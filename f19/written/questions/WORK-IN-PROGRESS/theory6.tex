\documentclass[12pt]{exam}
\newcommand{\hwnumber}{6}
\newcommand{\hwname}{Peg Solatire}

%%% begin hw-packages-and-macros.tex
\usepackage{amsmath}
\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{fancybox}
\usepackage{color}
\usepackage[all]{xy}
\usepackage{wrapfig}
\usepackage{fancyvrb}
\usepackage[T1]{fontenc}
\usepackage{listings}

\newcommand{\fillinlistings}{
    \lstset{ %
    language=C, numbers=left, numberstyle=\footnotesize, stepnumber=1,
    numbersep=4pt, showspaces=false, showstringspaces=false, tabsize=4,
    breaklines=true, breakatwhitespace=false,
    basicstyle=\normalsize\fontfamily{fvm}\selectfont, columns=flexible,
    mathescape=true, escapeinside={(*}{*)},
    morekeywords={alloc, allocarray, assert},
    otherkeywords={@requires, @ensures, @loop_invariant, @assert}
    }
}
\newcommand{\normallistings}{
    \lstset{ %
    language=C, numbers=left, numberstyle=\footnotesize, stepnumber=1,
    numbersep=4pt, showspaces=false, showstringspaces=false, tabsize=4,
    breaklines=true, breakatwhitespace=false,
    basicstyle=\footnotesize\fontfamily{fvm}\selectfont, columns=flexible,
    mathescape=true, escapeinside={(*}{*)},
    morekeywords={alloc, allocarray, assert},
    otherkeywords={@requires, @ensures, @loop_invariant, @assert}
    }
}

\newcommand{\semester}{Summer One 2013}

\newcommand{\Cnought}{C$0$}
\newcommand{\modulo}{\ \texttt{\%}\ }
\renewcommand{\lshift}{\ \texttt{<<}\ }
\renewcommand{\rshift}{\ \texttt{>>}\ }
\newcommand{\cgeq}{\ \texttt{>=}\ }
\newtheorem{task}{Task}
\newtheorem{ectask}{Extra Credit Task}
\newtheorem{exercise}{Exercise}

\newcommand{\answerbox}[1]{
\begin{framed}
\hspace{5.65in}
\vspace{#1}
\end{framed}}

\pagestyle{head}

\headrule \header{\textbf{15-122 Homework \hwnumber}}{}{\textbf{Page
\thepage\ of \numpages}}

\pointsinmargin \printanswers

\setlength\answerlinelength{2in} \setlength\answerskip{0.3in}
%%% end hw-packages-and-macros.tex

\begin{document}
\addpoints
\begin{center}
\textbf{\large{15-122 : Principles of Imperative Computation, \semester
\\  \vspace{0.2in} Homework~\hwnumber~Theory 
}}

 \vspace{0.2in}

 \large{Due: Thursday, June 13, 2013, at the {\bf beginning} of lecture}
\end{center}

\vspace{0.5in}

\hbox to \textwidth{Name:\enspace\hrulefill}


\vspace{0.2in}

\hbox to \textwidth{Andrew ID:\enspace\hrulefill}

\vspace{0.2in}

\hbox to \textwidth{Recitation:\enspace\hrulefill}


\vspace{0.5in}

\noindent The written portion of this weekï¿½s homework will give you
some practice working with hash tables and trees. You can either type
up your solutions or write them \textit{neatly} by hand in the spaces
provided. You should submit your work in class on the due date just
before lecture or recitation begins. Please remember to
\textit{staple} your written homework before submission.
\vspace{0.2in}

\begin{center}
\gradetable[v][questions]
\end{center}

\vspace{0.2in}
\begin{center}
  \Large{You {\it must} use this printout, include this cover sheet,

    and staple the whole thing together before turning it in.
  
    Either type up the assignment using the TeX source from the
    website or 

    print this PDF and write your answers \textit{neatly} by
    hand.}
\end{center}


\newpage
\begin{questions}



 \newpage
 \question{\textbf{Hash Tables using Separate Chaining.}}

Refer to the \Cnought{} code below for \verb"is_ht" that checks that a given hash table \verb"ht" is a valid hash table.
\begin{verbatim}
struct list_node {
  elem data;
  struct list_node* next;
};
typedef struct list_node list;

struct ht_header {
  list*[] table;
  int m;     // m = capacity = maximum number of chains table can hold
  int n;     // n = size = number of elements stored in hash table
};
typedef struct ht_header* ht;

bool is_ht(ht H) {
  if (H == NULL) return false;
  if (!(H->m > 0)) return false;
  if (!(H->n >= 0)) return false;
  //@assert H->m == \length(H->table);
  return true;
}
\end{verbatim}

An obvious data structure invariant of our hash table is that every
element of a chain hashes to the index of that chain.
This specification function is incomplete, then:
we never test that the contents of the hash table
hold to this data structure invariant. That is, we test only on the
struct ht, and not the properties of the array within. 

You may assume the existence of the following client functions as
discussed in class:

\begin{verbatim}
int hash(key k, int m)
//@requires m > 0;
//@ensures 0 <= \result && \result < m;
  ;

bool key_equal(key k1, key k2);

key elem_key(elem e)
//@requires e != NULL;
  ;
\end{verbatim}

\newpage
\begin{parts}
\part[4]
Extend \verb"is_ht" from above, adding code to check
that every element in the hash table matches the chain
it is located in, and that each chain is non-cyclic.

\begin{solution}
\begin{verbatim}
bool is_ht(ht H) {
  if (H == NULL) return false;
  if (!(H->m > 0)) return false;
  if (!(H->n >= 0)) return false;
  //@assert H->m == \length(H->table);
     
  int numnodes = 0;

  for (int i = 0; i < ________________; i++)
  {
    // set p equal to a pointer to first node 
    // of list i in table, if any

    list* p = __________________________________________________;    

    while (_____________________________________________________)
    {
      elem e = p->data;
 
      if ((e == NULL) || (________________________________ != i)) 

        return false;

      numnodes++;

      if (numnodes > ___________________________________________) 

        return false;

      p = ______________________________________________________;

    }
  }

  if (__________________________________________________________) 

    return false;

  return true;
}
\end{verbatim}
\end{solution}
\end{parts}


\newpage
\question{\textbf{Linear and quadratic probing}}

Consider two alternate implementations of hash tables that use an
array only (no chains), using linear/quadratic probing to resolve
collisions. In linear probing, if a key $k$ is inserted or looked up, on
the $(i+1)$st attempt we look at index $(h(k) + i) \mod m$, where $h$
is the hash function being used and $m$ is the size of the table. (We
succeed in insert if we find NULL there; we succeed in lookup if we
find an element there with matching key.)
Similarly, in quadratic probing, we look at index $(h(k) + i^2) \mod
m$ on the $(i+1)$st attempt.

Note that for this question, the hash function $h(k)$ does not perform
a modulus by the table size.  Also, for this question, you may assume
that there is no integer overflow (i.e. even for large i, $i^2$ will
still be non-negative).

\begin{parts}
\part[4] Assume that we hash a set of integer keys
into a hash table of capacity $m = 11$ using a hash function
$h(k) = k$.

In the first set of boxes, show where the following sequence of keys are stored
in the hash table if they are inserted in the order shown
using linear probing to resolve collisions.

In the second set, show the same but with quadratic probing.

\begin{verbatim}

54, 67, 23, 88, 39, 98, 72

\end{verbatim}

\begin{solution}
\begin{verbatim}

With Linear Probing:

       0    1    2    3    4    5    6    7    8    9   10
     ------------------------------------------------------
    |    |    |    |    |    |    |    |    |    |    |    |
     ------------------------------------------------------


With Quadratic Probing:

       0    1    2    3    4    5    6    7    8    9   10
     ------------------------------------------------------
    |    |    |    |    |    |    |    |    |    |    |    |
     ------------------------------------------------------

\end{verbatim}
\end{solution}

\clearpage
\part[2]

Quadratic probing suffers from one problem that linear probing does not.
In particular, given a non-full hashtable, insertions with linear probing will always
succeed, while insertions with quadratic probing may or may not succeed (i.e. they may
never find an open spot to insert).

Give an example of a non-full hashtable and a key that cannot be successfully inserted
using quadratic probing.  Use $h(k) = k$ as your hash function and $m = 6$ as your table capacity.

\begin{solution}

\begin{verbatim}

Non-Full Hashtable:                    Key to Insert:

       0    1    2    3    4    5           
     -----------------------------           ----
    |    |    |    |    |    |    |         |    |
     -----------------------------           ----
\end{verbatim}
\end{solution}

% \input{open-addressing-question.tex}

\end{parts}

\vspace{.5in}

\question{\textbf{BSTs.}}

In this question, we will think about the implementation of binary
search trees. The \verb|is_bst| and \verb|is_ordered| functions are
implemented as follows:

\begin{verbatim}
bool is_ordered(tree* T, elem lower, elem upper) {
  if (T == NULL) return true;
  if (T->data == NULL) return false;
  key k = elem_key(T->data);
  if (!(lower == NULL || key_compare(elem_key(lower),k) < 0))
    return false;
  if (!(upper == NULL || key_compare(k,elem_key(upper)) < 0))
    return false;
  return is_ordered(T->left, lower, T->data)
    && is_ordered(T->right, T->data, upper);
}

bool is_bst(bst B) {
  if (B == NULL) return false;
  return is_ordered(B->root, NULL, NULL);
}
\end{verbatim}
Remember that we cannot compare elements or keys directly with the C0
comparison operations; we have to use the client function
\verb'elem_key' to extract a key from an element and use the client
function \verb'key_compare' to compare keys.

\newpage
\begin{parts}
  \part[2]\label{part:search} It is possible to implement \verb|bst_search| 
  as an iterative function rather than a recursive one. Fill in the
  blanks so that the below function correctly implements
  \verb|bst_search|.  

  The lines involving the variables \verb|lower| and \verb|upper| are
  used only to prove that the loop invariant is preserved. You should
  not use \verb|lower| or \verb|upper| when filling in the blanks.
 
\begin{solution}
\begin{verbatim}
/*  1 */ elem bst_search(bst B, key k)
/*  2 */ //@requires is_bst(B);
/*  3 */ /*@ensures \result == NULL
/*  4 */         || key_compare(k, elem_key(\result)) == 0; @*/
/*  5 */ {
/*  6 */   tree* T = B->root;
/*  7 */   elem lower = NULL;
/*  8 */   elem upper = NULL;
/*  9 */ 
/* 10 */   while (______________________________________________)
/* 11 */   //@loop_invariant is_ordered(T, lower, upper);
/* 12 */   {
/* 13 */     if (______________________________________________) {
/* 14 */       upper = T->data;
/* 15 */       T = T->left;
/* 16 */     } 
/* 17 */     else {
/* 18 */       lower = T->data;
/* 19 */       T = T->right;
/* 20 */     }
/* 21 */   }
/* 22 */  
/* 23 */   if (T == NULL) return NULL;
/* 24 */   return T->data;
/* 25 */ }
\end{verbatim}
\end{solution}

\newpage
\part[4]\label{part:correctness}
Prove that the code you wrote on lines \verb'10' and \verb'13' is safe
-- that pointer dereferences are safe and that the preconditions of
any function you call are satisfied. You may assume that the
loop invariant is correct. (Don't forget that \verb'elem_key'
has a precondition!)
\begin{solution}
\vspace{2 in}
\end{solution}
Prove that the loop invariant is true initially.
\begin{solution}
\vspace{1 in}
\end{solution}
Prove that the loop invariant is preserved by any iteration of the
loop.  There are two cases that to show; just show the case where
the conditional on line \verb'13' evaluates to \verb'true'.
\begin{solution}
\vspace{3 in}
\end{solution}


\newpage
\part[4]
The ordering invariant of BSTs makes it possible to print the elements of
the BST in descending order, without having to use a temporary data
structure to store and/or sort any of the elements. Write a function
\verb'bst_print_desc(bst B)' that prints the elements of a BST in
\emph{descending order} using a helper function
\verb'tree_print_desc(tree* T)'.

You can assume that you have a client-provided function
\verb'elem_print(elem e)' that prints an element. Your solution should
be simple and straightforward, so try hard to think of a way to do
this elegantly; overly complex code will cost points.

\begin{solution}
\begin{verbatim}
void tree_print_desc(tree* T)
//@requires is_ordered(T, NULL, NULL);
{






















}

void bst_print_desc(bst B)
//@requires is_bst(B);
{

      ___________________________________________________________;
      return;
}
\end{verbatim}
\end{solution}

\end{parts}

\end{questions}

\end{document}
