%% See bottom of file

\clearpage
\Question{Generic Algorithms}

A generic comparison function might be given a type as follows in C1:
\begin{lstlisting}[numbers=none]
typedef int compare_fn(void* x, void* y)
  //@ensures -1 <= \result && \result <= 1;
\end{lstlisting}
(Note: there's no precondition that \lstinline'x'
and \lstinline'y' are necessarily non-\lstinline'NULL'.)

If we're given such a function, we can treat \lstinline'x' as being less than
\lstinline'y' if the function returns \lstinline'-1', treat \lstinline'x' as
being greater than \lstinline'y' if the function returns \lstinline'1', and
treat the two arguments as being equal if the function returns \lstinline'0'.

Given such a comparison function, we can write a function to check
that an array is sorted even though we don't know the type of its
elements (as long as it is a pointer type):
\begin{lstlisting}[numbers=none]
bool is_sorted(void*[] A, int lo, int hi, compare_fn* cmp)
  //@requires 0 <= lo && lo <= hi && hi <= \length(A) && cmp != NULL;
\end{lstlisting}

\begin{parts}
\enlargethispage{5ex}
\part[1]\TAGS{function-pointer, genericity, void-star}
Complete the generic binary search function below. You don't have
access to generic variants of \lstinline'lt_seg' and
\lstinline'gt_seg'. Remember that, for sorted integer arrays,
\lstinline'gt_seg(x, A, 0, lo)' was equivalent to %
\lstinline'lo == 0 || A[lo - 1] < x'.

\medskip
\begin{framed}
\begin{lstlisting}[aboveskip=0pt, belowskip=0pt]
[*\hspace{-0.5em}*]int binsearch_generic(void* x, void*[] A, int n, compare_fn* cmp)
//@requires 0 <= n && n <= \length(A) && cmp != NULL;
//@requires is_sorted(A, 0, n, cmp);
{
   int lo = 0;
   int hi = n;

   while (lo < hi)
   //@loop_invariant 0 <= lo && lo <= hi && hi <= n;

   //@loop_invariant lo == [*\uanswer{3em}{0}*] || [*\uanswer{12em}{(*cmp)(A[lo - 1], x)}*] == -1;

   //@loop_invariant hi == [*\uanswer{3em}{n}*] || [*\uanswer{12em}{(*cmp)(A[hi], x)}*] == 1;
   {
      int mid = lo + (hi - lo)/2;

      int c = [*\uanswer{24em}{(*cmp)(A[mid], x)}*];

      if (c == 0) return mid;
      if (c < 0) lo = mid + 1;
      else hi = mid;
   }
   return -1;
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (a)
TAGS: function-pointer, genericity, void-star

Gradescope rubric:
+0.5  Invokes function pointers correctly in all 3 instances (*cmp)(A[indx], x)
+0.25 Loop invariants correctly check bounds and attempt to call cmp function with right arguments
+0.25 Attempts to call cmp function with correct arguments (A[mid], x)

Commentary:
  - Solutions: (lo == 0 || (*cmp)(A[lo - 1], x) < 0)
                           (*cmp)(A[lo - 1], x) == -1
                           (*cmp)(x, A[lo - 1]) > 0
                           (*cmp)(x, A[lo - 1]) == 1
               (hi == n || (*cmp)(x, A[hi]) < 0)
                           (*cmp)(x, A[hi]) == -1
                           (*cmp)(A[hi], x) > 0
                           (*cmp)(A[hi], x) == 1
               int c = (*cmp)(A[mid], x)
     ** 1/4 point is for edge case/correctness
     ** 1/4 point is for correctly invoking function pointer
     ** 1/4 point is for getting directionality right
ENDRUBRIC

\newpage
\begin{EnvUplevel}
  Suppose you have a generic sorting function, with the following contract:
\begin{lstlisting}[numbers=none]
void sort_generic(void*[] A, int lo, int hi, compare_fn* cmp)
  //@requires 0 <= lo && lo <= hi && hi <= \length(A) && cmp != NULL;
  //@ensures is_sorted(A, lo, hi, cmp);
\end{lstlisting}
\end{EnvUplevel}

%\input{sort-int} % S19 F17 F16 S16
\input{sort-char} % F19 S18 S17
%\input{sort-pixel} % F18 -- see file

\end{parts}