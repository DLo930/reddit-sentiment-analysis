\clearpage
\Question{C0VM}

Consider the following C0 code that populates a structure with values.
\lstinputlisting[columns=fixed]{\code/gb.c0}

\begin{parts}
\part[2\half]\TAGS{c0vm}
Fill in the missing instructions (on the next page) in the following
bytecode that corresponds to the above C0 code. You don't need to
fill in the hex opcodes. Just the instruction name and its argument(s)
in decimal is sufficient.  Be careful, the answers may or may not
match the bytecode output generated by compiling the C0 code
directly.

\bigskip
\begin{lstlisting}[language=C0VM,frame=single,showlines,lineskip=3pt,name=c0vm-gb]
C0 C0 FF EE       # magic number
00 13             # version 9, arch = 1 (64 bits)

00 03             # int pool count
# int pool
00 00 BB F0
00 10 00 FF
00 01 00 00

00 00             # string pool total size
# string pool

00 01             # function count
# function_pool

\end{lstlisting}


\vfill
(bytecode continues on next page)
\newpage
(continued from previous page)

\medskip
\newcommand{\bsep}[1]{\uanswer{4.79em}{#1\hfill}}
\newcommand{\isep}[1]{\uanswer{7.75em}{#1\hfill}}
\begin{lstlisting}[language=C0VM,frame=single,lineskip=5pt,name=c0vm-gb]
#<main>
00 00             # number of arguments = 0
00 01             # number of local variables = 1
00 2B             # code length = 43 bytes
BB 18    # new 24        # alloc(gapbuf)
[*\bsep{36 00}*] # [*\isep{vstore 0}*] # gb = alloc(gapbuf);
15 00    # vload 0       # gb
62 00    # aaddf 0       # &gb->limit
[*\bsep{13 00 02}*] # [*\isep{ildc 2}*] # 65536
4E       # imstore       # gb->limit = 65536;
15 00    # vload 0       # gb
62 08    # aaddf 8       # &gb->buffer
[*\bsep{13 00 02}*] # [*\isep{ildc 2}*] # 65536
[*\bsep{BC 01}*] # [*\isep{newarray 1}*] # alloc_array(char, 65536)
4F       # amstore       # gb->buffer = alloc_array(char, 65536);
15 00    # vload 0       # gb
62 10    # aaddf 16      # &gb->gap_start
13 00 00 # ildc 0        # 48112
4E       # imstore       # gb->gap_start = 48112;
15 00    # vload 0       # gb
62 14    # aaddf 20      # &gb->gap_end
15 00    # vload 0       # gb
[*\bsep{62 10}*] # [*\isep{aaddf 16}*] # &gb->gap_start
2E       # imload        # gb->gap_start
4E       # imstore       # gb->gap_end = gb->gap_start;
10 01    # bipush 1      # 1
B0       # return        #

00 00             # native count
# native pool
\end{lstlisting}


\RUBRIC
Part (a)
TAGS: c0vm

Gradescope rubric:
+ 0.5 pts  1st blank: vstore 0
+ 0.5 pts  2nd blank: ildc 2
+ 0.5 pts  3rd blank: ildc 2
+ 0.5 pts  4th blank: newarray 1
+ 0.5 pts  5th blank: aaddf 16

Commentary:
  Half point per blank, minor typos in the names of
  bytecode instructions (aadd instead of aaddf) aren't a big deal.

        # new 24
        #          __vstore 0__
        # vload 0
        # aaddf 0
        #          __ildc 2__
        # imstore
        # vload 0
        # aaddf 8
        #          __ildc 2__
        #          __newarray 1__
        # amstore
        ...
        # vload 0
        #          __aaddf 16__
        # imload
ENDRUBRIC


\newpage
\part[1\half]\TAGS{c0vm}
After executing line 26 of the byte code, there will only be one value
on the operand stack; assume it is the pointer \lstinline'0x3fff0000'.

Draw the four operand stack states after each of lines 26--29 is
executed. The elements in your stack should be 32-bit hexadecimal
numbers. The top of your stack should be on the right-hand
side. Assume that \lstinline'alloc_array' returns \lstinline'0x80000000'.

\begin{framed}
\newcommand{\ans}[1]{\uanswer{8em}{\tt #1}}

Immediately after executing line 26: \lstinline[language=opsem]'vload 0'

\bigskip
\ans{0x3fff0000:*}, \ans{}, \ans{}, \ans{}

\bigskip
\bigskip
Immediately after executing line 27: \lstinline[language=opsem]'aaddf 8'

\bigskip
\ans{0x3fff0000:*}, \ans{}, \ans{}, \ans{}

\bigskip
\bigskip
Immediately after executing line 28: (you wrote that line, it pushed \lstinline'65536')

\bigskip
\ans{0x3fff0000:*}, \ans{65536:w32}, \ans{}, \ans{}

\bigskip
\bigskip
Immediately after executing line 29: \lstinline[language=opsem]'____________'

\bigskip
\ans{0x3fff0000:*}, \ans{0x80000000:*}, \ans{}, \ans{}

\end{framed}

\RUBRIC
Part (b)
TAGS: c0vm

Gradescope rubric:
+ 0.35pts (line 26): 0x3fff0000:*
+ 0.35pts (line 27): 0x3fff0008:*
+ 0.4pts (line 28): 0x3fff0008:*, 65536:w32
+ 0.4pts (line 29): 0x3fff0008:*, 0x80000000:*

Commentary:
  Half point per blank.
   - Types (*, w32) are not necessary
   - Dec/hex is fine, 0x3fff0000 == 1073676296
                      0x80000000 == 2147483648 or -2147483648
                      0x10000 == 65536
   - Only take off half a point overall if stacks are consistently
     represented in an order different from the one in the handout.
   - Take off one point if they miscalculate the AADDF
     (adding 64 = 0x40 instead of 8, for instance).
   - If wrong 1(a) answer leads to wrong 1(b) answer, grade generously

   Line 26: vload 0
                     0x3fff0000:*
   Line 27: aaddf 8
                     0x3fff0008:*
   Line 28: ildc 1 or 2
                     0x3fff0008:*, 65536:w32
   Line 29: newarray 1
                     0x3fff0008:*, 0x80000000:*
ENDRUBRIC

\end{parts}
