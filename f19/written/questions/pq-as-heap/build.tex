\newpage
\part[1]\TAGS{array, correctness, interface, pq}
The library function \lstinline'heap_build', shown below, takes an
array of data elements (ignoring index 0 of the array) and builds our
array-based min-heap \emph{in place}. That is, it uses the given array
inside of the heap structure rather than allocating a new array.

%\smallskip
\begin{lstlisting}
heap* heap_build(elem[] E, int n, higher_priority_fn* priority)
//@requires 0 < n && n <= \length(E) && priority != NULL;
//@ensures is_heap(\result);
{
  heap* H = alloc(heap);
  H->limit = n;
  H->next = 1;
  H->data = E;
  H->prior = priority;
  for (int i = 1; i < n; i++) {
    pq_add(H, E[i]);
  }
  return H;
}
\end{lstlisting}

%\smallskip
This code disrespects the boundary between the client and the
library. (Do you see why?) Use the functions \lstinline'int_to_elem'
and \lstinline'int_compare' to create a test case where the
postcondition of \lstinline'build_broken_heap' will always
succeed. Assume that the function \lstinline'int_compare' treats lower
integers as higher priority, so the heap we're building will be a
min-heap.

\begin{framed}
\begin{lstlisting}[aboveskip=0pt,belowskip=0pt]
elem int_to_elem(int n)
  /*@ensures \result != NULL && \hastag(int*, \result); @*/
  /*@ensures n == *(int*)\result; @*/ ;
bool int_compare(elem x, elem y)
  /*@requires x != NULL && \hastag(int*, x); @*/
  /*@requires y != NULL && \hastag(int*, y); @*/ ;

heap* build_broken_heap(elem[] E, int n)
//@requires 3 <= n && n <= \length(E);
//@ensures !is_heap(\result);
{
  heap* H = heap_build(E, n, &int_compare);

  E[1] = [*\uanswer{31em}{1}*];

  E[2] = [*\uanswer{31em}{0}*];

  return H;
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (pq_build)
TAGS: array, correctness, interface, pq

Gradescope rubric:
+1pt Any integers such that E[1] > E[2]
-0.5pt Incorrect use of int_to_elem

Commentary:
  E[1] must be a greater integer (lower priority) than E[2],
  all or nothing there.
  Half point penalty if they don't use the int_to_elem helper function
  correctly.
ENDRUBRIC
