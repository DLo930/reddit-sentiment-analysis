\part[0\half]\TAGS{array, pq}
Consider a non-empty priority queue of $n$ elements, each with a
different priority.  This priority queue is represented using the
array implementation of min-heaps. Give the exact range (inclusive), in
terms of $n$, of array indexes where any element of lowest priority
might occur. You may use mathematical notation or C0 notation.
\begin{framed}
\medskip
\answer{\linewidth}{$[1 + \lfloor n/2 \rfloor, n]$}
\end{framed}

\RUBRIC
Part (b)
TAGS: array, pq

Gradescope rubric:
+0.5pt Correct answer (One example: [1+floor(n/2), n] )

Commentary:
Full credit for mathematical or C0 notation equivalent
to the following. Don't worry about parens or brackets as long as it's
clear what is the lower bound and what is the upper bound. No credit
for off-by-one errors.
  - [1+floor(n/2), n] in math, i.e., [1+n/2, n] in C0
  - [ceil((n+1)/2), n] in math
ENDRUBRIC

\newpage
\part[0\half]\TAGS{interface, pq}
Complete the function \lstinline'heap_lowest', which returns (but does not
remove) the element with the lowest priority from a min-heap stored as
an array. The function template below is missing some loop invariants
that would be needed to ensure safety; you don't have to add these.

You can use helper functions from the published \lstinline'heap.c1'
or functions in the client interface. \emph{You shall examine only
  those elements that might contain the lowest priority element.}

\begin{framed}
\begin{lstlisting}[aboveskip=0pt, belowskip=0pt]
elem heap_lowest(heap* H)
//@requires is_heap(H) && !pq_empty(H);
//@ensures is_heap(H);
{
   int index = [*\uanswer{28em}{(H->next + 1) / 2}*];

   for (int i = [*\uanswer{8em}{index+1}*]; i < [*\uanswer{8em}{H->next}*]; i++) {

       if ([*\uanswer{29em}{(*H->prior)(H->data[index], H->data[i])}*]) {
           index = i;
       }
   }
   return [*\uanswer{31em}{H->data[index]}*];
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (pq_lowest)
TAGS: interface, pq

Gradescope rubric:
+0.1pt 1st blank: correct starting point
+0.1pt 2nd&3rd blanks: correct range or consistent with previous task
+0.15pt 4th blank: correct conditional check
+0.15pt 5th blank: return correct lowest-priority element

Commentary:
  +1/4 point for the first slot. If they write H->next / 2 then
  they don't get this point.

      int index = ___(H->next + 1) / 2___;

  +1/2 point for the for loop. It's okay if they start i at
  index+1 instead of index!

      for (int i = ___index+1___; i < ___H->next___; i++)

  +1/2 point for the conditional check
        if (___(*H->prior)(H->data[index], H->data[i])___);
        if (___ok_above(H, index, i)___)

  +1/4 point for the return (can't return index, must dereference array)

      return ___H->data[index]___;
ENDRUBRIC
