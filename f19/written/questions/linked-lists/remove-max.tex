\newpage
\part[1\half]\TAGS{linked-correctness, list, safety}
Complete the function below that removes the maximum integer from a
non-empty linked list of integers.  The specification function
\lstinline'gt_listseg(x,s,e)' checks that \lstinline'x' is strictly
larger than every element in the list segment between \lstinline's'
inclusive and \lstinline'e' exclusive.  You may assume there are no
duplicate elements. (Note that loop invariants are not given so we
can't reason about the safety of the code.)

\begin{framed}
\begin{lstlisting}[aboveskip=0pt,belowskip=0pt]
int remove_max(linkedlist a) {

  //@requires [*\uanswer{16.8em}{a != NULL \&\& a->start != a->end}*];  // List not empty
  //@requires is_segment(a->start, a->end);
  //@ensures  is_segment(a->start, a->end);
  //@ensures gt_listseg(\result, a->start, a->end);

  list* first = a->start;
  list* curr = first->next;
  list* prev = first;
  list* max = first;
  list* max_prev = first;

  while ([*\uanswer{30em}{curr != a->end}*]) {
    if (curr->data > max->data) {

       max_prev = [*\uanswer{26em}{prev}*];

       max = [*\uanswer{29em}{curr}*];
    }
    prev = [*\uanswer{30.2em}{curr}*];

    curr = [*\uanswer{30.2em}{curr->next}*];
  }
  if (max == max_prev)

    [*\uanswer{34.5em}{ a->start = a->start->next}*];

  else [*\uanswer{32.7em}{max\_prev->next = max->next}*];
  return max->data;
}
\end{lstlisting}
\end{framed}

\enlargethispage{5ex}
Explain in one sentence why the second postcondition specified in the
function above is not strong enough to reason that this function
removes and returns the maximum integer from the non-empty linked
list.
\begin{framed}
\bigskip\medskip
\answer{34em}{Because \result{} may not be in the original list.\hfill}
\end{framed}

\RUBRIC
Part (d)
TAGS: linked-correctness, list, safety

Gradescope rubric:
+0.1pt  //@requires a != NULL && a->start != a->end;
+0.1pt  while (curr != a->end)
+0.1pt  max_prev = prev;
+0.1pt  max = curr;
+0.1pt  prev = curr;
+0.1pt  curr = curr->next;
+0.2pt  if () a->start = a->start->next;
+0.2pt  else max_prev->next = max->next;
+0.5pt  (2nd box) Because \result may not be in the original list

Commentary:

There are lots of right answers for the a->start = a->start->next line!
Draw it out and check whether the student's answer works!

int remove_max(linkedlist a) {
    //@requires a != NULL;
    //@requires is_segment(a->start, a->end);
    //@ensures  is_segment(a->start, a->end);
    //@ensures gt_listseg(\result, a->start, a->end);

    list* first = a->start;
    list* curr = first->next;
    list* prev = first;
    list* max = first;
    list* max_prev = first;

    while (curr != a->end) {
        if (curr->data > max->data) {
             max_prev = prev;
             max = curr;
        }
        prev = curr;
        curr = curr->next;
    }
    if (max == max_prev)
       a->start = a->start->next;
    else
       max_prev->next = max->next;
    return max->data;
}
ENDRUBRIC
