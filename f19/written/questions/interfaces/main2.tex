\clearpage
\bgroup
\newcommand{\elem}
%{string} % before F18
{char} % F18

\Question{Queues, Stacks, and  Interfaces}

\begin{parts}
\part[1]\TAGS{interface, queue}
Consider the following interface for queues that stores elements of
type \texttt{\elem}:

\begin{lstlisting}
/* Queue Interface */
// typedef ______* queue_t;

bool queue_empty(queue_t Q)    // O(1), check if queue empty
/*@requires Q != NULL; @*/;

queue_t queue_new()            // O(1), create new empty queue
/*@ensures \result != NULL; @*/
/*@ensures queue_empty(\result); @*/;

void enq(queue_t Q, [*\elem*] e)    // O(1), add item at back of queue
/*@requires Q != NULL; @*/;

[*\elem*] deq(queue_t Q)            // O(1), remove item from front
/*@requires Q != NULL; @*/
/*@requires !queue_empty(Q); @*/ ;
\end{lstlisting}

Using this interface, write a \underline{client} function
\lstinline'queue_back(queue_t Q)' that returns the element at the
\emph{back} of the given queue, assuming the queue is not empty.  The
back of a queue is the most recently inserted element --- do not
confuse it with the element returned by \lstinline'deq', the front of
the queue, i.e., the element that has been in the queue the longest.
Upon returning, the queue \lstinline'Q' should be identical to the
queue passed to the function.  For this task, use only the interface
since, as a client, you do not know how this data structure is
implemented.  Do not use any queue functions that are not in the
interface (including specification functions like \lstinline'is_queue'
since these belong to the implementation).

\enlargethispage{5ex}
\begin{framed}
\begin{lstlisting}[aboveskip=0pt, belowskip=0pt]
[*\elem*] queue_back(queue_t Q)
//@requires Q != NULL;
//@requires !queue_empty(Q);
{
\end{lstlisting}
\ifprintanswers
\begin{lstlisting}[basicstyle=\basicstyle\color{\answerColor}]
  queue_t T = queue_new();
  [*\elem*] back;
  while (!queue_empty(Q)) {
    back = deq(Q);
    enq(Q, back);
  }
  while (!queue_empty(T)) {
    enq(Q, deq(T));
  }
  return back;
\end{lstlisting}
\else~\vspace{2.0in}\fi
\begin{lstlisting}[aboveskip=0pt, belowskip=0pt]
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (a)
TAGS: interface, queue

Gradescope rubric:
+0pt EITHER --- iterative solution:
+0.25pts Allocates a new temporary queue
+0.25pts Loop that empties Q onto tmp queue, another loop that puts elements back
+0.5pts Correctly grabs, restores, and returns the last element.
+0pt OR --- recursive solution:
+0.5pts Check for empty queue before making recursive call
+0.5pts Correctly grabs, restores, and returns the back element.
-1 pts Interface violation
-0.1pt variable out of scope

Commentary:
- replace the type ELEM with the actual type for this semester
ELEM queue_back(queue_t Q)
//@requires Q != NULL;
//@requires !queue_empty(S);
{
  queue_t T = queue_new();
  ELEM back;
  while (!queue_empty(Q)) {
      back = deq(Q);
      enq(Q, back);
    }
  while (!queue_empty(T)) {
    enq(Q, deq(T));
  }
  return back;
}

(recursive solution)
ELEM queue_back(queue_t Q)
//@requires Q != NULL;
//@requires !queue_empty(Q);
{
  ELEM x = deq(Q);
  if (!queue_empty(Q))
    x = queue_back(Q);
  enq(Q, x);
  return x;
}

  - No points if they violate the interface
  - 1 point for allocating a new queue
  - 1/2 point for loop that emptying onto tmp queue and another that restores the original queue
  - 1/2 point for getting back element correctly (there are several correct possibilities)
ENDRUBRIC


\newpage
\begin{EnvUplevel}
Below is the stack interface from lecture (with elements of type
\texttt{\elem}).
\begin{lstlisting}
// typedef ______* stack_t;

bool stack_empty(stack_t S)         // O(1), check if stack empty
/*@requires S != NULL; @*/;

stack_t stack_new()                 // O(1), create new empty stack
/*@ensures \result != NULL; @*/
/*@ensures stack_empty(\result); @*/;

void push(stack_t S, [*\elem*] x)        // O(1), add item on top of stack
/*@requires S != NULL; @*/;

[*\elem*] pop(stack_t S)                 // O(1), remove item from top
/*@requires S != NULL; @*/
/*@requires !stack_empty(S); @*/
\end{lstlisting}

The following is a client function \lstinline'stack_reverse' that is
intended to return a copy of its input stack \lstinline'S' with its
elements in reverse order while leaving \lstinline'S' unchanged.

\begin{quote}
\begin{lstlisting}[firstnumber=50, aboveskip=2pt, belowskip=2pt]
stack_t stack_reverse(stack_t S)
//@requires S != NULL;
//@ensures \result != NULL;
{
  stack_t RES = stack_new();
  stack_t TMP = S;
  while (!stack_empty(S)) {
    [*\elem*] x = pop(S);
    push(TMP, x);
    push(RES, x);
  }
  while (!stack_empty(TMP)) push(S, pop(TMP));
  return RES;
}
\end{lstlisting}
\end{quote}
\end{EnvUplevel}

\enlargethispage{5ex}
\part[0\half]\TAGS{interface, stack}
Explain why \lstinline'stack_reverse' does not work.
\begin{framed}
\medskip
\ifprintanswers{\color{\answerColor}
\lstinline'TMP' is an alias for \lstinline'S'. The first loop will not
terminate, since every element removed from \lstinline'S' is
immediately pushed onto \lstinline'S'.
}\else~\vspace{1.2in}\fi
\end{framed}

\newpage
\part[1]\TAGS{interface, stack}
Give a corrected version of \lstinline'stack_reverse'.
\begin{framed}
\begin{lstlisting}[firstnumber=50, belowskip=0pt]
stack_t stack_reverse(stack_t S)
//@requires S != NULL;
//@ensures \result != NULL;
{
\end{lstlisting}
\ifprintanswers
\begin{lstlisting}[basicstyle=\basicstyle\color{\answerColor}]
  stack_t RES = stack_new();
  stack_t TMP = stack_new();
  while (!stack_empty(S)) {
    ELEM x = pop(S);
    push(TMP, x);
    push(RES, x);
  }
  while (!stack_empty(TMP)) push(S, pop(TMP));
  return RES;
\end{lstlisting}
\else~\vspace{6.5in}\fi
\begin{lstlisting}[aboveskip=0pt, belowskip=0pt]
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (b)
TAGS: interface, stack

Gradescope rubric:
+0.5pt Explanation
+1pt Code revision

Commentary:
Explanation: TMP is an alias for S. The first loop will not terminate,
since every element removed from S is immediately pushed onto S.

Fix:
stack_t stack_reverse(stack_t S)
//@requires S != NULL;
//@ensures \result != NULL;
{
  stack_t RES = stack_new();
  stack_t TMP = stack_new();
  while (!stack_empty(S)) {
    ELEM x = pop(S);
    push(TMP, x);
    push(RES, x);
  }
  while (!stack_empty(TMP)) push(S, pop(TMP));
  return RES;
}

   - 1/2 point for explanation; they must mention at least one of the
     two points above (alias and/or infinite loop)

   - 1 point for code: they must initialize TMP using stack_new();
     they shouldn't change anything else. No penalty for correctly
     reversing the stack with the second loop instead of the first.
ENDRUBRIC

\end{parts}

\egroup
