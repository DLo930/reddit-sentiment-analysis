\part[1]\TAGS{bst, traverse-ds}
Assume the client also provides a function
\lstinline'entry_print(e)' that prints entry \lstinline'e'
in a readable format on one line.  Complete the function
\lstinline'dict_reverseprint' which prints the entries of
the given dictionary on one line in order from largest key to smallest
key.  If the dictionary is empty, nothing is printed. You will need a
\textbf{recursive} helper function \lstinline'tree_reverseprint' to
complete the task.

\emph{Think recursively: if you are at a non-empty node, what are the
  three things you need to print, and in what order?  You should not
  need to examine the keys since the contract guarantees the argument
  is a BST.}

\enlargethispage{5ex}
\begin{framed}
\begin{lstlisting}[aboveskip=0pt, belowskip=0pt]
void tree_reverseprint(tree* T)
//@requires is_bst(T);
{
\end{lstlisting}
\ifprintanswers
\begin{lstlisting}[basicstyle=\basicstyle\color{\answerColor}]
   if (T == NULL) return;
   tree_reverseprint(T->right);
   entry_print(T->data);
   tree_reverseprint(T->left);
\end{lstlisting}
\else~\vspace{3.5cm}\fi
\begin{lstlisting}[aboveskip=0pt, belowskip=0pt]
}

void dict_reverseprint(dict* D)
//@requires is_dict(D);
{
  tree_reverseprint([*\uanswer{24.5em}{D->root}*]);
  print("\n");
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (c)
TAGS: bst, traverse-ds

Gradescope rubric:
+0.25pt bst_reverseprint answer is correct: return B->root
+0.25pt tree_reverseprint correctly handles the base case (check if T == NULL and return if so)
+0.25pt Recursive calls happen in the correct order whenever T != NULL
+0.25pt Syntax and overall tree_reverseprint function is correct (possibly aside from the base case) and not needlessly complex

Commentary:
 1/2 point for the bst_reverseprint answer and correct handling of the base case
   (It doesn't work to implicitly assume and then enforce T != NULL as
   a precondition, because of the template we gave for bst_reverseprint. -1/2
   point if they try to do this and get it wrong.)
 1/2 point for the recursive calls and call to entry_print (and possibly
   printing spaces before and after; we don't care)
   (It's okay if they're mishandling the NULL case, though, -1/2 point
   if they get this in the wrong order, if they miss one, or if they
   don't correctly call entry_print)

 void tree_reverseprint(tree* T) {
   if (T == NULL) return;
   tree_reverseprint(T->right);
   entry_print(T->data);
   tree_reverseprint(T->left);
 }

 void bst_reverseprint(dict* D) {
   tree_reverseprint(D->root);

 }
ENDRUBRIC
