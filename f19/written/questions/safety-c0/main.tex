\clearpage
\Question{Safety in C0}\TAGS{safety}

We'll talk a lot in this class about proving that contracts
(preconditions, postconditions, annotations, and loop invariants) will
always evaluate to \lstinline'true'. This is important, because it's how we
prove a function correct.

Before we can even talk about correctness, though, we want to use our
contracts to think about \emph{safety}. There are five kinds of
safety violations that we've talked about so far in class:

\begin{itemize}
\item giving a function call arguments that violate its preconditions;
\item division or modulo by zero;
\item bitshifting an integer left or right by less than zero or more than
  31;
\item allocating an array with negative length; and
\item accessing an array out of bounds.
\end{itemize}

Whenever we have an operation that's potentially unsafe, we must be
able to point to contracts that ensure its safety \emph{without
  reasoning about multiple iterations of any loop at once}. That means
we may use the following facts:
\begin{itemize}
\item%
  When local variables are \emph{untouched} by a loop, statements we
  know to be true about those locals \emph{before} the loop remain
  valid \emph{inside} the loop and \emph{after} the loop.

\item%
  For local variables that are modified by the loop, the loop guard
  and the loop invariants are the only statements we can use.
  \begin{itemize}
  \item%
    Inside of a loop, we know that the loop invariants held just before the
    loop guard was checked and that the loop guard returned \lstinline'true'.
  \item%
    After a loop, we know that the loop invariants held just before the loop
    guard was checked for the last time and that the loop guard returned
    \lstinline'false'.
  \end{itemize}
\end{itemize}
We call this \emph{point-to reasoning}.  That's because we show that
our argument is supported by pointing to some lines of code.

For each of the problems below, \textbf{state whether the safety of each
  potentially unsafe operation is SUPPORTED or UNSUPPORTED given the existing
  contracts, and briefly explain your reasoning}.  You can assume that all
loop invariants are true initially (before the loop guard is checked the first
time) and that they are preserved by any iteration of the loop. If you claim
that the annotation is supported, your answer should be a concise proof; if you
claim that the annotation is unsupported, we only expect an informal argument
to explain why.

We've given two examples below.


\newpage
\input{example}

\begin{parts}

\newcounter{lineCounter}
\newcommand{\aLine}[3][1.5ex]
{\stepcounter{lineCounter}%
 \noindent\makebox[1em]{\alph{lineCounter})~~}\uanswer{21em}{#2}\hfill~by
 \uanswer{10em}{#3\hfill}\\[#1]%
}%
\newcommand{\noans}[1]{\textbf{#1}}
\newcommand{\ans}[1]{%
  \ifprintanswers%
  \textcolor{\answerColor}{\fbox{\noans{#1}}}%
  \else\noans{#1}\fi}

\RUBRIC
TAGS: safety
ENDRUBRIC

\newpage\input{exercise-1} % S16 (Goes together with example-1)
\newpage\input{exercise-2} % S16
\newpage\input{exercise-3} % S16

\end{parts}
