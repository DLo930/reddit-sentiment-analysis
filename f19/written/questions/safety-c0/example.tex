\begin{lstlisting}[numbers=left, aboveskip=0pt, belowskip=0pt]
void fill(int x, int[] A)
/*@requires x == \length(A); @*/;

int[] f(int x, int[] B)
//@requires 1 <= x && x < \length(B);
{
    int i = 1;
    int[] A = alloc_array(int, x);

    while (i < x)
    //@loop_invariant i >= 1;
    {
        B[i] = B[i] - 3;
        i += 1;
    }

    fill(i, A);
    return A;
}
\end{lstlisting}

\begin{framed}
\newcounter{lineCounterB}
\newcommand{\aLine}[3][0.8ex]
{\stepcounter{lineCounterB}%
 \noindent\makebox[1em]{\alph{lineCounterB})~~}\makebox[10em]{#2\hfill}~by
 \makebox[15em]{#3\hfill}\\[#1]%
}%

Safety of the array access on line 13 is: \underline{SUPPORTED}.

To show: \lstinline'0 <= i && i < \length(B)'

\medskip
\setcounter{lineCounterB}{0}
\aLine{\lstinline'i >= 1'}{line 11 (loop invariant)}
\aLine{\lstinline'0 <= i'}{math on (a) (because \lstinline'i >= 1')}
\aLine{\lstinline'i < x'}{line 10 (loop guard)}
\aLine{\texttt{x < \length(B)}}{line 5 (precondition)}
\aLine[-2ex]{\tt i < \length(B)}{(c) and (d)}
\end{framed}

\begin{framed}
Safety of the function call on line 17 is: \underline{UNSUPPORTED}.

We know by line 8 that \lstinline'\length(A) == x', so for the
function call to be safe we need to know \lstinline'i == x'.

By line 10, we know that the loop guard \lstinline'i < x' is false ---
that is, we know that \lstinline'!(i < x)', which is the same thing as
saying \lstinline'i >= x'. We can't conclude, from this, that \lstinline'i' is
equal to \lstinline'x'.
\end{framed}

With a different loop invariant on line 11, safety of the
function call on line 17 \textbf{would have been
  supported}. You'll demonstrate this in the next question.

\smallskip
That means that, even though we have a function call whose precondition will
never fail, our loop invariants aren't good enough for us to conclude (using
only point-to reasoning based on existing contracts) that the function call is
safe!
