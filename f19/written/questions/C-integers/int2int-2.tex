\part[1]\TAGS{c-array, c-memory, function-pointer}
Consider the following C definition for the factorial function:
\begin{framed}
\begin{lstlisting}
int factorial(int n) {
    REQUIRES (n >= 0);
    int result = 1;
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}
\end{lstlisting}
\end{framed}

\medskip
Use \lstinline'typedef' to define a C type named \lstinline'int2int_fn'
that represents a function pointer that requires an \lstinline'int' as
its parameter and returns an \lstinline'int' as its return type.
\begin{framed}
\begin{lstlisting}

typedef [*\uanswer{32em}{int int2int\_fn(int)}*];
\end{lstlisting}
\end{framed}

\medskip
Let the variable \lstinline'f' be of type
\lstinline'int2int_fn*'. (That is, \lstinline'f' is a function pointer to
a function that has one parameter of type \lstinline'int' and returns
a result of type \lstinline'int'.) Show how to initialize
\lstinline'f' with the address of the \lstinline'factorial' function
given above using the address-of operator.
\begin{framed}
\begin{lstlisting}

int2int_fn* f = [*\uanswer{27.3em}{\&factorial}*];
\end{lstlisting}
\end{framed}

\medskip
Write a C instruction that prints out 10! using the variable
\lstinline'f' defined above. Use an explicit derefencing operation on
\lstinline'f' to get to the factorial function.
\begin{framed}
\begin{lstlisting}

printf("10! = %d\n",[*\uanswer{23.7em}{(*f)(10)}*]);
\end{lstlisting}
\end{framed}

\medskip\enlargethispage{5ex}
Suppose we wanted to set \lstinline'x' equal to 8! using the function
above.  The following line causes a compilation error in C1.
\begin{lstlisting}
int x = f(8);
\end{lstlisting}
What about in C?  Try it out to determine whether this line is legal
in C.  Do you get the expected result?

\begin{framed}
\bigskip
\answer{34em}{YES: the C99 standard allows it (in the cryptic
  paragraph 6.3.1.4 on p.46).}
\end{framed}


\RUBRIC
Part <int2int-2>
TAGS: c-array, c-memory, function-pointer

Gradescope rubric:
+0.25pt 1st box: typedef int int2int_fn(int);
+0.25pt 2nd box: &factorial
+0.25pt 3rd box: (*f)(10)
+0.25pt 4th box: EITHER NO: we need to dereference f to apply it.
+0.25pt 4th box: OR     YES: gcc allows it.

Commentary: (see above)
For box 4: give points only if the justification is sensible.

ENDRUBRIC
