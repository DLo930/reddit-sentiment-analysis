\clearpage
\Question{A New Implementation of Queues}

Recall the interface for a stack that stores elements of the type
\lstinline'elem':

\begin{quote}
\begin{lstlisting}[numbers=none]
// typedef ______* stack_t;

bool stack_empty(stack_t S)              /* O(1) */
  /*@requires S != NULL; @*/;

stack_t stack_new()                      /* O(1) */
  /*@ensures \result != NULL; @*/
  /*@ensures stack_empty(\result); @*/;

void push(stack_t S, elem x)             /* O(1) */
  /*@requires S != NULL; @*/;

elem pop(stack_t S)                      /* O(1) */
  /*@requires S != NULL; @*/
  /*@requires !stack_empty(S); @*/;
\end{lstlisting}
\end{quote}

For this question you will analyze a different implementation of the
queue interface.  Instead of a linked list, this implementation uses
two stacks, called \lstinline'instack' and \lstinline'outstack'. To
enqueue an element, we push it on top of the \lstinline'instack'. To
dequeue an element, we pop the top off of the \lstinline'outstack'. If
the \lstinline'outstack' is empty when we try to dequeue, then we will
first move all of the elements from the \lstinline'instack' to
the \lstinline'outstack', then pop the \lstinline'outstack'.

For example, below is one possible configuration of a two-stack queue
containing the elements \lstinline'A' through \lstinline'E'
(\lstinline'A' is at the front and \lstinline'E' is at the back of the
abstract queue):
\begin{center}
\includegraphics[width=0.3\linewidth]{\img/twostack-queue.png}
\end{center}

We will use the following C0 code:

\begin{lstlisting}
typedef struct stackqueue_header stackqueue;
struct stackqueue_header {
  stack_t instack;
  stack_t outstack;
};

typedef stackqueue* queue_t;
\end{lstlisting}
\clearpage
\begin{lstlisting}[numbers=none]
bool is_stackqueue(stackqueue* Q)
{
  return Q != NULL && Q->instack != NULL && Q->outstack != NULL;
}

stackqueue* queue_new()
//@ensures is_stackqueue(\result);
{
  stackqueue* Q = alloc(stackqueue);
  Q->instack = stack_new();
  Q->outstack = stack_new();
  return Q;
}
\end{lstlisting}

\begin{parts}

\part[0\half]\TAGS{queue, stack}
Given a queue with $k$ elements in it, exactly how many different ways
can this queue be represented using two stacks, as a function of $k$?

\begin{framed}
\bigskip
\uanswer{8em}{$k+1$} way(s).
\end{framed}

\RUBRIC
Part (a)
TAGS: queue, stack

Gradescope rubric:
+0.5pt k+1

Commentary:
k+1, all or nothing

ENDRUBRIC


\medskip
\part[0\half]\TAGS{interface, queue, stack}
Write the function \lstinline'queue_empty' that returns
\lstinline'true' if the queue is empty, and \lstinline'false'
otherwise.  Your answer must be \emph{based on the description of the
  data structure above}.
\begin{framed}
\begin{lstlisting}[belowskip=0pt]
bool queue_empty(stackqueue* Q)
//@requires is_stackqueue(Q);
//@ensures is_stackqueue(Q);
{
\end{lstlisting}
\ifprintanswers
\begin{lstlisting}[basicstyle=\basicstyle\color{\answerColor}]
  return stack_empty(Q->instack) && stack_empty(Q->outstack);
\end{lstlisting}
\else~\vspace{2.5in}\fi
\begin{lstlisting}[aboveskip=0pt]
}
\end{lstlisting}
\end{framed}

\RUBRIC
TAGS: interface, queue, stack

Parts (b-d) overall:
  -0.5pt for extraneous or interface-violating checks like is_stack
  -0.5pt for forgetting Q-> and just writing "instack" or "outstack"
  (-0.5pt, no matter how many times they did it)

Part (b)

Gradescope rubric:
+0.5pt return stack_empty(Q->instack) && stack_empty(Q->outstack)

Commentary: (none)

ENDRUBRIC

\newpage
\part[0\half]\TAGS{interface, queue, stack}
Write the function \lstinline'enq' \emph{based on the description
  of the data structure above}.
\begin{framed}
\begin{lstlisting}[belowskip=0pt]
void enq(stackqueue* Q, elem x)
//@requires is_stackqueue(Q);
//@ensures is_stackqueue(Q);
{
\end{lstlisting}
\ifprintanswers
\begin{lstlisting}[basicstyle=\basicstyle\color{\answerColor}]
  push(Q->instack, x);
\end{lstlisting}
\else~\vspace{2.5in}\fi
\begin{lstlisting}[aboveskip=0pt, belowskip=0pt]
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (c)
TAGS: interface, queue, stack

Gradescope rubric:
+0.5pt push(Q->instack, x)

Commentary: (none)

ENDRUBRIC


\part[0\half]\TAGS{interface, queue, stack}
Write the function \lstinline'deq' \emph{based on the description
  of the data structure above}.
\begin{framed}
\begin{lstlisting}[belowskip=0pt]
elem deq(stackqueue* Q)
//@requires is_stackqueue(Q);
//@requires !queue_empty(Q);
//@ensures is_stackqueue(Q);
{
\end{lstlisting}
\ifprintanswers
\begin{lstlisting}[basicstyle=\basicstyle\color{\answerColor}]
  if (stack_empty(Q->outstack)) {
    while (!stack_empty(Q->instack)) {
      push(Q->outstack, pop(Q->instack));
    }
  }

  return pop(Q->outstack);
\end{lstlisting}
\else~\vspace{2.5in}\fi
\begin{lstlisting}[aboveskip=0pt, belowskip=0pt]
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (d)
TAGS: interface, queue, stack

Gradescope rubric:
+ 0.25pt Handles common case where Q->outstack is not empty
+ 0.25pt Handles special case where Q->outstack is empty

Commentary:
   +.25pt: common case (popping from the outstack correctly)
   +.25pt: handing expensive operation correctly

    if (stack_empty(Q->outstack)) {
       while (!stack_empty(Q->instack)) {
          push(Q->outstack, pop(Q->instack));
       }
    }

    return pop(Q->outstack);
ENDRUBRIC


\newpage
\part[1]\TAGS{complexity}
We now determine the runtime complexity of the \lstinline'enq' and
\lstinline'deq' operations.  Let $k$ be the total number of elements in
the queue.

What is the worst-case (non-amortized) runtime complexity of each of
the following queue operations based on the description of the data
structure implementation given above? Write \emph{one} sentence that
explains each answer.

\begin{framed}
\medskip
\lstinline'enq': \  $O(\uanswer{6em}{$1$})$, \ because
\uanswer{19.8em}{we always do exactly one push.\hfill}

\smallskip
\uanswer{34em}{}

\bigskip
\lstinline'deq': \  $O(\uanswer{6em}{$k$})$, \ because
\uanswer{19.8em}{we may need to pop all $k$ elements from\hfill}

\smallskip
\uanswer{34em}{the \lstinline'instack'.\hfill}
\end{framed}

\RUBRIC
Part (e)
TAGS: complexity

Gradescope rubric:
+ 0.5 pts enq is O(1) and some reasonable explanation
+ 0.5 pts deq is O(k) and some reasonable explanation

Commentary:
Give half-credit if the answer agrees with the
  description in the writeup but the code from the previous part doesn't match.
  +1/2pt: enq is O(1) and some reasonable explanation
  +1/2pt: deq is O(k) and some reasonable explanation
          Note that O(n) is NOT okay, function is in terms of k
ENDRUBRIC


\part[2]\TAGS{amortized-cost}
Using amortized analysis, we can show that the worst-case complexity
of a \emph{valid sequence} of $n$ enqueue/dequeue operations starting
from an empty queue is $O(n)$.  This means that the amortized cost per
operation is $O(1)$, even though the worst-case cost of an individual
operation may not be constant.

Here, a \emph{valid sequence} of queue operations must start with the
empty queue, each operation must be either an \lstinline'enq' or a
\lstinline'deq', and you must have enough tokens.  Assume that
\lstinline'push' and \lstinline'pop' each consume one token (and
emptiness tests are free).

How many tokens should be charged to enqueue an element? How many to
dequeue an element?  Your answers should be constant integers ---
recall that the amortized cost is to be $O(1)$.  Justify each answer
by briefly stating for what purpose of each token is used \emph{(you
  may not need all lines)}.

\begin{framed}
\newcommand{\tokenPurpose}[1]{\item[1] token to \uanswer{27.5em}{#1\hfill}}
Cost of \lstinline{enq}: \uanswer{8em}{4} token(s), to be used as follows:
\begin{itemize}
\tokenPurpose{push instack}
\tokenPurpose{pop instack}
\tokenPurpose{push outstack}
\tokenPurpose{pop outstack}
%\tokenPurpose{}
\end{itemize}

\bigskip
Cost of \lstinline{deq}: \uanswer{8em}{0} token(s), to be used as follows:
\begin{itemize}
\tokenPurpose{}
\tokenPurpose{}
\tokenPurpose{}
\tokenPurpose{}
%\tokenPurpose{}
\end{itemize}
\end{framed}

\RUBRIC
Part (f)
TAGS: amortized-cost

Gradescope rubric:
+ 1 pt First box number and explanation correct: EITHER 3: push-instack, pop-instack, push-outstack OR 4: push-instack, pop-instack, push-outstack, pop-outstack
+ 1 pt Second box number and explanation correct: depending on answer to first box, EITHER 1: pop-outstack OR 0

Commentary:
Doesn't have to match their implementation.
  +1pt - Correct token numbers (3/1 or 4/0). No partial credit.
  +1pt - Correct assignment of tokens to operations. No partial credit
  unless you see a compelling reason; consult with the staff if so.

  Expected answer:
    enqueue takes 3 (push-instack, pop-instack, push-outstack)
    dequeue takes 1 (pop-outstack)

  Alternate answer:
    enqueue takes 4 (push-instack, pop-instack, push-outstack, pop-outstack)
    dequeue takes 0
ENDRUBRIC

\end{parts}
