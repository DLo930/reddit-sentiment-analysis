\clearpage
\bgroup
% Customizations for first task
\newcommand{\IMG}{IMG}%{A}
\newcommand{\ROW}{row}
\newcommand{\COL}{col}
\newcommand{\PIXEL}{P}%{q}{x}{P}
\newcommand{\WIDTH}{width}%{w}{wid}
\newcommand{\HEIGHT}{height}%{h}{hei}

%% Select the last two exercises from the options at the end of this file


\Question{Implementing an Image Type Using a Struct}

In a previous programming assignment, we worked with one-dimensional
arrays that represented two-dimensional images.  Neither the width nor
the height of an image could be 0.  Suppose we want to create a data
type for an image along with an interface that specifies functions to
allow us to get a pixel of the image or set a pixel of the image.
This type should still be implementable as a one-dimensional array
(but allow other choices).

(You may assume that \lstinline'p1 == p2' is an acceptable way of
comparing pixels for equality.)

\begin{parts}
\part[1\half]\TAGS{interface}
Complete the \underline{interface} for the image data type.
Add appropriate preconditions and postconditions for each image
operation \emph{(you may not need all the lines we provided)}.  The
first two functions should have at least one meaningful postcondition,
but you don't have to give every conceivable postcondition.

\begin{framed}
\begin{lstlisting}
// typedef ______* image_t;


[*\uanswer{5.5em}{int}*] image_getwidth([*\uanswer{22em}{image\_t \IMG}*])

  [*\uanswer{36.3em}{//@requires \IMG{} != NULL;\hfill}*]

  [*\uanswer{36.3em}{//@ensures \result{} > 0;\hfill}*]

  [*\uanswer{36.3em}{}*]


[*\uanswer{5.5em}{int}*] image_getheight([*\uanswer{21.5em}{image\_t \IMG}*])

  [*\uanswer{36.3em}{//@requires \IMG{} != NULL;\hfill}*]

  [*\uanswer{36.3em}{//@ensures \result{} > 0;\hfill}*]

  [*\uanswer{36.3em}{}*]

\end{lstlisting}
\end{framed}

\newpage
\begin{framed}
\bigskip
\begin{lstlisting}
[*\uanswer{5.5em}{pixel\_t}*] image_getpixel(image_t [*\IMG*], int [*\ROW*], int [*\COL*])

  [*\uanswer{36.3em}{//@requires \IMG{} != NULL;\hfill}*]

  [*\uanswer{36.3em}{//@requires 0 <= \ROW{} \&\& \ROW{} < image\_getheight(\IMG);\hfill}*]

  [*\uanswer{36.3em}{//@requires 0 <= \COL{} \&\& \COL{} < image\_getwidth(\IMG);\hfill}*]

  [*\uanswer{36.3em}{}*]

  [*\uanswer{36.3em}{}*]


[*\uanswer{4.0em}{void}*] image_setpixel(image_t [*\IMG*], int [*\ROW*], int [*\COL*], pixel_t [*\PIXEL*])

  [*\uanswer{36.3em}{//@requires \IMG{} != NULL;\hfill}*]

  [*\uanswer{36.3em}{//@requires 0 <= \ROW{} \&\& \ROW{} < image\_getheight(\IMG);\hfill}*]

  [*\uanswer{36.3em}{//@requires 0 <= \COL{} \&\& \COL{} < image\_getwidth(\IMG);\hfill}*]

  [*\uanswer{36.3em}{//@ensures image\_getpixel(\IMG, \ROW, \COL) == \PIXEL;\hfill}*]

  [*\uanswer{36.3em}{}*]


[*\uanswer{5.5em}{image\_t}*] image_new([*\uanswer{5.5em}{int}*] [*\WIDTH*], [*\uanswer{5.5em}{int}*] [*\HEIGHT*])

  [*\uanswer{36.3em}{//@requires 0 < \WIDTH{} \&\& 0 < \HEIGHT{};\hfill}*]

  [*\uanswer{36.3em}{//@requires \WIDTH{} <= int\_max()/\HEIGHT;\hfill}*]

  [*\uanswer{36.3em}{//@ensures \result{} != NULL;\hfill}*]

  [*\uanswer{36.3em}{//@ensures image\_getwidth(\result) == \WIDTH{};\hfill}*]

  [*\uanswer{36.3em}{//@ensures image\_getheight(\result) == \HEIGHT;\hfill}*]
\end{lstlisting}
\end{framed}

\RUBRIC
Part (a)
TAGS: interface

Gradescope rubric:
+0.25pts Return types and parameters are correct (int, int, pixel_t, void, image_t)
+0.25pts NULL check is performed
+0.5pts All other necessary contracts on get/set functions are present
+0.5pts All other necessary contracts on image_new are present, and uses height with row and width with column consistently.
-0.5pts doesn't check for NULL as the first precondition
-0.5pts Interface Violation! (Dereferencing a pointer or using is_image.)

Commentary:
- the names of the variables [below IMG, ROW, COL, PIXEL, HEIGHT, WIDTH]
  vary from semester to semester: set the rubrics up appropriately
 * RETURN TYPES AND PARAMETERS: 1/4 point, all or nothing
    int image_getwidth(image_t IMG);
    int image_getheight(image_t IMG);
    void image_setpixel
    pixel_t image_getpixel
    image_t image_new(int WIDTH, int HEIGHT)

 * CONTRACTS: [imageutil.c0 functions ARE allowed if used correctly]
    image_getwidth/image_getheight
      //@requires IMG != NULL
      //@ensures \result > 0
    image_getpixel/image_setpixel
      //@requires IMG != NULL
      //@requires 0 <= ROW && ROW < image_getheight(IMG)
      //@requires 0 <= COL && COL < image_getwidth(IMG)
     OR
      //@requires IMG != NULL
      //@requires is_valid_pixel(image_getwidth(IMG), image_getheight(IMG),
                                 ROW, COL);
     ALSO, FOR SET:
      //@ensures image_getpixel(IMG, ROW, COL) == PIXEL        // OPTIONAL
    image_new
      //@requires 0 < WIDTH && 0 < HEIGHT && WIDTH <= int_max() / HEIGHT
        OR
      //@requires is_valid_imagesize(WIDTH, HEIGHT)
      //@ensures \result != NULL
      //@ensures image_getwidth(\result) == WIDTH          // OPTIONAL
      //@ensures image_getheight(\result) == HEIGHT        // OPTIONAL

  . +1/4 point for preconditions that check for NULL and attempt to
    check ***some*** sort of bounds for getpixel/setpixel/new
    (so row <= image_getwidth(IMG) on getpixel and 0 <= WIDTH for image_new
    still gets this point)
  . +1/2 point for not confusing ROW/COL and for getting the full
    image_new precondition (either with the check or with is_valid_imagesize)
  . +1/2 point for non-optional postconditions

  *** EXCEPTION:
  *** If they break the interface anywhere (using is_image or
  *** dereferencing the pointer), then their score is capped at 1 point
ENDRUBRIC


\newpage
\begin{EnvUplevel}
In the \underline{implementation} of the image data type, we
have the following type definitions:

\begin{lstlisting}
struct image_header {
    int width;
    int height;
    pixel_t[] data;
};
typedef struct image_header image;
typedef image* image_t;

\end{lstlisting}

\noindent
And the following data structure invariant:

\begin{lstlisting}[firstnumber=8]
bool is_image(image* [*\IMG*]) {
  return [*\IMG*] != NULL
      && [*\IMG*]->width > 0
      && [*\IMG*]->height > 0
      && [*\IMG*]->width <= int_max() / [*\IMG*]->height
      && is_arr_expected_length([*\IMG*]->data, [*\IMG*]->width * [*\IMG*]->height);
}
\end{lstlisting}

The client does not need to know about this function, since it is the job
of the implementation to preserve the validity of the image data structure.
But the implementation must use this specification function to assure
that the image is valid before and after any image operation.
\end{EnvUplevel}

\part[1\half]\TAGS{correctness, pointer, safety, struct}
\input{image_getpixel} % F19 F18 S18 S17 F16 S16
%\input{image_setpixel} % S19 F17


\newpage
\part[1\half]\TAGS{array, correctness, pointer, safety, struct}
%\input{image_new} % F18 S17 F16 S16
%\input{image_getwidth} % S19 F17
\input{image_getheight} % F19 S18

\end{parts}

\egroup