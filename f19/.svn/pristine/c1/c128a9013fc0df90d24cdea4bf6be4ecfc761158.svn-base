/* The file pixel.c0 describes the pixel type. It also defines the
 * pixel interface with five functions: get_red(p), get_green(p),
 * get_blue(p), get_alpha(p), and make_pixel(a,r,g,b).
 *
 * We're going to check that you represent pixels as integers where
 * the bits describe the alpha value, red intensity, green intensity,
 * and blue intensity (in that order). However, if you're *given* a
 * working pixel implementation, you can use the pixel interface
 * without knowing which part of the integer is used to store the blue
 * intensity. You don't even need to know that pixels are integers!
 *
 * When writing this file, only use the interface of pixels.c0. We'll
 * check your code by compiling and running it against different
 * implementations of the pixel interface.
 *
 * There are 4 tasks in this file:
 *  - 4 - Modifying pixels while respecting interfaces
 *  - 5 - Implement quantize() as described in the writeup
 *  - 6 - Testing quantize()
 *  - 7 - Returning multiple values */

/* Task 4 - Respecting interfaces:
   This implementation of the function for this task does not currently
   respect the interface to pixels: change it so that it does. */

pixel_t opacify(pixel_t p) {
  return make_pixel(0xFF, get_red(p), get_green(p), get_blue(p));
}

/* This is some code for testing the remove_red() function. It *does*
 * respect the pixel interface. You can use it to test your
 * implementation and, if you want, extend it with your own tests, but
 * we won't run this test code in the autograder. */

bool opacify_works(pixel_t p1) {
  pixel_t p2 = opacify(p1);
  if (get_alpha(p2) != 0xFF)          return false;
  if (get_red(p2)   != get_red(p1))   return false;
  if (get_green(p2) != get_green(p1)) return false;
  if (get_blue(p2)  != get_blue(p1))  return false;
  return true;
}

void test_opacify() {
  assert(opacify_works(make_pixel(0xFF, 0x01, 0x03, 0x04)));
  assert(opacify_works(make_pixel(0x02, 0x00, 0xFF, 0xEE)));
  assert(opacify_works(make_pixel(0xFF, 0xFF, 0xFF, 0xFF)));
  assert(opacify_works(make_pixel(0x00, 0x00, 0x00, 0x00)));
  assert(opacify_works(make_pixel(0x00, 0xAA, 0xBB, 0xCC)));
}

/* Task 5 - Implement quantize() as described in the writeup */

pixel_t quantize(pixel_t p, int q)
//@requires 0 <= q && q < 8;
{
  int i;
  int mask = (0xFF << q) & 0xFF;

  return make_pixel(get_alpha(p),
                    get_red(p) & mask,
                    get_green(p) & mask,
                    get_blue(p) & mask);
}

/* Task 6 - Testing quantize()
 *
 * Write some more tests for quantize. Remember to respect the pixels
 * interface! We *will* run these tests, and will grade them based on
 * their ability to catch buggy implementations of quantize. */

void test_quantize() {
  pixel_t p = quantize(make_pixel(0xFF, 0xFF, 0xFF, 0xFF), 4);
  assert(get_alpha(p) == 0xFF);
  assert(get_red(p)   == 0xF0);
  assert(get_green(p) == 0xF0);
  assert(get_blue(p)  == 0xF0);

  p = quantize(make_pixel(0xFA, 0xFB, 0xFC, 0xFD), 0);
  assert(get_alpha(p) == 0xFA);
  assert(get_red(p) == 0xFB);
  assert(get_green(p) == 0xFC);
  assert(get_blue(p) == 0xFD);

  p = quantize(make_pixel(0xF1, 0xF2, 0xF3, 0xF4), 7);
  assert(get_alpha(p) == 0xF1);
  assert(get_red(p) == 0x80);
  assert(get_green(p) == 0x80);
  assert(get_blue(p) == 0x80);
}

/* Task 7
 *
 * In C and C0, it's a bit difficult to return more than one value
 * from a function. For instance, say we needed to know, given an
 * array of pixels, how many pixels had red intensity 0, how many
 * pixels had blue intensity 0, and how many pixels had green
 * intensity 0.
 *
 * We could write three different functions to return these three
 * values, but what we'd like to do instead is write one loop that
 * calculates all three values. Then, those three values are returned
 * to the user by modifying the contents of an array that was passed
 * to the function.
 *
 * The function histogram is supposed to count the intensity average
 * of the pixels and store the results in results[0], ... results[255],
 * respectively. In otherwords, the pixel array A[] is an input and
 * should not change, but the integer array results[] is an output,
 * should not change, but and we have to change it.
 *
 * This function has a couple of bugs and therefore fails
 * the test cases below. Fix it, but do not change the interface. (You
 * shouldn't need to change the test cases, either.) */

void histogram(pixel_t[] A, int length, int[] results)
//@requires \length(A) == length;
//@requires \length(results) == 256;
{
  for (int i = 0; i < 256; i++)
  //@loop_invariant 0 <= i;
    results[i] = 0;

  for (int j = 0; j < length; j++)
  //@loop_invariant 0 <= j;
  {
    int average = (get_red(A[j]) + get_green(A[j]) + get_blue(A[j])) / 3;
    results[average] = results[average] + 1;
  }
}

/* This is some code for testing the count_zeroes() function. You can
 * use it to help you understand what count_zeroes is supposed to do,
 * and you can use it to test your implementation. If you want, you
 * can extend it with your own tests, but we won't run this test code
 * in the autograder. */

pixel_t[] copy_pixels(pixel_t[] A, int length)
//@requires length == \length(A);
//@ensures length == \length(\result);
//@ensures \result != A;
{
  pixel_t[] B = alloc_array(pixel_t, length);
  for (int i = 0; i < length; i++)
    //@loop_invariant 0 <= i;
    {
      B[i] = A[i];
    }
  return B;
}

bool pixels_equal(pixel_t[] A, pixel_t[] B, int length)
//@requires length == \length(A);
//@requires length == \length(B);
{
  for (int i = 0; i < length; i++)
    //@loop_invariant 0 <= i;
    {
      if (get_alpha(A[i]) != get_alpha(B[i])) return false;
      if (get_red(A[i])   != get_red(B[i]))   return false;
      if (get_blue(A[i])  != get_blue(B[i]))  return false;
      if (get_green(A[i]) != get_green(B[i])) return false;
    }
  return true;
}
