\part
Consider extending the dictionary library implementation with the
following function which deletes the entry with the given key
\lstinline'k', if any.

\medskip
\begin{lstlisting}
void dict_delete(dict* D, key k)
//@requires is_dict(D);
//@ensures is_dict(D);
{
  D->root = bst_delete(D->root, k);
}
\end{lstlisting}

\medskip
We will proceed in two steps.
\begin{subparts}
\subpart[1\half]\TAGS{bst}
Complete the code for the recursive helper function
\lstinline'largest_child' below which removes and returns the largest
\emph{child} rooted at a given tree node \lstinline'T'. \emph{(HINT:
Finding the largest child of T actually doesn't require us to look at
the keys. The largest child must be in one specific location.)}

\medskip
\begin{framed}
\begin{lstlisting}
entry largest_child(tree* T)
//@requires is_bst(T) && T != NULL && T->right != NULL;
{
  if (T->right->right == NULL) {

    entry e = [*\uanswer{26.5em}{T->right->data}*];

    T->right = [*\uanswer{26em}{T->right->left}*];
    return e;
  }

  return largest_child([*\uanswer{20.5em}{T->right}*]);
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (d i)
TAGS: bst

Gradescope rubric:
+0.5pt 1st blank: T->right->data
+0.5pt 2nd blank: T->right->left
+0.5pt 3rd blank: T->right

Commentary:
  1/2 off for each incorrect line, up to 1 point off max
  entry e = ____T->right->data____
  T->right = ____T->right->left____
  return largest_child(____T->right____)
ENDRUBRIC


\bigskip\bigskip
\subpart[2]\TAGS{bst}
Complete the code for the recursive helper function
\lstinline'bst_delete' on the next page which is used by the
function \lstinline'dict_delete' above. This function should return a pointer
to the tree rooted at \lstinline'T' once the entry is deleted (if it
is in the tree).  Note that this function uses the
\lstinline'largest_child' function you just completed.

\newpage
\enlargethispage{3ex}
\begin{framed}
\begin{lstlisting}[aboveskip=0pt, belowskip=0pt]
tree* bst_delete(tree* T, key k)
//@requires is_bst(T);
//@ensures is_bst(\result);
{
  if (T == NULL)  return NULL;  // key is not in the tree

  int cmp = key_compare(k, entry_key(T->data));
  if (cmp > 0) {

    [*\uanswer{16em}{T->right}*] = bst_delete(T->right, k);
    return T;
  }
  else if (cmp < 0) {

    [*\uanswer{16em}{T->left}*] = bst_delete(T->left, k);
    return T;
  }
  else {  // key is in current tree node T
    if (T->right == NULL)

      return [*\uanswer{27em}{T->left}*];
    else if (T->left == NULL)

      return [*\uanswer{27em}{T->right}*];
    else {  // T has two children
      if (T->left->right == NULL) {
             // Replace T's data with the left child's data

          [*\uanswer{28.7em}{T->data = T->left->data}*];
             // Replace the left child with its left child

          [*\uanswer{28.7em}{T->left = T->left->left}*];
         return T;
      }
      else { // Search for the largest child in the left
             // subtree of T and replace the data in node
             // T with this data after removing the largest
             // child in the left subtree
        T->data = largest_child(T->left);
        return T;
      }
    }
  }
}
\end{lstlisting}
\end{framed}

\end{subparts}

\RUBRIC
Part (d ii)
TAGS: bst

Gradescope rubric:
+0.25pt 1st blank: T->right
+0.25pt 2nd blank: T->left
+0.5pt  3rd blank: T->left
+0.25pt 4th blank: T->right
+0.5pt  5th blank: T->data = T->left->data
+0.25pt 6th blank: T->left = T->left->left

Commentary:
  T->right                  1/2 pt for first two answers, no partial credit
  T->left

  T->left                   3/2 pt for next two answers, no partial credit
  T->right

  T->data = T->left->data;  1/2 pt, no partial credit

  T->left = T->left->left;  1/4 pt, no partial credit
ENDRUBRIC
