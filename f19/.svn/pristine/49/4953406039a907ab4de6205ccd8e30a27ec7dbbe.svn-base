// Code to check exercise "Dealing with Collisions", task about problem with quadratic probing.
// Synopsis:
//      a.out k1 k2 k3 k4 K
// where k1-k4 are the elements in the table and K is the element that cannot be inserted

#use <conio>
#use <args>
#use <parse>

int hash(int k, int i, int n)
//@requires 0 <= i && i < n;
//@ensures 0 <= \result && \result < n;
{
  int v = (k + i*i) % n;
  return v<0 ? v+n : v;
}

bool ins(int[] A, int k, int n) {
  for (int i=0; i<n; i++)
    if (A[hash(k,i,n)] == -100) {
      A[hash(k,i,n)] = k;
      return true;
    }
  return false;
}

int main () {
  int n = 6;

  int[] A = alloc_array(int, n);
  for (int i=0; i<n; i++)
    A[i] = -100;

  args_t G = args_parse();
  int k = 0;
  if (ins(A, *parse_int(G->argv[0], 10), n)) k++;
  if (ins(A, *parse_int(G->argv[1], 10), n)) k++;
  if (ins(A, *parse_int(G->argv[2], 10), n)) k++;
  if (ins(A, *parse_int(G->argv[3], 10), n)) k++;

  for (int i=0; i<n; i++) {
    if (A[i] == -100) print(" _");
    else {
      print(" "); printint(A[i]);
    }
  }
  println("");
  if (!ins(A, *parse_int(G->argv[4], 10), n))
    println("Correct");
  else {
    println("Wrong!!");
    k++;
  }

  return k;
}
