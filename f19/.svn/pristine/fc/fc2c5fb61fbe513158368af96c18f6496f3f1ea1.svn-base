/*
 * Queues of string
 *
 * 15-122 Principles of Imperative Computation */


/**************************** Implementation ****************************/

/* Aux structure of linked lists of strings */
struct slist_node_sekret {
  string data;
  struct slist_node_sekret* next;
};

/* is_segment(start, end) will diverge if list is circular! */
bool is_segment_slist_sekret(struct slist_node_sekret* start,
                             struct slist_node_sekret* end) {
  if (start == NULL) return false;
  if (start == end) return true;
  return is_segment_slist_sekret(start->next, end);
}

/* Queues */

typedef struct queue_header_sekret[] queue;
struct queue_header_sekret {
  bool is_read_only;
  struct slist_node_sekret* front;
  struct slist_node_sekret* back;
};

bool is_queue_sekret(queue* Q) {
  if (Q == NULL) return false;
  //@assert \length(*Q) == 1;
  return is_segment_slist_sekret((*Q)[0].front, (*Q)[0].back);
}

bool queue_empty(queue* Q)
//@requires is_queue_sekret(Q);
{
  return (*Q)[0].front == (*Q)[0].back;
}

bool queue_is_read_only(queue* Q)
//@requires is_queue_sekret(Q);
{
  return (*Q)[0].is_read_only;
}

queue* queue_new()
//@ensures is_queue_sekret(\result);
//@ensures queue_empty(\result);
{
  queue* Q = alloc(queue);
  *Q = alloc_array(struct queue_header_sekret, 1);
  struct slist_node_sekret* l = alloc(struct slist_node_sekret);
  (*Q)[0].is_read_only = false;
  (*Q)[0].front = l;
  (*Q)[0].back = l;
  return Q;
}

void enq(queue* Q, string s)
//@requires is_queue_sekret(Q);
//@ensures is_queue_sekret(Q);
{
  struct slist_node_sekret* l = alloc(struct slist_node_sekret);
  (*Q)[0].back->data = s;
  (*Q)[0].back->next = l;
  (*Q)[0].back = l;
  return;
}

string deq(queue* Q)
//@requires is_queue_sekret(Q);
//@requires !queue_empty(Q);
//@ensures is_queue_sekret(Q);
{
  string s = (*Q)[0].front->data;
  (*Q)[0].front = (*Q)[0].front->next;
  return s;
}

queue* queue_read_only_copy(queue* Q)
//@requires is_queue_sekret(Q);
//@ensures is_queue_sekret(Q);
//@ensures is_queue_sekret(\result);
//@ensures queue_is_read_only(\result);
{
  queue* QC = alloc(queue);
  *QC = alloc_array(struct queue_header_sekret, 1);
  (*QC)[0].is_read_only = true;
  (*QC)[0].front = (*Q)[0].front;
  (*QC)[0].back = (*Q)[0].back;
  return QC;
}

// Client type
typedef queue* queue_t;


/**************************** Interface ****************************/

// typedef ______* queue_t;

bool queue_empty(queue_t Q)        /* O(1) */
  /*@requires Q != NULL; @*/;

bool queue_is_read_only(queue_t Q) /* O(1) */
  /*@requires Q != NULL; @*/;

queue_t queue_new()                /* O(1) */
  /*@ensures \result != NULL; @*/
  /*@ensures queue_empty(\result); @*/;

void enq(queue_t Q, string e)      /* O(1) */
  /*@requires Q != NULL; @*/;

string deq(queue_t Q)              /* O(1) */
  /*@requires Q != NULL; @*/
  /*@requires !queue_empty(Q); @*/ ;

/* O(1) operation to create a copy of the queue that can only be
 * dequeued from, not enqueued onto. */
queue_t queue_read_only_copy(queue_t Q)
  /*@ensures \result != NULL; @*/
  /*@ensures queue_is_read_only(\result); @*/ ;
