/*
 * Ropes
 *
 * 15-122 Principles of Imperative Computation
 */

#use <conio>
#use <string>
#use <util>

/************************************/
/* Interface (leave this in place!) */
/************************************/

//typedef _______ rope_t;
typedef struct rope_node* rope_t; //pointer to struct rope_node

int rope_length(rope_t R);
rope_t rope_new(string s);
rope_t rope_join(rope_t R, rope_t S)
  /*@requires rope_length(R) <= int_max() - rope_length(S); @*/ ;
char   rope_charat(rope_t R, int i)
  /*@requires 0 <= i && i < rope_length(R); @*/ ;
rope_t rope_sub(rope_t R, int lo, int hi)
  /*@requires 0 <= lo && lo <= hi && hi <= rope_length(R); @*/ ;
void   rope_reduce(rope_t[] A, int n)
  /*@requires n == \length(A); @*/ ;

/***********************************/
/* Implementation (edit this part) */
/***********************************/

typedef struct rope_node rope;
struct rope_node {
  int len;
  rope* left;
  rope* right;
  string data;
};

int rope_length(rope_t R){
  if (R == NULL){
    return 0;
  }
  else return R->len;
}

int rope_size(rope* R){ //recursively find size of a rope
  //to give us the R->len or confirm it
  int count = 0;
  if (R->right == NULL && R->left == NULL){
    return string_length(R->data);
  }
  else if (R->left != NULL && R->right != NULL){
    int x = rope_size(R->left);
    int y = rope_size(R->right);
    count = x + y;
  }
  return count;
}

bool is_rope(rope* R)
{ 
  if (R == NULL)
  {
    return true;
  }
  else if (R->left == NULL && R->right == NULL)
  { //valid leaf rope
    if (rope_length(R) <= 0)
    { //has a non-empty string data field
      return false;
    }
    if (string_length(R->data) <= 0)
    {//again "has a non-empty string data field"
      return false;
    }
    else if (R->len != string_length(R->data))
    {//as a strictly positive len equal to the length of the
      //string in the data field
      return false;
    }
  }
  else if (R->left != NULL && R->right !=NULL)
  { //rope is a non-leaf if it has non-NULL left and right fields
    if (R->left->len < 1 || R->right->len < 1) return false;
    else if (R->len != R->left->len + R->right->len) return false; 
    else if (!is_rope(R->left) || !is_rope(R->right))
    {
      return false;
    }
    else if (rope_size(R) != R->len) return false; //and if it has a len field equal to the sum of the len 
    //fields of its children
    else return true;
  }
  else return false;
  return false;
}

rope_t rope_new(string s)
///@ensures is_rope(\result);
{
  rope_t R = alloc(struct rope_node);
  if (string_length(s) == 0){
    R = NULL; //we have a 0 size rope so it's null
    return R;
  }
  else {
    R->data = s; //set the parameters for non empty rope
    R->len = string_length(s);
    //R->left = NULL;
    //R->right = NULL;
    return R;
  }
}
rope_t rope_join(rope_t R, rope_t S)
//@requires is_rope(R);
//@requires is_rope(S);
//@requires rope_length(R) <= int_max() - rope_length(S);
{
  rope_t L = alloc(struct rope_node);//test
  if (R == NULL && S == NULL){//test
    L == NULL;//test
    return L;
  }
  L->left = R;
  L->right = S;
  L->len = rope_length(R) + rope_length(S);
  return L;
}

string rope_tostring(rope_t R)
{
  string z = ""; //start with empty string
  if (R == NULL){
    return ""; //it's null so empty string
  }
  else if (R->right == NULL && R->left == NULL){
    return R->data; //just return the stirng in rope
  }
  else if (R->left != NULL && R->right != NULL){
    string x = rope_tostring(R->left); //have to recurse...
    string y = rope_tostring(R->right);//to find the parts...
    z = string_join(x,y);//and put them together!
    return z; //now return!
  }
  else return "";
}

char rope_charat(rope_t R, int i)
//@requires 0 <= i && i < rope_length(R);
//@requires is_rope(R);
{
  int count = 0;
  char c = ' '; //empty char (to be changed)
  if (R->left == NULL && R->right == NULL) {
    println("will it ever hit this?");
    char [] C = string_to_chararray(R->data);
    return C[i]; // the character is at this node!
  }
  else {
    if (i >= rope_length(R->left)){
      println("it hit this");
      //not on the left side adjust count and try the right
      count = count + R->left->len;
      printint(count);
      c = rope_charat(R->right, i-count); //notice this adjustes i since
      //we reset count to 0 but we just skipped len amount of chars
    }
    else {
      //no need to do any of that just search on the left;
      println("this what I is");
      printint(i);
      c = rope_charat(R->left, i); //search the left side;
    }
  }
  return c;
}

rope_t rope_sub_recurse(rope_t R,rope_t S, int lo, int hi)
///@requires 0 <= lo && lo <= hi && hi <= rope_length(R)
{
  //println("was the segfault caused here?");
  //println("the segfault was caused there ^ :/");
  if (lo == 0 && hi == R->len){
     return R;
  }
  else {
    if (R->left == NULL && R->right == NULL){
      println("this is R->len");
      printint(R->len);
      println("this is lo");
      printint(lo);
      println("this is hi");
      printint(hi);
      println("a");
      S->data = string_sub(R->data,lo,hi);
      println("this is S");
      println(S->data);
      S->len = string_length(S->data);
      //println("what about here?");
      //return S;
    }
    else if (R->left->len <= lo){
      println("this R->left len now (the second condition in recurse)");
      printint(R->left->len);
      println("this is hi right now");
      printint(hi);
      println("this is R->right len");
      printint(R->right->len);
      rope_sub_recurse(R->right, S, lo - R->left->len, hi - R->left->len);
    }
    else if (R->left->len >= hi){
      rope_sub_recurse(R->left,S, lo, hi);
    }
    else {
      //println("could it be from here?");
      //S->left = alloc(struct rope_node);//so left & right won't be null
      //S->right = alloc(struct rope_node);
      println("R->left->len");
      printint(R->left->len);
      S->left = rope_sub(R->left,lo,R->left->len);
      S->right = rope_sub(R->right,0,hi-R->left->len);
      S->len = rope_length(S->left) + rope_length(S->right);
      //return S;
    }
  }
  return S;
}

rope_t rope_sub(rope_t R, int lo, int hi)
//@requires 0 <= lo && lo <= hi && hi <= rope_length(R);
///@ensures is_rope(\result); 
{
  if (R==NULL) return R;
  else if (lo == hi){
    rope_t S = alloc(struct rope_node);
    S->data = "";
    return S;
  }
  else if (R->left == NULL && R->right == NULL){
    if (lo == 0 && hi == R->len){
      println("it hit this (1)/if");
      return R;
    }
    else {
      rope_t S = alloc(struct rope_node); //gotta make a new 
      return rope_sub_recurse(R,S,lo,hi); //rope with only part of it
      //recurse can do that.
    }
  }
  else {
    println("it hit this (else)");
    if (R->left->len <= lo){
      println("I hit the < in rope sub!!!");
      return rope_sub(R->right, lo - R->left->len, hi - R->left->len);
    }
    else if (R->left->len >= hi){
      return rope_sub(R->left,lo, hi);
    }
    else { //the only OTHER case we REALLY need to alloc is if the
    //
      rope_t S = alloc(struct rope_node);
      return rope_sub_recurse(R,S,lo,hi);
    }
  }
}

int rope_hash(void* x){
  rope_t S = (rope_t)x;
  int y = rope_length(S); //the hset is of the size of the array so...
  return (abs(y * 1664525) + 1013904223) % 1000000;
}

bool rope_equal(void* A,void* B)
///@requires(is_rope(S));
///@requires(is_rope(R));
{
  rope_t S = (rope_t)A;
  rope_t R = (rope_t)B;
  if (R == NULL && S == NULL){
    return true;
  }
  else if (rope_length(S) != rope_length(R)){
    return false; //have to recurse through
  }// they don't equal
  else { // they MAY equal
    for (int i = 0; i < rope_length(S); i++){
      if (rope_charat(R,i) != rope_charat(S,i)) return false;
    }
    return true;
  }
}

void rope_reduce(rope_t[] A, int n) //rewritten
//@requires n == \length(A);
{
  hset_t H = hset_new(1000000, &rope_equal, &rope_hash); //check this
  //DO NOT need to allocate memory so helper can be merged with original
  //Your memory-reduction procedure will use a hash set
  for (int i = 0; i < n; i++)
  {
    //rope_t = A[i]; //just makes it a bit easier to write
    void* Al = (void*)A[i];
    if (hset_lookup(H,Al) != NULL)
    { //(ignore for now) it is something in the hash table
      A[i] = (rope_t)hset_lookup(H,Al);//*so set it to that* <-ignore 
      //When given a rope, you should look
      //up that rope in the hash set to see if an equivalent rope .one representing the same string
      //already exists in the hash table.
      //If so, your memory-reduction procedure can just return
     //that already-stored rope in place of the rope you were given
    }
    else
    { 
      if (A[i]->left != NULL && A[i]->right != NULL) {
        //If your memory-reduction procedure doesn’t find the rope already in the hash set, it
        //should recursively call itself, first on the left sub-rope, and then on the right sub-rope
        void* All = (void*)A[i]->left;
        void* Alr = (void*)A[i]->right;
        hset_lookup(H,All);
        hset_lookup(H,Alr);
        //Then, without allocating any additional memory, you can replace the
        // original left and right subropes
        //with the results of calling the memory-reduction procedure on them. It’s always okay
        //to replace a rope with another rope that represents the same string. 
      }
    }
    // *ignore this for now*otherwise that's it and just add it :/
    //ht_insert(R); // *ignore for now* insert it into the hash table as stated:
    void* Ap = (void*)A[i];
    hset_insert(H,Ap); //after reduced add it to hash table
    //Now you have a rope with two sharing-maximized sub-ropes; this new rope should be added to the hash 
    //set for future use.
  }
}
