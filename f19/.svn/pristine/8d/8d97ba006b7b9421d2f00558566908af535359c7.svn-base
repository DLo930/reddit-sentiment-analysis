/*
 * Text buffers as doubly linked lists.
 * 
 * 15-122 Principles of Imperative Computation */

/*** Interface ***/

typedef struct dll_node dll;
struct dll_node {
  char data; 
  dll* next;
  dll* prev;
};

typedef struct tbuf_header tbuf;
struct tbuf_header {
  dll* start; /* the fist node of the list (on the left)  */
  dll* cursor; /* the position where the cursor is displayed */
  dll* end;   /* the last node of the list (on the right) */
};

bool is_tbuf(tbuf* B);

bool tbuf_at_left(tbuf* B);  /* Returns true if the cursor */
                             /* is in leftmost position  */
bool tbuf_at_right(tbuf* B); /* Returns true if the cursor */
                             /* is in rightmost position  */

tbuf* tbuf_new();                    /* Creates a new, empty text buffer */
void tbuf_forward(tbuf* B);          /* Moves the cursor forward (right) */
void tbuf_backward(tbuf* B);         /* Moves the cursor backward (left) */
void tbuf_insert(tbuf* B, char c);   /* Insert a character before cursor */
char tbuf_delete(tbuf* B);           /* Remove character before cursor   */

/*** Implementation ***/

bool is_dll_segment(dll* start, dll* end) {
  if (start == NULL) return false;
  if (start == end) return true;
  return start->next != NULL
    && start->next->prev == start
    && is_dll_segment(start->next, end);
}

bool dll_segment_contains(dll* start, dll* cursor, dll* end)
//@requires is_dll_segment(start, end);
{
  if (start == end) return cursor == start;
  return cursor == start 
    || dll_segment_contains(start->next, cursor, end);
}

bool is_tbuf(tbuf* B) {
  return B != NULL
    && B->start != B->end
    && is_dll_segment(B->start, B->end)
    && dll_segment_contains(B->start->next, B->cursor, B->end);
}

bool tbuf_at_left(tbuf* B) 
//@requires is_tbuf(B);
{
  return B->start->next == B->cursor;
}

bool tbuf_at_right(tbuf* B) 
//@requires is_tbuf(B);
{
  return B->end == B->cursor;
}

tbuf* tbuf_new() 
//@ensures is_tbuf(\result);
{
  tbuf* B = alloc(tbuf);
  B->start = alloc(dll);
  B->end = alloc(dll);
  B->end->data;
  B->start->next = B->end;
  B->end->prev = B->start;
  B->cursor = B->end;
  return B;
}

void tbuf_forward(tbuf* B)
//@requires is_tbuf(B);
//@requires !tbuf_at_right(B);
//@ensures is_tbuf(B);
{
  B->cursor = B->cursor->next;
}

void tbuf_backward(tbuf* B)
//@requires is_tbuf(B);
//@requires !tbuf_at_left(B);
//@ensures is_tbuf(B);
{
  B->cursor = B->cursor->prev;
}

char tbuf_delete(tbuf* B)
//@requires is_tbuf(B);
//@requires !tbuf_at_left(B);
//@ensures is_tbuf(B);
{
  char c = B->cursor->prev->data;
  B->cursor->prev = B->cursor->prev->prev;
  B->cursor->prev->next = B->cursor;
  return c;
}

void tbuf_insert(tbuf* B, char c)
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  dll* new = alloc(dll);
  new->prev = B->cursor->prev;
  new->data = c;
  new->next = B->cursor;
  new->prev->next = new;
  B->cursor->prev = new;
}


// Given a text buffer, reports the row (contracts-only)
int tbuf_row(tbuf* B) 
//@requires is_tbuf(B);
{
  dll* p = B->start;
  int i = 1;

  while (p != B->cursor) {
    if (p->data == '\n') i++;
    p = p->next;
  }

  return i;
}

// Given a text buffer, reports the column (may be called by code)
int tbuf_col(tbuf* B) 
//@requires is_tbuf(B);
{
  dll* p = B->cursor;
  int i = 0;

  while (p->prev != B->start && p->prev->data != '\n') {
    p = p->prev;
    i++;
  }

  return i;
}
