/* 
 * Interface for bloom filters (sets)
 * Stores last m elements in a circular queue
 * 
 * 15-122 Principles of Imperative Computation */

#use <string>

/*** Interface to bloom filters ***/

// typedef ______* bloom_t;
typedef struct bloom_header* bloom_t;

bloom_t bloom_new(int table_size)
  /*@requires table_size > 0; @*/
  /*@ensures \result != NULL; @*/ ;

bool bloom_contains(bloom_t B, string x)
  /*@requires B != NULL; @*/ ;

void bloom_add(bloom_t B, string x)
  /*@requires B != NULL; @*/
  /*@ensures bloom_contains(B, x); @*/ ;

/*** Implementation of bloom filters ***/

typedef struct bloom_header bloom;
struct bloom_header {
  string[] table; 
  int start;
  int end;
  int capacity;
};

bool is_bloom(bloom* B) {
  if (B == NULL) return false;
  //@assert \length(B->table) == B->capacity;
  return 0 <= B->start && B->start < B->capacity
    && 0 <= B->end && B->end < B->capacity;
}

bloom* bloom_new(int table_size)
//@requires table_size > 0;
//@ensures is_bloom(\result);
{
  bloom* B = alloc(bloom);
  B->table = alloc_array(string, table_size);
  B->capacity = table_size;
  B->start = 0;
  B->end = 0;
  return B;
}

bool bloom_contains(bloom* B, string x)
//@requires is_bloom(B);
{
  for (int i = B->start; i != B->end; i = (i+1) % B->capacity) 
  //@loop_invariant 0 <= i && i < B->capacity;
  {
    if (string_equal(B->table[i], x)) return true;
  }

  return (B->end + 1) % B->capacity == B->start
    && string_equal(B->table[B->end], x);
}

void bloom_add(bloom* B, string x) 
//@requires is_bloom(B);
//@ensures is_bloom(B);
//@ensures bloom_contains(B, x);
{
  if ((B->end + 1) % B->capacity == B->start) 
    B->start = (B->start + 1) % B->capacity;
  B->table[B->end] = x;
  B->end = (B->end + 1) % B->capacity;
}
