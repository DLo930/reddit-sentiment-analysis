/*
 * Bloom filters
 * Task 2 solution
 *
 * 15-122 Principles of Imperative Computation */

#use <string>
#use <util>


/************************ Implementation ***********************/

typedef struct bloom_filter bloom;
struct bloom_filter {
  int[] data;
  int limit;
};

bool is_bloom(bloom* B) {
  if (B == NULL) return false;
  //@assert \length(B->data) == B->limit;
  return B->limit > 0;
}

bloom* bloom_new(int capacity)
//@requires capacity > 0;
//@ensures is_bloom(\result);
{
  bloom* B = alloc(bloom);
  B->limit = (capacity + 31)/32;
  B->data = alloc_array(int, B->limit);
  return B;
}

int hash1(string x) { // FNV-like hash (http://isthe.com/chongo/tech/comp/fnv/)
  int h = 0;
  for (int i = 0; i < string_length(x); i++) {
    h ^= char_ord(string_charat(x, i));
    h *= 16777619;
  }
  return h;
}

int hash2(string x) { // Numerical Recipies LCG
  int h = 0xDEADBEEF;
  for (int i = 0; i < string_length(x); i++) {
    int c = char_ord(string_charat(x, i));
    h = h + c;
    h = h*1664525 + 1013904223;
  }
  return h;
}

int hash3(string x) { // Murmurhash (https://sites.google.com/site/murmurhash/)

  // 'm' is a mixing constant generated offline.
  // Not really 'magic', just happens to work well.
  int m = 0x5bd1e995;

  // Initialize the hash to a 'random' value
  int h = 0xC0C0FFEE ^ string_length(x);

  // Mix 4 bytes at a time into the hash
  int i = 0;
  while (i + 4 <= string_length(x)) {
    int k = char_ord(string_charat(x, i)) << 24;
    k |= char_ord(string_charat(x, i+1)) << 16;
    k |= char_ord(string_charat(x, i+2)) << 8;
    k |= char_ord(string_charat(x, i+3));

    k *= m;
    k ^= (k >> 24) & 0x00FFFFFF;
    k *= m;

    h *= m;
    h ^= k;

    i += 4;
  }

  // Handle the last few bytes of the input array
  if (i < string_length(x)) h ^= char_ord(string_charat(x, i));
  if (i+1 < string_length(x)) h ^= char_ord(string_charat(x, i+1)) << 8;
  if (i+2 < string_length(x)) h ^= char_ord(string_charat(x, i+2)) << 16;
  if (i < string_length(x)) h *= m;

  // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.

  h ^= (h >> 13) & 0x7FFFF;
  h *= m;
  h ^= (h >> 15) & 0x1FFFF;

  return h;
}

bool get_bit(int[] A, int i)
//@requires 0 <= i && i/32 < \length(A);
{
  int j = i >> 5;
  int k = i & 31;
  return 1 == ((A[j] >> k) & 1);
}

void set_bit(int[] A, int i)
//@requires 0 <= i && i/32 < \length(A);
{
  int j = i >> 5;
  int k = i & 31;
  A[j] |= 1 << k;
}

int get_index(bloom* B, int hash_value)
//@requires is_bloom(B);
{
  return abs(hash_value % (B->limit << 5));
}

bool bloom_contains(bloom* B, string x)
//@requires is_bloom(B);
{
  return get_bit(B->data, get_index(B, hash1(x)))
    && get_bit(B->data, get_index(B, hash2(x)))
    && get_bit(B->data, get_index(B, hash3(x)));
}

void bloom_add(bloom* B, string x)
//@requires is_bloom(B);
//@ensures is_bloom(B);
//@ensures bloom_contains(B, x);
{
  set_bit(B->data, get_index(B, hash1(x)));
  set_bit(B->data, get_index(B, hash2(x)));
  set_bit(B->data, get_index(B, hash3(x)));
}

// Client type
typedef bloom* bloom_t;


/*********************** Interface to bloom filters ***********************/

// typedef ______* bloom_t;

bloom_t bloom_new(int table_size)
  /*@requires table_size > 0; @*/
  /*@ensures \result != NULL; @*/ ;

bool bloom_contains(bloom_t B, string x)
  /*@requires B != NULL; @*/ ;

void bloom_add(bloom_t B, string x)
  /*@requires B != NULL; @*/
  /*@ensures bloom_contains(B, x); @*/ ;
