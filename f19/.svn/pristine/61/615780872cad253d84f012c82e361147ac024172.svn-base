/*
 * Text buffers
 * 
 * The back end for a one-character text editor, a doubly-linked list
 * whose elements are 16-character gap buffers.
 * 
 * 15-122 Principles of Imperative Computation */

/*** Interface ***/

typedef dll_pt tbuf;

tbuf* tbuf_new();                /* Creates an empty text buffer        */
                                 /* with gap buffers of size 16         */
void tbuf_split_pt(tbuf* B);     /* Splits a full point into two nodes  */
                                 /* so that the new point is not full   */
void tbuf_forward(tbuf* B);      /* Move the cursor forward/right by 1  */
void tbuf_backward(tbuf* B);     /* Move the cursor backward/left by 1  */
void tbuf_insert(tbuf* B, char c); /* Insert the char before the cursor */
void tbuf_delete(tbuf* B);       /* Delete the char before the cursor   */
                                 /* also delete point if it's empty     */

bool is_tbuf(tbuf* B);

/*** Implementation ***/

bool is_minimal_tbuf(tbuf* B) {
  if (!is_dll_pt(B)) return false;

  for (dll* l = B->start->next; l != B->end; l = l->next)
    //@loop_invariant l != NULL && is_dll_segment(l->prev, B->end);
    {
      if (!is_gapbuf(l->data)) return false;
      if (16 != l->data->limit) return false;
    }

  return true;
}

bool is_aligned(dll_pt* B) 
//@requires is_minimal_tbuf(B);
{
  for (dll* l = B->start->next; l != B->point; l = l->next)
    //@loop_invariant l != NULL && is_dll_segment(l->prev, B->point);
    if (!gapbuf_at_right(l->data)) return false;

  for (dll* l = B->point->next; l != B->end; l = l->next)
    //@loop_invariant l != NULL && is_dll_segment(l->prev, B->end);
    if (!gapbuf_at_left(l->data)) return false;

  return true;
}

bool is_empty_or_full(dll_pt* B) 
//@requires is_minimal_tbuf(B);
{
  if (B->start->next == B->point && B->point == B->end->prev) return true;

  for (dll* l = B->start->next; l != B->end; l = l->next)
    //@loop_invariant l != NULL && is_dll_segment(l->prev, B->end);
    if (gapbuf_empty(l->data)) return false;

  return true;
}

bool is_tbuf(dll_pt* B) {
  if (!is_minimal_tbuf(B)) return false;
  if (!is_aligned(B)) return false;
  if (!is_empty_or_full(B)) return false;
  return true;
}

bool tbuf_empty(tbuf* B) 
//@requires is_tbuf(B);
{
  return gapbuf_empty(B->point->data);
}

tbuf* tbuf_new() 
//@ensures is_tbuf(\result);
{
  tbuf* B = alloc(struct dll_pt_header);
  B->start = alloc(dll);
  B->point = alloc(dll);
  B->end = alloc(dll);

  B->start->next = B->point;
  B->point->prev = B->start;
  B->point->data = gapbuf_new(16);
  B->point->next = B->end;
  B->end->prev = B->point;

  return B;
}

void tbuf_split_pt(tbuf* B) 
//@requires is_tbuf(B);
//@requires gapbuf_full(B->point->data);
//@ensures is_tbuf(B);
//@ensures !gapbuf_full(B->point->data);
{
  dll* very_left = B->point->prev;
  dll* left = alloc(struct dll_node);
  dll* right = B->point;

  very_left->next = left;
  left->prev = very_left;
  left->data = gapbuf_new(16);
  left->next = right;
  right->prev = left;
  //@assert is_dll_pt(B);

  // First, split the buffers at the point
  int elems_in_left = right->data->gap_start;
  for(int i = 0; i < elems_in_left; i++) {
    left->data->buffer[i] = right->data->buffer[i];
  }
  left->data->gap_start = elems_in_left;
  right->data->gap_start = 0;
  right->data->gap_end = elems_in_left;
  //@assert is_gapbuf(left->data);
  //@assert is_gapbuf(right->data);

  // Then, balance them out
  if (elems_in_left <= 8) {
    // Point moves to the left
    B->point = left;
    for(int i = elems_in_left; i < 8; i++) 
      {
        left->data->buffer[i+8] = right->data->buffer[i];
      }
    left->data->gap_end = 8 + elems_in_left;
    right->data->gap_start = 0;
    right->data->gap_end = 8;
  } else {
    // Point remains on the right
    for(int i = elems_in_left-1; i >= 8; i--) {
      right->data->buffer[i-8] = left->data->buffer[i];
    }
    left->data->gap_start = 8;
    left->data->gap_end = 16;
    right->data->gap_start = elems_in_left - 8;
  }
}

void tbuf_forward(tbuf* B) 
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  if (gapbuf_at_right(B->point->data) && dll_pt_at_right(B)) return;
  if (gapbuf_at_right(B->point->data)) dll_pt_forward(B);
  gapbuf_forward(B->point->data);
}

void tbuf_backward(tbuf* B) 
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  if (gapbuf_at_left(B->point->data) && dll_pt_at_left(B)) return;
  if (gapbuf_at_left(B->point->data)) dll_pt_backward(B);
  gapbuf_backward(B->point->data);
}

void tbuf_insert(tbuf* B, char c) 
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  if (gapbuf_full(B->point->data)) {
    tbuf_split_pt(B);
  }

  gapbuf_insert(B->point->data, c);
}

void tbuf_delete(tbuf* B) 
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  if (tbuf_empty(B)) return;
  if (dll_pt_at_left(B) && gapbuf_at_left(B->point->data)) return;
  
  if (gapbuf_at_left(B->point->data))
    //@assert !dll_pt_at_left(B);
    dll_pt_backward(B);

  //@assert !gapbuf_at_left(B->point->data);
  gapbuf_delete(B->point->data);

  if (!dll_pt_one(B) && gapbuf_empty(B->point->data)) 
    dll_pt_delete(B);
}