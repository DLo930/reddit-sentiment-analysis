\section*{Error: out of memory}
Uh-oh! The 15-122 supercomputer has just run out of memory!  Now how
will the TAs tackle their next challenge? For some extra credit, see
if you can help them out!

An \lstinline'int' array is \emph{palindrome} if reading it from left
to right and from right to left yields the same numbers.  For example,
$[1,2,3,2,1]$ is palindrome, but $[1,2,3,4,2]$ is not.  For years,
15-122 has been determining palindromes by checking if \lstinline'A'
and \lstinline'reverse(A, n)' have the same contents. However, this
requires allocating a new array every time you want to check if an
array is palindrome.  Alas, because we ran out of memory, we need a
more efficient solution.
\begin{part}\TAGS{correctness, loop-invariant, safety}
  The header for the old palindrome function is given below. It
  checks if \lstinline'A[i,j)' is a palindrome.  It uses an inclusive
  bound on \lstinline'i', but an exclusive bound on \lstinline'j'.
  % However,
  % when you write your palindrome function, you just need the upper
  % bound, labeled \lstinline'n'. \textbf{Only use this in contracts!}
\begin{lstlisting}
bool is_palindrome_old(int[] A, int i, int j)
//@requires 0 <= i && i <= j && j <= \length(A);
\end{lstlisting}
The TAs have again started you off by writing the function header and
the loop below.  Try and fill in the loop invariants using the
specification function we provided above.

\textbf{Hint:} you are returning \lstinline'true' at the end of the
function, so you want the loop invariants to help you prove that
\lstinline'is_palindrome_old(A, 0, n)' is true when the loop exits
normally.

\textbf{Remember:} labs are collaborative! If this is challenging, work with your neighbors!
\begin{lstlisting}[numbers=left, belowskip=0pt]
bool is_palindrome(int[] A, int n)
//@requires 0 <= n && n <= \length(A);
//@ensures \result == is_palindrome_old(A, 0, n);
{
  for (int i = [*\shortanswerline{~0~}*]; i < [*\shortanswerline{n/2}*]; i++)
  //@loop_invariant [*\answerline{0 <= i \&\& i <= n/2}*];
  //@loop_invariant [*\answerline{is\_palindrome\_old(A, n/2-i, (n+1)/2+i)}*];
  {
    [*\dots*]
  }
  return true;
}
\end{lstlisting}
\end{part}

\begin{part}\TAGS{testing}
  Again, using these loop invariants to guide you, open up
  \lstinline'palindrome.c0' and fill in the loop body there.  When
  ready, test your implementation as follows:

\begin{lstlisting}[language={[coin]C}, basicstyle=\smallbasicstyle]
  % coin -d palindrome.c0
  --> is_palindrome(to_arr(1221), 4);
  true (bool)
  --> is_palindrome(to_arr(122), 3);
  false (bool)
  --> is_palindrome(to_arr(9), 1);
  true (bool)
\end{lstlisting}

You can test your code by running %
\lstinline[language={[coin]C}]'cc0 -d -x palindrome.c0 test-palindrome.c0'\\
Make sure your code passes this test to get the extra credit!

\threePT
\begin{solution}
\begin{lstlisting}[numbers=left, belowskip=0pt]
bool is_palindrome(int[] A, int n)
//@requires 0<= n && n <= \length(A);
//@ensures \result == is_palindrome_old(A, 0, n);
{
  for (int i = 0; i < n/2; i++)
  //@loop_invariant 0 <= i && i <= n/2;
  //@loop_invariant is_palindrome_old(A, n/2-i, (n+1)/2+i);
  {
    if (A[n/2-i-1] != A[(n+1)/2+i]) {
      return false;
    }
  }
  return true;
}
\end{lstlisting}
\end{solution}
\end{part}
