// Contract exploit: leaves the image alone


bool is_valid_mask(int[] mask, int maskwidth) 
//@requires is_valid_imagesize(maskwidth, maskwidth);
//@requires \length(mask) == maskwidth * maskwidth;
{
  if (!(maskwidth % 2 == 1)) return false;
  if (!(mask[maskwidth * (maskwidth/2) + maskwidth/2] > 0)) return false; 
  for (int i = 0; i < maskwidth*maskwidth; i++) 
    //@loop_invariant 0 <= i;
    if (!(mask[i] >= 0)) return false; 
  return true;
}

pixel[] blur(pixel[] pixels, int width, int height,
             int[] mask, int maskwidth) 
//@requires is_valid_imagesize(width, height);
//@requires \length(pixels) == width*height;
//@requires is_valid_imagesize(maskwidth, maskwidth);
//@requires \length(mask) == maskwidth * maskwidth;
//@requires is_valid_mask(mask, maskwidth);
{
  pixel[] B = alloc_array(pixel, width*height);
  
  int radius = maskwidth/2;

  for (int row = 0; row < height; row++) 
    //@loop_invariant 0 <= row;
    {
      for (int col = 0; col < width; col++) 
        //@loop_invariant 0 <= col;
        {
          int accum = 0;
          int red = 0;
          int green = 0;
          int blue = 0;

          // Now iterate through the positions in the image that
          // correspond to mask locations
          for (int mrow = row-radius; mrow < row+radius+1; mrow++) {
            for (int mcol = col-radius; mcol < col+radius+1; mcol++) {

              int maskrow = mrow - (row-radius);
              int maskcol = mcol - (col-radius);
              //@assert 0 <= maskrow && maskrow < maskwidth;
              //@assert 0 <= maskcol && maskcol < maskwidth;

              // We only care about the positions that are actually in
              // the image!
              if (is_valid_pixel(mrow, mcol, width, height)) {

                // The way we've iterated makes it easy to compute the
                // image position/index and more annoying to recover
                // the mask index.
                int i = get_index(mrow, mcol, width, height);
                int maski = get_index(mrow-row+radius, 
                                      mcol-col+radius,
                                      maskwidth,
                                      maskwidth);

                // Update weighted sums
                int weight = 1;
                accum += weight;
                red += get_red(pixels[i]) * weight;
                green += get_green(pixels[i]) * weight;
                blue += get_blue(pixels[i]) * weight;
              }
            }
          }

          int i = get_index(row, col, width, height);
          B[i] = make_pixel(get_alpha(pixels[i]),
                            red/accum,
                            green/accum,
                            blue/accum);
        }
    }

  return B;
}

