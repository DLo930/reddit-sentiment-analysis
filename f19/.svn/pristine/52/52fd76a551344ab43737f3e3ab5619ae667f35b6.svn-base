\newpage
\section*{Graph search%
\TAGS{graph, traverse-ds}}

We've discussed two algorithms for traversing a graph: depth-first
search (DFS) and breadth-first search (BFS). DFS always visits the
first neighbor of a vertex before visiting the rest of the neighbors,
whereas BFS visits all neighbors of a vertex before continuing the
search in a neighbor's neighbor.


\checkpoint*{\TAGS{graph, traverse-ds}}

Assume you wish to search the above graph for vertex $K$ starting at
vertex $A$. List the vertices of the graph in the order visited by DFS
and BFS.  Assume that the algorithms consider neighbors in
alphabetical order.

\begin{solution}
DFS: A, B, C, D, E, F, H, I, K

BFS: A, B, C, E, F, D, H, I, J, K

Shortest-to-Largest Distance: A, B, C, E, F, D, H, I, J, K (same as BFS)
\end{solution}

Now list the vertices in order of distance from $A$. Do you notice anything?


\checkpoint*{\TAGS{graph, traverse-ds}}

In class we studied a recursive implementation of DFS\@. Finish the
iterative implementation of DFS below.

\enlargethispage{5ex}
\bgroup
\smalllistings
\begin{lstlisting}[numbers=left, belowskip=0pt]
bool dfs(graph_t G, vertex start, vertex target) {
  REQUIRES(G != NULL);
  REQUIRES(start < graph_size(G) && target < graph_size(G));

  if (start == target) return true;

  bool mark[graph_size(G)];
  for (unsigned int i = 0; i < graph_size(G); i++)
    mark[i] = false;
  mark[start] = true;

  [*\shortanswerline{istack\_t S = stack\_new();\hspace{3.5em}}*] // initialize data structure

  [*\shortanswerline{push(S, start);\hspace{6.9em}}*] // put start into our data structure

  while ([*\shortanswerline{!stack\_empty(S)\hspace{3.2em}}*]) { // unless our data structure is empty

    vertex v = [*\shortanswerline{pop(S);\hspace{4.8em}}*] // retrieve a vertex from our data structure
    vert_list *nbors = graph_get_neighbors(G, v);
    for (vert_list *p = nbors; p != NULL; p = p->next) {
      vertex w = p->vert;
      if (w == target) {

        [*\shortanswerline{stack\_free(S);\hspace{8.9em}}*] // free our data structure
        graph_free_neighbors(nbors);
        return true;
      }
      if (!mark[w]) {      // if w was not seen before[*\label{l:dfs-if2}*]
        mark[w] = true;       // Mark it as known[*\label{l:dfs-mark}*]

        [*\shortanswerline{push(S, w);\hspace{5.7em}}*] // add the neighbor to our data structure
      }
    }
    graph_free_neighbors(nbors);
  }
  [*\shortanswerline{stack\_free(S);\hspace{10.9em}}*] // free our data structure
  return false;
}
\end{lstlisting}
\egroup