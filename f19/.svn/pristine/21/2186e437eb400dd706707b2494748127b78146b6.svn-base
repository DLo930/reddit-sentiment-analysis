\newpage
\part[3\half]\TAGS{bst, divide-and-conquer, loop-invariant}
The function \lstinline'bst_insert' in the lecture notes is recursive,
but it is also possible to implement it iteratively. Fill in the
missing code.

\enlargethispage{5ex}
\begin{framed}
\begin{lstlisting}[aboveskip=-1pt, belowskip=-1pt]
tree* bst_insert(tree* T, entry e)
//@requires is_bst(T) && e != NULL;
//@ensures is_bst(\result);
{
  key k = entry_key(e);
  tree* parent = NULL;
  tree* current = [*\uanswer{26em}{T}*];
  while (current != NULL)
    /*@loop_invariant current == NULL || parent == NULL

                   || current == [*\uanswer{15.5em}{parent->left}*]

                   || current == [*\uanswer{15.5em}{parent->right}*];@*/
    {
      parent = current;
      int cmp = key_compare(k, entry_key(current->data));
      if (cmp == 0) {
        current->data = e;
        return T;
      } else if (cmp < 0) {

        current = [*\uanswer{26em}{current->left}*];
      } else { //@assert cmp > 0;

        current = [*\uanswer{26em}{current->right}*];
      }
    }
  tree* R = alloc(tree);
  R->data = e;
  if (parent != NULL) {

    int cmp = [*\uanswer{28.5em}{entry\_compare(k, entry\_key(parent->data))}*];
    if (cmp < 0)
      [*\uanswer{33.3em}{parent->left = R}*];
    else
      [*\uanswer{33.3em}{parent->right = R}*];
  }
  else {
    [*\uanswer{34.3em}{T = R}*];
  }
  return T;
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (d)
TAGS: bst, divide-and-conquer, loop-invariant

Gradescope rubric:
+0.5pts tree* current = ___T___;
+0.25pts || current == ___parent->left___
+0.25pts || current == ___parent->right___
+0.5pts if (cmp < 0) current = ___current->left___
+0.5pts if (cmp > 0) current = ___current->right___
+0.5pts cmp = ___entry_compare(k, entry_key(parent->data))___;
+0.25pts if (cmp < 0) ___parent->left = R___
+0.25pts else ___parent->right = R___
+0.5pts else ___T = R___ (or, else return R)

Commentary:
First slot .5 point tree* current = T;

Next four slots 1 point:
      || current == parent->left
      || current == parent->right
        current = current->left;
        current = current->right;
Give half credit if they got the directions backward in the assignment
to current.

Next two slots 1 point:
      parent->left = R;
      parent->right = R;

Last slot .5 point:
    T = R; (alternatively, return R)
ENDRUBRIC
