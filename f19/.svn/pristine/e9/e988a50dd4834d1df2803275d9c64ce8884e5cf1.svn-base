#use <args>
#use <string>

tbuf construct_char_buffer(string s) 
{
  int limit = string_length(s);
  tbuf B = alloc(struct text_buffer);

  B->start = alloc(struct list_node);

  dll last = B->start;
  for(int i = 0; i < limit; i++) 
    //@loop_invariant 0 <= i && i <= limit;
    {
      last->next = alloc(struct list_node);
      last->next->prev = last;
      last->next->data = string_charat(s,i);
      last = last->next;
    }

  last->next = alloc(struct list_node);
  last->next->prev = last;

  B->point = last;
  B->end = last->next;

  return B;
}

int main() {
  args_t args = args_parse();
  if (args->argc != 1) 4/0; // Bug in autograder!
  string s = args->argv[0];
  tbuf B = alloc(struct text_buffer);
  tbuf E = construct_char_buffer("e");
  tbuf ER = construct_char_buffer("xy");
  tbuf EL = construct_char_buffer("xy"); EL->point = EL->start->next;

  // Magic arguments for testing invalid input
  if (string_equal("at_left", s)) { tbuf_at_left(B); }
  else if (string_equal("at_right", s)) { tbuf_at_right(B); }
  else if (string_equal("forward1", s)) { tbuf_forward(B); }
  else if (string_equal("forward2", s)) { tbuf_forward(E); }
  else if (string_equal("forward3", s)) { tbuf_forward(ER); }
  else if (string_equal("backward1", s)) { tbuf_backward(B); }
  else if (string_equal("backward2", s)) { tbuf_backward(E); }
  else if (string_equal("backward3", s)) { tbuf_backward(EL); }
  else if (string_equal("delete_point1", s)) { tbuf_delete_point(B); }
  else if (string_equal("delete_point2", s)) { tbuf_delete_point(E); }
  else { 4/0; }

  return 0;
}