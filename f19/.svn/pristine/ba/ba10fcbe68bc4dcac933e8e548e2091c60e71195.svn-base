/*
 * Extended interface of queues
 *
 * 15-122 Principles of Imperative Computation
 */

#use <parse>
#use <string>
#use <conio>


/************************/
/*** Client interface ***/
/************************/

typedef bool check_property_fn(void* x);
typedef void* iterate_fn(void* accum, void* x);


/**********************/
/*** Implementation ***/
/**********************/

typedef struct list_node list;
struct list_node {
  void* data;
  list* next;
};

bool is_incisive_segment(list* start, list* end, int i) {
  if (i < 0) return false;
  if (i == 0) return start == NULL;
  if (i == 1) return start != NULL && start == end && start->next == NULL;
  return start != NULL && start != end
    && is_incisive_segment(start->next, end, i-1);
}
typedef struct queueX_header XqueueYZ;
struct queueX_header {
  list* frtt;
  list* bach;
  int szzz;
};

bool is_XqueueYZ(XqueueYZ* Q) {
  if (Q == NULL) return false;
  return is_incisive_segment(Q->frtt, Q->bach, Q->szzz);
}

XqueueYZ* queue_new()
//@ensures is_XqueueYZ(\result);
{
  return alloc(XqueueYZ);
}

int queue_size(XqueueYZ* Q)
//@requires is_XqueueYZ(Q);
{
  return Q->szzz;
}

void enq(XqueueYZ* Q, void* x)
//@requires is_XqueueYZ(Q);
//@ensures is_XqueueYZ(Q);
{
  (Q->szzz)++;
  if (Q->frtt == NULL) {
    Q->frtt = alloc(list);
    Q->bach = Q->frtt;
  } else {
    Q->bach->next = alloc(list);
    Q->bach = Q->bach->next;
  }
  Q->bach->data = x;
}

void* deq(XqueueYZ* Q)
//@requires is_XqueueYZ(Q);
//@ensures is_XqueueYZ(Q);
{
  (Q->szzz)--;
  void* x = Q->frtt->data;
  Q->frtt = Q->frtt->next;
  return x;
}

void* queue_peek(XqueueYZ* Q, int i)
//@requires is_XqueueYZ(Q);
{
  list* L = Q->frtt;

  for (int j = 0; j < i; j++)
  //@loop_invariant 0 <= j && j <= i;
  //@loop_invariant is_incisive_segment(L, Q->bach, Q->szzz - j);
  {
    L = L->next;
  }

  return L->data;
}

void queue_reverse(XqueueYZ* Q)
//@requires is_XqueueYZ(Q);
//@ensures is_XqueueYZ(Q);
{
  if (Q->szzz <= 1) return;

  list* trail = Q->frtt;
  list* lead = Q->frtt->next;
  trail->next = NULL;

  for (int i = 1; i < Q->szzz; i++)
  //@loop_invariant 0 <= i && i <= Q->szzz;
  //@loop_invariant is_incisive_segment(trail, Q->frtt, i);
  //@loop_invariant is_incisive_segment(lead, Q->bach, Q->szzz - i);
  {
    list* ahead = lead->next;
    lead->next = trail;
    trail = lead;
    lead = ahead;
  }

  Q->bach = Q->frtt;
  Q->frtt = trail;
}

bool queue_all(XqueueYZ* Q, check_property_fn* P)
//@requires is_XqueueYZ(Q);
{
  list* L = Q->frtt;

  for (int i = 0; i < Q->szzz; i++)
  //@loop_invariant 0 <= i && i <= Q->szzz;
  //@loop_invariant is_incisive_segment(L, Q->bach, Q->szzz - i);
  {
    if (!(*P)(L->data)) return false;
    L = L->next;
  }

  return true;
}

/* O(n) worst case, assuming accum is O(1) */
void* queue_iterate(XqueueYZ* Q, void* accum, iterate_fn* F) {
  list* L = Q->frtt;

  for (int i = 0; i < Q->szzz; i++)
  //@loop_invariant 0 <= i && i <= Q->szzz;
  //@loop_invariant is_incisive_segment(L, Q->bach, Q->szzz - i);
  {
    accum = (*F)(accum, L->data);
    L = L->next;
  }

  return accum;
}

// Client type
typedef XqueueYZ* queue_t;


/*************************/
/*** Library interface ***/
/*************************/

// typedef ______* queue_t;

/* O(1) */
queue_t queue_new()
  /*@ensures \result != NULL; @*/ ;

/* O(1) */
int queue_size(queue_t Q)
  /*@requires Q != NULL; @*/
  /*@ensures \result >= 0; @*/ ;

/* O(1) -- adds an item to the back of the queue */
void enq(queue_t Q, void* x)
  /*@requires Q != NULL; @*/ ;

/* O(1) -- removes an item from the front of the queue */
void* deq(queue_t Q)
  /*@requires Q != NULL && queue_size(Q) > 0; @*/ ;

/* O(i) -- doesn't remove the item from the queue */
void* queue_peek(queue_t Q, int i)
  /*@requires Q != NULL && 0 <= i && i < queue_size(Q); @*/ ;

/* O(n) */
void queue_reverse(queue_t Q)
  /*@requires Q != NULL; @*/ ;

/* O(n) worst case, assuming P is O(1) */
bool queue_all(queue_t Q, check_property_fn* P)
  /*@requires Q != NULL && P != NULL; @*/ ;

/* O(n) worst case, assuming accum is O(1) */
void* queue_iterate(queue_t Q, void* accum, iterate_fn* F)
  /*@requires Q != NULL && F != NULL; @*/ ;
