\section*{Implementing the traversal}

There are two parts to the in-order traversal implementation.  First,
we need a function that gives us the starting traversal stack (which
represents the first element we need to look at).  Once we have a
traversal stack, we need a way to move ahead in the traversal to look
at the next element.

\begin{part}\TAGS{bst, traverse-ds}
  In file \lstinline'bst.c1', implement the function
  \lstinline'bst_traverse_start'.  This function returns the initial
  traversal stack that we'll use to begin our traversal (as in the
  first step of the diagram above).  The stack should contain all the
  nodes on the path from the root to the minimum element, with the
  minimum element at the top of the stack.
\begin{solution}
\begin{lstlisting}
stack_t bst_traverse_start(bst* B)
//@requires is_bst(B);
//@ensures \result != NULL;
{
  stack_t S = stack_new();
  tree* node = B->root;
  while (node != NULL) {
    push(S, (void*)node);
    node = node->left;
  }
  return S;
}
\end{lstlisting}
\vspace*{-0.5em}
\end{solution}
\end{part}

\begin{part}\TAGS{bst, testing, traverse-ds}
  In file \lstinline'bst.c1', implement the function
  \lstinline'bst_traverse_next'.  Each time this function is called,
  the next smallest element in the tree is returned.  Given a
  traversal stack, this function should do three things:
\begin{enumerate}
\itemsep=0em
\item%
  Retrieve the data at the current node (which is at the top of the
  traversal stack)
\item%
  Modify the stack so that it represents the next node in the in-order
  traversal of the tree
\item%
  Return the retrieved data
\end{enumerate}

Also, implement the one-line function
\lstinline'bst_traverse_finished', which returns whether or not the
given traversal stack has been advanced past the last element in the
tree. This should be used in a precondition of
\lstinline'bst_traverse_next'.
\begin{solution}
\begin{lstlisting}
bool bst_traverse_finished(stack_t S) {
  return stack_empty(S);
}

elem bst_traverse_next(stack_t S)
//@requires !bst_traverse_finished(S);
//@ensures \result != NULL;
{
  tree* curr = (tree*)pop(S);
  tree* node = curr->right;
  while (node != NULL) {
    push(S, (void*)node);
    node = node->left;
  }
  return curr->data;
}
\end{lstlisting}
\vspace*{-0.5em}
\end{solution}
\end{part}
\vspace*{-0.5em}
You can test your code using: %
\lstinline'cc0 -d -x lib/stack.c1 bst.c1 test-traverse.c1'.

\twoPT