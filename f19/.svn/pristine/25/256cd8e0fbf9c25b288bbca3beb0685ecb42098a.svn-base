/*
 * Dictionaries, implemented as assocation lists
 *
 * 15-122 Principles of Imperative Computation, Fall 2012
 * Frank Pfenning
 */

#use <string>
#use "lib/queues_string.c0"

/* Interface to dictionaries */

typedef struct dict_header* dict;

dict dict_new();
void dict_insert(dict D, string name, queue def);
queue dict_lookup(dict D, string name);
/* returns NULL if name is not defined */

/* Implementation of dictionaries as association lists */

/* Association lists */
struct _alist_node {
  string _name;
  queue _def;
  struct _alist_node* _next;
};
typedef struct _alist_node _alist;

/* Association lists should be non-circular, but we
 * do not check this explicitly.  NULL is a valid
 * (empty) association list.
 */

/* Dictionaries */
struct dict_header {
  _alist* _assoclist;
};

bool is_dict (dict D) {
  return D != NULL;
}

/* Allocating a new dictionary */
dict dict_new()
//@ensures is_dict(\result);
{
  dict D = alloc(struct dict_header);
  D->_assoclist = NULL;
  return D;
}

_alist* _alist_find(_alist* p, string _name)
//@ensures \result == NULL || string_equal(\result->_name, _name);
{
  while (p != NULL) {
    if (string_equal(p->_name, _name))
      return p;
    p = p->_next;
  }
  return NULL;
}

queue dict_lookup(dict D, string _name)
//@requires is_dict(D);
{
  _alist* p = _alist_find(D->_assoclist, _name);
  if (p == NULL)
    return NULL;
  else
    return p->_def;
}

void dict_insert(dict D, string _name, queue _def)
//@requires is_dict(D);
//@ensures is_dict(D);
//@ensures dict_lookup(D, _name) == _def;
{
  _alist* p = D->_assoclist;
  _alist* q = _alist_find(p, _name); /* NULL if undefined */
  //@assert q == NULL || string_equal(q->_name, _name);
  if (q == NULL) {
    /* insert at beginning of association list */
    q = alloc(struct _alist_node);
    q->_name = _name;
    q->_def = _def;
    q->_next = p;
    D->_assoclist = q;
  } else {
    /* update existing definition */
    q->_def = _def;
  }
  return;
}
