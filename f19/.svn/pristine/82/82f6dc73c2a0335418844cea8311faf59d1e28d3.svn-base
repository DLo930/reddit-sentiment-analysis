/*
 * Clac, stack-based calculator language
 *
 * 15-122 Principles of Imperative Computation
 */

#use <string>
#use <parse>
#use <conio>
#use <args>
#use <util>

/* From the perspective of the clac-main.c0 file, state_t is an
 * abstract type. (typedef ____* state_t) This file contains the
 * implementation of the state_t type. You will add new fields to this
 * struct when you do task 4. */
struct state_header {
  dict_t D;
  qstack_t call_stack;
};
typedef struct state_header* state_t;
state_t init_state()
//@ensures \result != NULL;
{
  state_t X = alloc(struct state_header);
  X->D = dict_new();
  X->call_stack = qstack_new();
  return X;
}

void createDict(queue_t Q, state_t C, string tok)
{ 
  if (dict_lookup(C->D,tok) != NULL) 
  {
    queue_t FD = dict_lookup(C->D,tok);
    queue_t copy = queue_read_only_copy(FD);
    dict_insert(C->D, tok, copy);
    qpush(C->call_stack,Q);
    while (!queue_empty(FD))
    {
      enq(Q,deq(FD));
    }
  } 
  else if (queue_empty(Q) && !qstack_empty(C->call_stack))
  {
    queue_t L = qpop(C->call_stack);
    while (!queue_empty(L))
    {
      enq(Q,deq(L));
    }
  }
  else if (string_equal(tok,":"))
  {
    if (!queue_empty(Q))
    {
      string dict_word = deq(Q);
      queue_t K = queue_new();
      while (!string_equal(tok,";"))
      {
        tok = deq(Q);
        enq(K,tok);
      }
      deq(Q);
      if (queue_empty(K)) error("no definition for word");
      dict_insert(C->D, dict_word, K);
    }
  }  
}


/* Main clac interpreter. */
/* Return true: clac top-level interpreter will expect more input */
/* Return false: clac top-level interpreter will exit */
bool eval(queue_t Q, stack_t S, state_t ST)
//@requires Q != NULL && S != NULL && ST != NULL;
{
  while (!queue_empty(Q) || !qstack_empty(ST->call_stack)) 
  { 
    assert(!queue_empty(Q));
    string tok = deq(Q); /* Is this dequeue safe? */
    // Uncommenting these lines might help with debugging:
    //print("Read: "); print(tok); print("\n");
    if (string_equal(tok, "print")) {
      if (!stack_empty(S)) 
      {
        int x = pop(S); /* This line is unsafe and must be fixed! */
        printint(x); print("\n");
      }
      else
      {
        error("no integer to perform operation on");
      }
    } else if (string_equal(tok, "quit")) {
      return false;
    } 
    else if (string_equal(tok,"+"))
    {
      int x = 0; int y = 0;
      if (!stack_empty(S))
      {
        y = pop(S);
      } else {
        error("no integer to perform addition operation on");
      } if (!stack_empty(S)) {
        x = pop(S);
      } else {
        error("no integer to perform addition operation on");
      }
      int result = x + y;
      push(S,result);
    }
    else if (string_equal(tok,"-"))
    {
      int x = 0; int y = 0;
      if (!stack_empty(S))
      {
        y = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      if (!stack_empty(S))
      {
        x = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      int result = x - y;
      push(S,result);
    }
    else if (string_equal(tok,"*"))
    {
      int x = 0; int y = 0;
      if (!stack_empty(S))
      {
        y = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      if (!stack_empty(S))
      {
        x = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      int result = x * y;
      push(S,result);
    }
    else if (string_equal(tok,"/"))
    {
      int x = 0; int y = 0;
      if (!stack_empty(S))
      {
        y = pop(S);
        if (y == 0) error("can't divide by zero!");
      }
      else
      {
        error("no integer to perform operation on");
      }
      if (!stack_empty(S))
      {
        x = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      if (x == int_min() && y == -1) error("can't divide int_min() and -1");
      int result = x / y;
      push(S,result);
    }
    else if (string_equal(tok,"%"))
    {
      int x = 0; int y = 0;
      if (!stack_empty(S))
      {
        y = pop(S);
        if (y == 0) error("can't divide a number by 0");
      }
      else
      {
        error("no integer to perform operation on");
      }
      if (!stack_empty(S))
      {
        x = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      if (x == int_min() && y == -1) error("can't divide int_min() and -1");
      int result = x % y;
      push(S,result);
    }
    else if (string_equal(tok,"<"))
    {
      int x = 0; int y = 0;
      if (!stack_empty(S))
      {
        y = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      if (!stack_empty(S))
      {
        x = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      if (x < y) push(S,1);
      else if (x >= y) push(S,0);
    }
    else if (string_equal(tok,"drop"))
    {
      int x = 0;
      if (!stack_empty(S))
      {
        x = pop(S);
      }
      else
      {
        error("stack is empty!");
      }
    }
    else if (string_equal(tok,"swap"))
    {
      int x = 0; int y = 0;
      if (!stack_empty(S))
      {
        y = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      if (!stack_empty(S))
      {
        x = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      push(S,y);
      push(S,x);
    }
    else if (string_equal(tok,"rot"))
    {
      int x = 0; int y = 0; int z = 0;
      if (!stack_empty(S))
      {
        z = pop(S); 
      }
      else
      {
        error("no integer to perform operation on");
      }
      if (!stack_empty(S))
      {
        y = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      if (!stack_empty(S))
      {
        x = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      push(S,y);
      push(S,z);
      push(S,x);
    }
    else if (string_equal(tok,"if"))
    {
      int x = 0;
      if (!stack_empty(S))
      {
        x = pop(S);
        if (x == 0)
        {
          if (!queue_empty(Q)) deq(Q);
          else error("no token");
          if (!queue_empty(Q)) deq(Q);
          else error("no token");
          if (!queue_empty(Q)) deq(Q);
          else error("no token");
        }
      }
      else
      {
        error("no integer to perform operation on");
      }
    }
    else if (string_equal(tok,"skip"))
    {
      int n = 0;
      if (!stack_empty(S))
      {
        n = pop(S);
      }
      else
      {
        error("no integer to perform operation on");
      }
      if (n < 0) error("cannot have a negative value for skip");
      for(int i = 0; i < n; i++)
      {
        if (!queue_empty(Q)) deq(Q);
        else error("no more elements in Q");
      }
    }
    else if (string_equal(tok,"pick"))
    {
       int n = 0;
       if (!stack_empty(S))
       {
         n = pop(S);
         if (n <= 0) error("cannot perform pick operation because n <= 0");
         stack_t temp = stack_new();
         int tracker = 0;
         int putback = 0;
         for(int i = 1; i <= n; i++)
         {
           if (!stack_empty(S))
           {
             tracker = pop(S);
             push(temp, tracker);
           }
           else error("no integer to perform operation on");
         }
         while (!stack_empty(temp))
         {
           putback = pop(temp);
           push(S,putback);
         }
         push(S,tracker);
       }
       else
       {
         error("no integer to perform operation on");
       }
    }
    else if (dict_lookup(ST->D,tok) != NULL) 
    {
      queue_t FD = dict_lookup(ST->D,tok);
      queue_t copy = queue_read_only_copy(FD);
      qpush(ST->call_stack,Q);
      Q = copy;
    }
    else if (queue_empty(Q) && !qstack_empty(ST->call_stack))
    {
      queue_t L = qpop(ST->call_stack);
      Q = L;
    } 
    else if (string_equal(tok,":"))
    {
      if (!queue_empty(Q))
      {
        string dict_word = deq(Q);
        //check and see if it overrides a basic thingy
        queue_t K = queue_new();
        while (!string_equal(tok,";") && !queue_empty(Q))
        {
          tok = deq(Q);
          enq(K,tok);
        }
        if (!string_equal(tok,";")) error("no semicolon after definition");
        if (queue_empty(K)) error("no definition for word");
        dict_insert(ST->D, dict_word, K);
      }
      else error("Q is empty!!! and there is no definition");
    }
    else 
    {
      /* Not defined as an operation name, should be an int */
      int* p = parse_int(tok, 10);
      if (p == NULL) { /* not an int */
        /* call error(msg) which prints msg and aborts */
        error(string_join("undefined token ", tok));
      }
      push(S, *p);
    }
  }

  /* When you return "true", don't pop anything off the stack! When we
   * grade your function, we'll check that the stack contains the
   * integers we expect. */
  return true;
}
