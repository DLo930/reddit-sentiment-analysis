%% See also customization at the bottom

\clearpage
\Question{Binary Search Trees}

\begin{parts}

\newcommand{\insseqA}  % Vary from time to time
 {87, 78, 16, 121, 82, 104, 88, 41, 100, 111}
%{93, 86, 71, 115, 88, 99,  94, 77, 95,  109}
%{88, 79, 17, 122, 83, 105, 89, 42, 101, 112}
%{91, 85, 69, 110, 87, 98,  93, 76, 94,  108}
\newcommand{\insseqB}  % Vary from time to time
{76, 51, 103, -12, 88}
%{42, 11, 59, -7, 83}
%{59, 31, 81, -9, 87}
%{58, 29, 80, -8, 88}

\part[1]\TAGS{bst}
Draw the final binary search tree that results from inserting the
following keys in the order given.  Make sure all branches in your tree
are drawn \emph{clearly} so we can distinguish left branches from
right branches.
\bigskip
\begin{center}\tt
\insseqA
\end{center}
\bigskip
\begin{framed} % Paste the appropriate version

\ifprintanswers{
\begin{lstlisting}[basicstyle=\basicstyle\color{\answerColor}]
                        87
                      /    \
                     /      \
                   78        121
                  /  \       /
                16    82    104
                 \         /  \
                 41       88  111
                            \
                            100
\end{lstlisting}}
\else~\vspace{7in}\fi
\end{framed}

\RUBRIC
Part (a)
TAGS: bst

Gradescope rubric:
+1pt Correct

Commentary:
                        87
                      /    \
                     /      \
                   78        121
                  /  \       /
                16    82    104
                 \         /  \
                 41       88  111
                            \
                            100
ENDRUBRIC


\newpage
\part[2]\TAGS{bst}
How many different binary search trees can be constructed using the
following five keys if they can be inserted in any order?

\bigskip
\begin{center}\tt
\insseqB
\end{center}
\bigskip

Show how your answer is derived. We've begun the derivation below;
we've used $t(n)$ to stand for the number of binary search trees with
$n$ nodes.

\emph{Think recursively:} How many trees with 0 nodes can possibly
exist? How many different trees with 1 node can possibly exist?  2
nodes? 3 nodes? 4 nodes? Think about how to build up your answer from
answers to simpler questions. (It might help to come back to this
question after doing the last question on AVL tree height.)

\bigskip
\begin{center}
\newcommand{\ans}[1]{\answer{27em}{#1}}
\renewcommand{\arraystretch}{2.5}
\begin{tabular}{@{}|c|p{32.6em}|@{}}
       \hline $n$ & \multicolumn{1}{c|}{$t(n)$}
\\[5pt]\hline  0  & $t(0) = 1$
\\[5pt]\hline  1  & $t(1) = 1$
\\[5pt]\hline  2  & $t(2) = t(0)\times t(1) + t(1) \times t(0) = 2$
\\[5pt]\hline  3  & $t(3) = \ans{$t(2) \times t(0) + t(1) \times t(1) +
                                 t(0) \times t(2) \;\;=\;\; 2 + 1 + 2 \;\;=\;\; 5$}$
\\[5pt]\hline  4  & $t(4) = \ans{$\sum_{i=0}^3 t(i) \times t(3-i) \;\;=\;\; 5 + 2 + 2 + 5 \;\;=\;\; 14$}$
\\[5pt]\hline  5  & $t(5) = \ans{$\sum_{i=0}^4 t(i) \times t(4-i) \;\;=\;\; 14 + 5 + 4 + 5 + 14 \;\;=\;\; 42$}$
\\[5pt]\hline
\end{tabular}
\end{center}

\bigskip
What is the general formula for $t(n)$ when $n > 0$?
\begin{framed}
\medskip
$t(n) = \answer{31em}{$\sum_{i=0}^n t(i) \times t(n-i)$}$
\end{framed}

\RUBRIC
Part (b)
TAGS: bst

Gradescope rubric:
+1pt Correct answers in table (5, 14, 42)
+1pt Correct general formula

Commentary:
 Derivation:
 t(0): 1
 t(1): 1
 t(2): t(1)*t(0) + t(0)*t(1) = 1 + 1 = 2
 t(3): t(2)*t(0) + t(1)*t(1) + t(0)*t(2) = 2 + 1 + 2 = 5
 t(4): t(3)*t(0) + t(2)*t(1) + t(1)*t(2) + t(0)*t(3) = 5 + 2 + 2 + 5 = 14
 t(5): t(4)*t(0) + t(3)*t(1) + t(2)*t(2) + t(1)*t(3) + t(0)*t(4) = 14 + 5 + 4 + 5 + 14 = 42

It doesn't need to be in exactly the above form but each line should
have the correct number. One point if they make one mistake and
following lines are consistent with it.

General form (many solutions):
- \Sum_{i=0}^{n-1} t(i) \times t(n-i-1)
- \Sum_{i=1}^n t(i-1) \times t(n-i)
- \choose{2n}{n}/(n+1)
- (2n)!/((n+1)! \times n!)
- t(n-1) \times (4n-2)/(n+1)
ENDRUBRIC


\newpage
\begin{EnvUplevel}
  For the next few questions, we consider the implementation of
  dictionaries as binary search trees in the lecture notes.  In
  particular, recall the following declarations:
\end{EnvUplevel}

\begin{lstlisting}[aboveskip=2pt, belowskip=-6pt]
// typedef _______ key;
// typedef _______* entry;
key entry_key(entry e) /*@requires e != NULL; @*/ ;

bool is_bst(tree* T) {
  return is_tree(T) && is_ordered(T, NULL, NULL);
}
\end{lstlisting}
\begin{minipage}[t]{0.5\linewidth}
\begin{lstlisting}[aboveskip=0pt, belowskip=0pt]
struct dict_header {
  tree* root;
};
typedef struct dict_header dict;
\end{lstlisting}
\end{minipage}%
\hfill\rule[-11ex]{0.01em}{10.5ex}\hfill%
\begin{minipage}[t]{0.44\linewidth}
\begin{lstlisting}[aboveskip=0pt, belowskip=0pt]
bool is_dict(dict* D) {
  return D != NULL
      && is_bst(D->root);
}
\end{lstlisting}
\end{minipage}
\begin{EnvUplevel}
Like in class, the
client defines two functions: \lstinline'entry_key(e)' that extracts
the key of entry \lstinline'e', and \lstinline'key_compare(k1,k2)' that
returns \lstinline'-1' if key \lstinline'k1' is ``less than'' key
\lstinline'k2',
\lstinline'0' if \lstinline'k1' is ``equal to'' \lstinline'k2', and
\lstinline'1' if \lstinline'k1' is ``greater than'' \lstinline'k2'.
\end{EnvUplevel}
\vspace{-1ex}

%\input{print} % S19 S18 S17 S16
\input{reverseprint} % F19 F18 F17 F16

\newpage
\input{lookup} % F19 S18 S17
%\input{insert} % S19 S16
%\input{delete} % F18 F17 F16
%\input{height} %

\end{parts}
