\section*{C string libraries}

The header file \lstinline'string.h' outlines a number of string
functions that can be used (often incorrectly) in C programs. They
include:
\begin{lstlisting}[language={[coin]C}]
char *strcpy(char *dest, const char *src)
char *strncpy(char *dest, const char *src, size_t n)
size_t strlen(const char *str)
\end{lstlisting}
Read about how these functions work here:
\begin{quote}\tt
\url{http://en.wikipedia.org/wiki/C_string_handling#Functions}
\end{quote}
These functions assume that the pointers point to a \lstinline'NUL'-terminated
string (i.e., a string that ends with the character
`\lstinline'\0'', which has ASCII value 0).

\begin{part}\TAGS{c-memory, string, testing}
  Load the file \lstinline'ex3.c' into a text editor.  Read through the
  file and decide what you think the output will be before you run the
  program.

\begin{lstlisting}[language={[coin]C}, belowskip=0pt]
% gcc -Wall -Wextra -Werror -Wshadow -std=c99 -pedantic -g ex3.c
% ./a.out
\end{lstlisting}

\begin{solution}
\begin{lstlisting}[language={[coin]C}]
It may be desira<??gibberish??>
any process which alters the mutual relation of two or more things,
\end{lstlisting}
\end{solution}
\end{part}

\begin{part}\TAGS{c-memory, correctness, string}
  Did the results surprise you? Can you explain the difference in
  behavior of the two functions?
\begin{solution}
  The first function uses \lstinline'strncpy', which only copies the
  first 16 characters of the string. It doesn't copy the
  \lstinline'NUL' character, so the print function reads past the end
  of the buffer and prints gibberish.

  The second function uses \lstinline'strcpy', which always copies
  until reaching the end of the string. This causes the text to be
  printed successfully, but breaks the program by writing past the end
  of an array (so the third line never gets printed).
\end{solution}
\end{part}