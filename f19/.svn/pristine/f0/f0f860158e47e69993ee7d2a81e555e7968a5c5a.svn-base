/**
 *****************************************************************************
 *                              HOMEWORK  15-122
 *****************************************************************************
 *      A gap buffer data structure is represented by an array of chars stored
 *      along with its size (limit) and two integers representing the beginning
 *      (inclusive, gap start) and end (exclusive, gap end) of the gap.
 *
 * @author:
 *****************************************************************************/

typedef struct gap_buffer * gapbuf;
typedef gapbuf elem; // The data in linked lists will be gap buffers
struct gap_buffer
{
  int limit;     /* limit > 0                      */
  char[] buffer; /* \length(buffer) == limit       */
  int gap_start; /* 0 <= gap_start                 */
  int gap_end;   /* gap_start  <= gap_end <= limit */
};

/* INTERFACE */

bool is_gapbuf(gapbuf G);       /* Checks if this is a valid buffer    */
bool gapbuf_empty(gapbuf G);    /* Returns true if the buffer is empty */
bool gapbuf_full(gapbuf G);     /* Returns true if the buffer is full  */
int gapbuf_max_size(gapbuf G);  /* Returns the maximum elements in the buffer */
bool gapbuf_at_left(gapbuf G);  /* Returns true if the gap is at the   */
                                /*   left end of the buffer            */
bool gapbuf_at_right(gapbuf G); /* Returns true if the gap is at the   */
                                /*   right end of the buffer           */
gapbuf gapbuf_new(int limit);   /* Create a new gapbuf of size limit  */
void gapbuf_forward(gapbuf G);  /* Move the gap forward, to the right */
void gapbuf_backward(gapbuf G); /* Move the gap backward, to the left */
void gapbuf_insert(gapbuf G, char c); /* Insert the char c before the gap    */
void gapbuf_delete(gapbuf G);         /* Delete the character before the gap */
int gapbuf_left_pos(gapbuf G);        /* Returns the current start of the gap */ 
int gapbuf_right_pos(gapbuf G);       /* Returns the current end of the gap   */ 
char gapbuf_char_at(gapbuf G, int i); /* Return the char at position i in the buffer */


bool is_gapbuf(gapbuf G)        /* Checks if this is a valid buffer    */
{
  if (G == NULL) return false;
  //@assert \length(G->buffer) == G->limit;
  if (! (G->limit > 0)) return false;
  return (0 <= G->gap_start && G->gap_start <= G->gap_end && G->gap_end <= G->limit);
}


bool gapbuf_empty(gapbuf G)     /* Returns true if the buffer is empty */
//@requires is_gapbuf(G);
{
  return G->gap_start == 0 && G->gap_end == G->limit;
}

bool gapbuf_full(gapbuf G)      /* Returns true if the buffer is full  */
//@requires is_gapbuf(G);
{
  return G->gap_start == G->gap_end;
}

int gapbuf_max_size(gapbuf G)      /* Returns the limit of a buffer */
//@requires is_gapbuf(G);
{
  return G->limit;
}

char gapbuf_char_at(gapbuf G, int i) /* Return the char at position i */
//@requires is_gapbuf(G);
//@requires 0 <= i && i < gapbuf_left_pos(G) || gapbuf_right_pos(G) <= i && i < gapbuf_max_size(G);
{
  return G->buffer[i];
}

int gapbuf_left_pos(gapbuf G)   /* Returns the current left position   */
//@requires is_gapbuf(G);
//@ensures 0 <= \result && \result <= gapbuf_max_size(G);
{
  return G->gap_start;
}

int gapbuf_right_pos(gapbuf G)  /* Returns the current right position  */
//@requires is_gapbuf(G);
//@ensures 0 <= \result && \result <= gapbuf_max_size(G);
{
  return G->gap_end;
}

bool gapbuf_at_left(gapbuf G)   /* Returns true if the gap is at the   */
                                /*   left end of the buffer            */
//@requires is_gapbuf(G);
{
  return gapbuf_left_pos(G) == 0;
}

bool gapbuf_at_right(gapbuf G)  /* Returns true if the gap is at the   */
                                /*   right end of the buffer           */
//@requires is_gapbuf(G);
{
  return gapbuf_right_pos(G) == gapbuf_max_size(G);
}

gapbuf gapbuf_new(int limit)    /* Create a new gapbuf of size limit  */
//@requires 0 < limit;
//@ensures is_gapbuf(\result);
{
  gapbuf G = alloc(struct gap_buffer);
  G->buffer = alloc_array(char, limit);
  G->limit = limit;
  G->gap_start = 0;
  G->gap_end = limit;
  return G;
}

void gapbuf_forward(gapbuf G)   /* Move the gap forward, to the right */
//@requires is_gapbuf(G) && !gapbuf_at_right(G);
//@ensures is_gapbuf(G);
{
  G->buffer[G->gap_start] = G->buffer[G->gap_end];
  G->gap_start++;
  G->gap_end++;
  return;
}

void gapbuf_backward(gapbuf G)  /* Move the gap backward, to the left */
//@requires is_gapbuf(G) && !gapbuf_at_left(G);
//@ensures is_gapbuf(G);
{
  G->gap_start--;
  G->gap_end--;
  G->buffer[G->gap_end] = G->buffer[G->gap_start];
  return;
}

void gapbuf_insert(gapbuf G, char c)  /* Insert the char c before the gap    */
//@requires is_gapbuf(G) && !gapbuf_full(G);
//@ensures is_gapbuf(G);
{
  G->buffer[G->gap_start] = c;
  G->gap_start++;
  return;
}

void gapbuf_delete(gapbuf G)          /* Delete the character before the gap */
//@requires is_gapbuf(G) && !gapbuf_at_left(G);
//@ensures is_gapbuf(G);
{
  G->gap_start--;
  return;
}


/* IMPLEMENTATION */
