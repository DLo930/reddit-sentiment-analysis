/* 
 * Interface for bloom filters (sets)
 * Broken: misuse of sentiel values causes apparent deletion
 * 
 * 15-122 Principles of Imperative Computation */

#use <string>

/*** Interface to bloom filters ***/

// typedef ______* bloom_t;
typedef struct bloom_header* bloom_t;

bloom_t bloom_new(int table_size)
  /*@requires table_size > 0; @*/
  /*@ensures \result != NULL; @*/ ;

bool bloom_contains(bloom_t B, string x)
  /*@requires B != NULL; @*/ ;

void bloom_add(bloom_t B, string x)
  /*@requires B != NULL; @*/
  /*@ensures bloom_contains(B, x); @*/ ;

/*** Implementation of bloom filters ***/

typedef struct list_node list;
struct list_node {
  string data;
  list* next;
};

typedef struct bloom_header bloom;
struct bloom_header {
  list* chain;
};

bool has_sentinel(list* l) {
  if (l == NULL) return false;
  return string_equal(l->data, "")
    || has_sentinel(l->next);
}

bool is_bloom(bloom* B) { 
  return B != NULL; // too slow: && has_sentinel(B->chain);
}

bloom* bloom_new(int table_size)
//@requires table_size > 0;
//@ensures is_bloom(\result);
{
  bloom* B = alloc(bloom);
  B->chain = alloc(list);
  return B;
}

bool bloom_contains(bloom* B, string x) 
//@requires is_bloom(B);
{
  for (list* l = B->chain; true; l = l->next)
  //@loop_invariant has_sentinel(l);
  {
    if (string_equal(l->data, x)) return true;
    if (string_equal(l->data, "")) return false;
  }
  
  error("impossible");
}

void bloom_add(bloom* B, string x)
//@requires is_bloom(B);
//@ensures is_bloom(B);
//@ensures bloom_contains(B, x);
{
  list* l = alloc(list);
  l->next = B->chain;
  l->data = x;
  B->chain = l;
}