LAST: part II -- data structures
TODAY:
- transition to C
- the C pre-processor
  . #include
  . macros
  . conditional compilation
  . macro functions
- compilation
- memory management
NEXT: C's memory model

Important concepts (5 = highest, 1 = lowest)
============================================
[5] C preprocessor
[5] #include
[4] macros
[4] conditional compilation
[3] macro functions
[5] translating a C0 program (without arrays) to C
[5] malloc and xmalloc
[5] free
[5] valgrind
[4] memory ownership

IMPORTANT: make sure to finish this lecture in its entirety
           the current programming hw relies on everything in it


Transition to C
===============
- this course so far:
      give you a methodology to do the best out of a terrible programming language
- that's C
  . and actually many other recent popular languages (Python, PHP, Javascript)
- C is pervasively used for system-level programming (the language of 15-213)
- C is much more powerful than C0
  . but with great powers come great responsibilities
  . and a lot of dangers
- next 3 lectures: covering some of the main differences between C0/C1 and C
  . trip to the zoo
  . C0/C1 is a fragment of C (mostly) -- you have been programming in C all along!
- this lecture: translate a C0 program (without arrays) to C

[as we go along fill a lost/gained table -- see summary below]

The C preprocessor [GO FAST on pre-processor -- up to 'translating a C0 program to C']
==================
- C is not ONE terrible language but TWO
  . there is C itself (of which C0/C1 is largely a fragment)
  . there is the C PREPROCESSOR LANGUAGE whose commands start with #
- a normal C program contains both
  . first thing the C compiler does is to call a program called cpp
    . you never see cpp directly
  . cpp carries out all the preprocessor directives (start with #)
  . result is a program in C itself (usually ugly)
- the preprocessor language is very powerful
  . we will discuss just 5 features

File inclusion
==============
- #include <stdio.h>
  . includes the system file stdio.h in the current program
  . akin to #use <conio>
- #include "lib/xalloc.h"
  . includes the local file lib/xalloc.h in the current program
  . we never used something like this in C0
- preprocessor simply dumps the contents of that file in the current program
  . #use is a bit smarter -- see later
- argument of #include is a HEADER FILE
  . has a .h extension (e.g., stdio.h)
  . contains
    . a library's interface (function prototypes and type definitions)
    . other preprocessor directives
  . in truth could be any file, but (good) C programmers don't do that
  . NEVER #include ANYTHING OTHER THAN A .h FILE

Macro definitions
=================
- give a name to a constant
- example
      #define INT_MIN 0x80000000
  . INT_MIN is called a (MACRO) SYMBOL
- preprocessor will replace every occurrence of INT_MIN with 0x80000000
- in C0, int_min() was a function because it couldn't be anything else
  . a C0 program can define types and functions (and nothing else)
- by convention, macro symbols are written in all caps
- C macro definitions of constants are quite useful
- macros can define arbitrary expressions, not just constants
  . buggy example
      #define INT_MAX INT_MIN ^ -1
  (a bit silly but let's pretend)
  . preprocessor will expand
      INT_MAX / 2
    to
      0x80000000 ^ -1 / 2
    which, according to C operator precedences, corresponds to
      0x80000000 ^ (-1 / 2)
    which is not what we want
- the preprocessor doesn't understand precedences
- fixed definition of INT_MAX
      #define INT_MAX (INT_MIN ^ -1)
- DO NOT MAKE MACRO DEFINITIONS FOR COMPOSITE EXPRESSIONS
  (unless you know what you are doing ... after a few years of experience)

Conditional compilation
=======================
- allows compiling (or not) program segments depending on whether a symbol is defined
- example
      #ifdef DEBUG
        printf("Reached here\n");
      #endif
  . if DEBUG is defined, the next line is compiled as part of the program
    . define for example as
        #define DEBUG
      . no need to define it as anything
  . if DEBUG is not defined, the next line is cut out and never reaches the compiler itself
  . works similarly to -d flag in C0 (we will see a more convenient way to define it)
- an #else clause can be provided, e.g.,
      #ifdef X86_ARCH
        #include "arch/x86_optimizations.h"
        x86_optimize(code);
      #else
        generic_optimize(code);
      #endif
- variant: #ifndef keeps code that follows if symbol is NOT defined
- different from if-else commands of C0/C: part that is excluded is never compiled
  . compiled code is smaller, more specialized, often more efficient

Macro function definitions
==========================
- essentially a macro with arguments
- buggy example
      #define MULT(x,y) x * y
  . preprocessor expands
      MULT(1 + 2, 3 - 5) / 2
    to
      1 + 2 * 3 - 5 / 2
    ==> not what we wanted!
- use lots of parentheses!
      #define MULT(x,y) ((x) * (y))
- DO NOT MAKE MACRO FUNCTION DEFINITIONS
  (unless you know what you are doing ... after a few years of experience)
. we will provide you with all the macro function you will need
  . exactly 3 of them: REQUIRES, ENSURES, ASSERT
    [display contents of lib/contracts.h, focus on part starting with #ifndef DEBUG]
  . this is how we will emulate C0 contracts in C
    . no replacement for //@loop_invariant
      . done with judicious uses of ASSERT
    . no \length, \result, \hastag
  . if DEBUG is defined, code will behave like when compiling C0 program with -d flag
  . otherwise, they do nothing
- C has NO NOTION OF CONTRACT
  . we need to hack them in

Translating a C0 program to C -- I
==================================
- [display files simple.c0 (minimal library) and test.c0 (minimal main)]
- [recall how to compile them and run a.out]
      # cc0 -d simple.c0 test.c0
      # ./a.out
- let's first work on the library
  . copy interface into simple.h and implementation into simple.c
- changes to simple.h
  . NONE FOR NOW
- changes to simple.c
  . interface
    . add #include "simple.h"
  . dealing with int_min()
    . replace int_min() with INT_MIN
    . add #include <limits.h>         [library where INT_MIN is defined]
  . dealing with contracts
    . REQUIRES(x > INT_MIN);          [as first line of function]
    . int res = x < 0 ? -x : x;       [assign result to a variable]
    . ENSURES(res >= 0);              [as last line of function]
    . add #include "lib/contracts.h"  [15-122 support for contracts in C]
  [resulting file]
      #include <limits.h>
      #include "lib/contracts.h"
      #include "simple.h"

      int absval(int x) {
        REQUIRES(x > INT_MIN);
        int res = x < 0 ? -x : x;
        ENSURES(res >= 0);
        return res;
      }
  [do not compile yet]

Translating a C0 program to C -- II
===================================
- let's now work on main [copy test.c0 to test.c]
- [first round of changes]
  . allocating the struct
    . in C structs are defined with malloc
    . malloc takes a SIZE as argument, not a type
    . sizeof computes the size of a type
      . replacement line: struct point2d* P = malloc(sizeof(struct point2d));
    . malloc defined in stdlib.h
      . add #include <stdlib.h>
    . malloc returns NULL when running out of memory
      . bad! better abort computation
      . 15-122 micro-library that does that instead replace malloc with xmalloc
      . add #include "lib/xalloc.h"
  . dealing with assert
    . add #include <assert.h>
  . printing
    . C uses printf to conveniently print multiple (simple) values at once
      . formatted printing
    . add #include <stdio.h>
    . change 1st print ... to printf("x coord: %d\n", P->x);
    . change 2nd print ... to printf("y coord: %d\n", P->y);
- how to compile our code?
    # gcc -Wall -Wextra -Wshadow -Werror -std=c99 -pedantic -g -DDEBUG lib/*.c simple.c test.c
  . gcc       = the C compiler
  . -Wall     = display all warning
  . -Wextra   = display extra warnings (!)
  . -Wshadow  = display an additional warning (shadowed declarations)
  . -Werror   = abort compilation when there are warnings
  . -std=c99  = use the C99 standard
  . -pedantic = do so pedantically
  . -g        = keep extra information [used by valgrind -- see below]
  . -DDEBUG   = define the DEBUG macro
  . lib/*.c simple.c test.c = files to compile
- lots of errors!
  . first 3 about 'struct point2d' and 'absval'
    . gcc does not know about these names when compiling test.c
      . but they are defined in simple.c which comes before test.c!
    . big difference in how cc0 and gcc compile programs split over multiple files
      . cc0 combines them into a single file which gets compiled
      . gcc COMPILES EACH FILE SEPARATELY
        . compiled files are combined into a.out at a later stage (linker)
        . each file needs to know about all the names it uses
    . we must provide the header file simple.h to test.c
      . add #include "simple.h" TWICE
  . last is about 'true'
    . bool is not a primitive type in C
    . supplied through library
    . add #include <stdbool.h>
- recompile
  . more errors: redefinition of 'struct point2d'
  . that's because we included "simple.h" twice
    . silly here but happen regularly in larger programs (e.g., assert.h even here)
    . not a problem in C0
  . protect against this by using preprocessor conditional in simple.h
      #ifndef _SIMPLE_H_
      #define _SIMPLE_H_

      int absval(int x)
        /*@requires x >= INT_MIN; @*/
        /*@ensures \result >= 0;  @*/ ;

      struct point2d {
        int x;
        int y;
      };

      #endif
    . first time, loads code because _SIMPLE_H_ is not defined
    . next time, doesn't because it is

Translating a C0 program to C -- III
====================================
- recompiling should go through now
- run
      # ./a.out
  . may or may not work [depends on OS: consistent result on Linux, non-deterministic on Mac]
  . problem is that p->y had not been initialized on line
      P->y = P->y + absval(P->x * 2);
  . C DOES NOT INITIALIZE ALLOCATED MEMORY (C0 always does)
    . source of endless bugs
  . obvious fix here: add P->y = 0;  [don't do it yet]
- more systematic way to find these errors is to use the VALGRIND tool
      # valgrind ./a.out
      ...
      ==9164== Conditional jump or move depends on uninitialized value(s)
      ==9164==    at 0x400856: main (test.c:20)
      ...
  . line 20 of test.c is (near) where the issue is
    . flags assert because that's first place where execution can go one of two ways
    . P->y = P->y + absval(P->x * 2);  will compute some value for P->y
- now add P->y = 0;
  . recompile and run without valgrind
- run with valgrind
      # valgrind ./a.out
      ...
      ==9280== HEAP SUMMARY:
      ==9280==     in use at exit: 8 bytes in 1 blocks
      ==9280==   total heap usage: 2 allocs, 1 frees, 1,032 bytes allocated
      ==9280==
      ==9280== LEAK SUMMARY:
      ==9280==    definitely lost: 8 bytes in 1 blocks
  . what is this about?
- C0 is garbage collected; C is not!
  . we need to FREE allocated memory when we don't need it any more
    . otherwise MEMORY LEAK
    . doesn't matter for this program but big problem for long-running programs
      . web browsers, games, operating systems, ...
    . program get slower and slower over time and eventually crashes
      . restarting fixes the issue
  . C mindframe: IF YOU ALLOCATE IT, YOU FREE IT!
- add free(P);
  . passes valgrind
- once you freed memory, you shouldn't use it anymore
  . example violation: add free before printf
    . run it without valgrind: may work or print garbage
    . run it with valgrind
      ...
      ==9373== Invalid read of size 4
      ==9373==    at 0x4008DC: main (TMP.c:24)
      ==9373==  Address 0x5204040 is 0 bytes inside a block of size 8 free'd
      ...
      ==9373== Invalid read of size 4
      ==9373==    at 0x4008F3: main (TMP.c:25)
      ==9373==  Address 0x5204044 is 4 bytes inside a block of size 8 free'd
      ...
  . other example: free memory twice
    . run without valgrind: may or may not work
    . run with valgrind
      ...
      ==9448== Invalid free() / delete / delete[] / realloc()
      ==9448==  Address 0x5204040 is 0 bytes inside a block of size 8 free'd
      ...
- final code for test.c
      #include <stdio.h>       // input/output -- akin to <conio>
      #include <stdbool.h>     // booleans
      #include <stdlib.h>      // malloc, free -- akin to <util>
      #include <assert.h>      // assert
      #include "lib/xalloc.h"  // safe version of malloc, ...
      #include "simple.h"      // header of simple.c

      int main() {
        struct point2d *P = xmalloc(sizeof(struct point2d));
        P->x = -15;
        P->y = 0;
        P->y = P->y + absval(P->x * 2);
        assert(P->y > P->x && true);
        printf("x coord: %d\n", P->x);
        printf("y coord: %d\n", P->y);
        free(P);
        return 0;
      }

Memory ownership [write code in tree-template.c or display tree.c if pressed for time]
================
- with this, we can convert any C0/C1 program (that doesn't use arrays) to C
- data structure libraries need additional considerations
  . once data structure is not needed, it must be freed
- interface must provide a function to do this
  . example: generic BST
  . version 1
      void dict_free(dict_t D)  // in library interface
      /*@requires D != NULL; @*/ ;
- but what about the data in the BST?
  . sometimes it is convenient that the LIBRARY frees it (e.g., at end of program)
    . data is generic, so client should tell it how to free data
      typedef void entry_free_fn(entry e);         // in client interface

      void dict_free(dict_t D, entry_free_fn *Fr)  // in library interface
      /*@requires D != NULL; @*/ ;
  . other times the CLIENT should free it (e.g., when same data in multiple DS)
  . client knows best
    . we need a way for the client to specify MEMORY OWNERSHIP -- say who should free data
      . call dict_free with actual function if library should free data
      . call it with NULL if client will (and library should not)
  . resulting code
      void tree_free(tree *T, entry_free_fn *Fr) {
        // REQUIRES(is_bst(T));
        if (T == NULL) return;

        if (Fr != NULL) (*Fr)(T->data);  // handle data
        tree_free(T->left, Fr);
        tree_free(T->right, Fr);
        free(T);
      }

      void dict_free(dict *D, entry_free_fn *Fr) {
        //REQUIRES(is_dict(D));
        tree_free(D->root, Fr);
        free(D);
      }

Summary
=======
  Lost                    Gained
  --------------------    --------------------------
  contracts               preprocessor (?)
  safety                  whimsical execution
  garbage collection      explicit memory management
  memory initialization   separate compilation
