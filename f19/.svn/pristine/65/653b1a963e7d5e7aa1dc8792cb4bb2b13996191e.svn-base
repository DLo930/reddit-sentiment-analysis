\section*{Addressing all things%
\TAGS{c-memory}}

We have already seen the ``address-of'' operator, \lstinline'&', used
to find function pointers in C1. In C, we can do the same thing with
variables. This is useful if you want to give a function a reference
to a local variable. \emph{Remember to only free pointers returned
  from \lstinline'malloc'!}

\checkpoint*{\TAGS{c-memory}}

\begin{minipage}{0.55\textwidth}
\smalllistings
\lstinputlisting[aboveskip=0pt, belowskip=0pt]{\code/mult_by_2.c}
\end{minipage}%
\begin{minipage}{0.45\textwidth}
\smalllistings
\lstinputlisting[aboveskip=0pt, belowskip=0pt]{\code/swap_points.c}
\end{minipage}%

What is the output when each of these programs are run?
\begin{solution}

For the program on the left, the output is \\
\lstinline'4'\\
\lstinline'8'

The reason that \lstinline'mult_by_2' works and the other function
doesn't is that C passes a copy of its arguments in to the function it
calls, so if you directly modify your argument you're only modifying
\emph{your copy} of it. In \lstinline'mult_by_2', we're given the
address where a variable is stored and we go there and update it.

For the program on the right, the output is \\
\lstinline'A: (15, 122)'

We pass \lstinline'swap_points' a pointer to our struct stored on the
stack. This is valid because the stack frame for \lstinline'main'
where the struct is stored will always exist during the call to
\lstinline'swap_points'.

\end{solution}

\begin{solution}
  This is a good point to talk about the different sizes and types of
  integers.  Mention that \lstinline'char' < \lstinline'short' <
  \lstinline'int' < \lstinline'long' < \lstinline'long long', then
  the standard sizes they will encounter on 64-bit linux
  (\lstinline'char' = 8, \lstinline'short' = 16, \lstinline'int' = 32,
  \lstinline'long' = 64, \lstinline'long long' = 64). Also talk about
  the \lstinline'int'$N$\lstinline'_t' and
  \lstinline'uint'$N$\lstinline'_t' types that are exactly $N$ bits,
  for $N \in \{8, 16, 32, 64\}$. This is also a good time to remind
  them that signed integer overflow is implementation defined, but the
  same as C0 on 64 bit linux systems. Talk about \lstinline'size_t' if
  you have lots of time.
\end{solution}