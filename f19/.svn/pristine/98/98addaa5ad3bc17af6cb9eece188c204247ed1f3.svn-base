LAST: C
TODAY:
- Data structures in C
- Graphs
  . definitions
  . representations
  . use
NEXT: Search in graphs

Important concepts (5 = highest, 1 = lowest)
============================================
[4] where we are in the course
[5] definition of (undirected) graph, vertex, edge, ...
[5] graph applications
[3] implicit graphs
[5] graph interface
[3] implementations based on what we have studied
[5] adjacency matrix/list representations
[5] cost comparison between AM and AL, dense/sparse graphs
[4] implementing AM
[5] using the graph representation and complexity


Where we are
============
- big picture
  . part I: nuts and bolts, C0, contracts, complexity
  . part II: algorithms and data structures
  . part III (so far): C
                  MT1                   MT2
     Part I -------------> Part II -------------> Part III
- remaining 2 weeks of the course
  . we could see more concepts of C
  . instead, we will practice using C -- more important
- look at more data structures, but this time in C
- graphs
  . very versatile data structure
  . comes up in all kinds of contexts
  . there are entire courses dedicated to them
  . we will give a few basic definitions and explore elementary uses
    . next 4 lectures

What is a graph? [slides]
================
- [show graph example]
- a GRAPH is a collection of dots and lines
  . dots are called VERTICES or NODES and are generally given names
  . lines are called EDGES and are referenced by the name of their ENDPOINTS
    . there can be at most one edge between two nodes
    . if there is an edge between two nodes, they are NEIGHBORS
- a graph G is determined by a set V of vertices and a set E of edges
  . G = (V, E)
- graphs come in many varieties
  . this week, UNDIRECTED GRAPHS: edge (A, B) is the same as (B, A)
  . for simplicity, we don't allow edge (A, A) between a node and itself (self-edge)
- graphs are a convenient abstraction that brings out commonalities between different domains
  . our example graph can describe
    . a road network
    . a social network
    . a game (lightsout)
      . vertex is a board configuration
      . edge is a single move (pushing a button)
      . graph is undirected: pressing a button twice brings us back to where we are
      . no self edge: lights do change when pressing a button
    (and many more things)
- once we view a problem in term of graphs, we can use general graph algorithms to solve it
  . no need to reinvent the wheel: avoid pitfalls, take advantage of clever ideas
  . example: solving lightsout amount to finding a PATH between
    . vertex representing starting board and
    . vertex representing the board where all lights are out
  . an algorithm for finding a path between two vertices yields a solution to lightsout
    . many different possible solutions: many different paths

Implicit graphs
===============
- the graph for 2x2 lightsout fits on a slide
  . so we can solve it in terms of vertices and edges
- but is this the way you implemented it?
  . no: you didn't even know there was a graph in there
  . from a given board (=vertex),
    . you constructed all the boards accessible by one move (=edges)
    . followed one and stored the others in a queue
- although you did implement a graph algorithm without knowing it,
  you never gave a representation to the graph
  . you worked on an IMPLICIT GRAPH
  . this was possible because there is an algorithmic way to find the neighbors of a vertex
- in an implicit graph, there is no data structure corresponding to the graph
  . for 2x2 lightsout, it is easy to have an explicit data structure (see next)
  . what about 6x6 lightsout?
    . each board is a possible 36 bit configuration
      . 2^36 vertices      ~ 16GB
    . there are 36 moves from each boards
      36 * 2^36 / 2 edges  ~ 1TB
    . this is larger than the memory of most computers!

Explicit graphs interface [graph.h]
=========================
- we will only consider graphs that need an EXPLICIT representations
  . no algorithmic way to compute the edges from the nodes
    . e.g., social networks, roads, ...
- what operations do we need?
  . create a graph (we fix the number of nodes beforehand -- no Facebook)
  . check whether two nodes are connected by an edge
  . add an edge if there isn't one
  . ask for how big the graph is
  . get all the neighbors of a node
  . clean up (free graph, free neighbors list)
- resulting interface [on slide and in graph.h]
      typedef unsigned int vertex;
      // typedef ______ *graph_t;

      graph_t graph_new(unsigned int n); // New graph with n vertices
      //@ensures \result != NULL;

      void graph_free(graph_t G);
      //@requires G != NULL;

      unsigned int graph_size(graph_t G);
      //@requires G != NULL;

      bool graph_hasedge(graph_t G, vertex v, vertex w);
      //@requires G != NULL;
      //@requires v < graph_size(G) && w < graph_size(G);

      void graph_addedge(graph_t G, vertex v, vertex w);
      //@requires G != NULL;
      //@requires v < graph_size(G) && w < graph_size(G);
      //@requires v != w;   // no self-loops
      //@requires !graph_hasedge(G, v, w);

      typedef struct vert_list_node vert_list;
      struct vert_list_node {
        vertex vert;
        vert_list *next;
      };

      vert_list* graph_get_neighbors(graph_t G, vertex v);
      //@requires G != NULL;
      //@requires v < graph_size(G);

      void graph_free_neighbors(vert_list* neighbors);
- notes:
  . vertices are consecutive integers starting at 0 (for convenience)
      0   3
      |\  |
      | 4 |
      |/ \|
      1---2
  . neighbors are reported as a linked list
- a realistic graph interface would provide many more operations
- using data structures we have studied,
  . how would we present graphs?
  . what would operations cost?
- how to talk about the cost of graph operations?
  . v = number of vertices
  . e = number of edges
    . minimum number of edge: 0
    . maximum number of edge: v(v-1)/2
    . in general e in O(v^2)
      . many graphs have fewer than O(v^2) edges -- naive to take e ~ v^2
    . number of neighbors in O(min(v,e))
      . at most v-1 neigbors for each vertex
      . but no more than e

                        Linked list    Hash table       ...
                        of edges       of edges
  graph_hasedge          O(e)           O(1) avg+amt
  graph_addedge          O(1)           O(1)
  graph_get_neighbors    O(e)           O(e)
  graph_free_neighbors   O(min(v,e))    O(min(v,e))

- we can do better: we will study two classic data structures for graphs
  . [ask audience to suggest implementations]
  . students generally come up with both adj matrix and adj list representation, in some order
  . [develop them side by side on the board]
- example graph moving forward
      0   3
      |\  |
      | 4 |
      |/ \|
      1---2

Adjacency matrix (AM) representation [implemented in lab]
====================================
- represent graph as a v*v matrix of booleans
  . G[i,j] == true if there is an edge between i and j
    . we will need to have G[j,i] == true since graph is undirected
  . G[i,j] == false otherwise
  . called an ADJACENCY MATRIX
          0   1   2   3   5
        ---------------------
      0 |   | X |   |   | X |
        ---------------------
      1 | X |   | X |   | X |
        ---------------------
      2 |   | X |   | X | X |
        ---------------------
      3 |   |   | X |   |   |
        ---------------------
      4 | X | X | X |   |   |
        ---------------------
- how to implement it in C?
  . v*v bool array -- similar to images
  . array of arrays
  . this will be the topic of your last lab
- how much space do we need?  O(v^2)
- how much time does each operation take?
  . graph_hasedge: O(1)               -- just get G[i,j]
  . graph_addedge: O(1)               -- just set G[i,j]
  . graph_get_neighbors: O(v)         -- construct list from row (visit all v positions)
  . graph_free_neighbors: O(min(v,e)) -- free list (each vertex has up to v-1 neighbors)

Adjacency list (AL) representation
==================================
- for each vertex, keep track of its neighbors in a list
  . called the ADJACENCY LIST of each vertex
        ___
      0 |*|--> 1 --> 4
        |_|
      1 |*|--> 0 --> 2 --> 4
        |_|
      2 |*|--> 1 --> 4 --> 3
        |_|
      3 |*|--> 4
        |_|
      4 |*|--> 0 --> 1 --> 2
        ---
- how much space do we need?
  . O(v) for the array of all the nodes
  - each edge corresponds to exactly 2 list elements (because undirected)
    . O(e) list nodes ALTOGETHER
  - O(v+e)
    . this is conventionally written O(max(v,e))
      . why? exercise
- how much time does each operation take?
  . graph_hasedge: O(min(v,e))
    . go to entry for i (O(1)) and then check if j is in its adj list (O(v) in the very worst case)
    . if e < v, adj list will be at most e elements long
  . graph_addedge: O(1)
    . add j to front of adj list of entry for i
    . because we require edge not to be there as a precondition
  . graph_get_neighbors: O(1)
    . just return ajd list of i
  . graph_free_neighbors: O(...)
    . we will see that later

When to use what?
=================
- a graph with a lot of edges is DENSE
  . "lots of" means about v^2
- a graph that is not dense is SPARSE
  . relatively few edges: O(v), O(v log v) -- less than O(v^2)
  . many graphs are sparse
    . social networks, transportation, communication, ...
- for a dense graph
  . AL and AM take about the same amount of space
  . graph_hasedge is faster with AM
  . graph_get_neighbors is faster in AL but
    . we will typically do something with each neighbor
    . at least O(v) altogether in either case
  . summary                    AM       AL
    . space                    O(v^2)   O(v^2)
    . graph_hasedge:           O(1)     O(v) = O(min(v, v^2))
    . graph_addedge:           O(1)     O(1)
    . graph_get_neighbors:     O(v)     O(1)
    . graph_free_neighbors:    O(v)     O(...)
- for a sparse graph
  . AL take substantially less space
    . e.g., 6x6 lightsout
  . graph_hasedge is slower in AL

Implementing the adjacency list representation [graph-template.c, full code in graph.c]
==============================================
- data structure
  . adjacency lists -- just list of vertices
      typedef vert_list adjlist;
  . graph itself: array of pointers to adjacency lists + array size
      typedef struct graph_header graph;
      struct graph_header {
        unsigned int size;
        adjlist **adj;      // adjlist*[] adj in C0
      };
- [quickly go over DS invariants]
- [implement graph_new]
      graph *graph_new(unsigned int size) {
        graph *G = xmalloc(sizeof(graph));
        G->size = size;
        G->adj = xcalloc(size, sizeof(adjlist*));
        ENSURES(is_graph(G));
        return G;
      }
- [quickly go over graph_hasedge and graph_addedge]
- [quickly go over implementation of graph_get_neighbors]
- how do we implement graph_free_neighbors?
  . first idea: free all nodes in the list
  . but doing so destroys our graph!
  . what to do then? nothing!
      void graph_free_neighbors(vert_list *L) {
        (void)L;
      }
    . (void)L avoid compiler warning/error
  . thus the cost of graph_free_neighbor is O(1)

AM/AL summary
=============
                             AM            AL
   space                    O(v^2)        O(max(v,e))
   graph_hasedge:           O(1)          O(min(v,e))
   graph_addedge:           O(1)          O(1)
   graph_get_neighbors:     O(v)          O(1)
   graph_free_neighbors:    O(min(v,e))   O(1)

Using the graph interface [test.c]
=========================
- write a function that prints all the edges in a graph
  [do so interactively, showing the interface]
      void graph_print(graph_t G) {
        for (vertex v = 0; v < graph_size(G); v++) {
          printf("Vertices connected to %u: ", v);
          vert_list *nbors = graph_get_neighbors(G, v);
          for (vert_list *p = nbors; p != NULL; p = p->next) {
            vertex w = p->vert;   // w is a neighbor of v
            printf(" %u,", w);
          }
          graph_free_neighbors(nbors);
          printf("\n");
        }
      }
- we will see other algorithms that follow this pattern
- what is the complexity of graph_print using AL?
  . outer loop runs v times
  . constant work (printing)
    . total so far: O(v)
  . graph_get_neighbors costs O(1)
    . total so far: O(v) AL
  . inner loop has interesting cost
    . naively, each neighbor list has length O(min(e,v)) so each execution costs O(min(e,v))
    . IN REALITY, each neighbor is reached through an edge from each endpoint
      . body of inner loop will run 2e overall
      . OVERALL cost of inner loop is O(e) -- over all iteration of outer loop
    . total cost so far:
      . AL: O(v + e) = O(max(v,e))
  . graph_free_neighbor costs O(1) with AL (= O(v) overall)
      . total cost still the same
  . therefore: graph_print costs O(max(v,e)) with AL
- what is the complexity of graph_print using AM? [skip if pressed for time]
  . outer loop runs v times
  . constant work (printing)
    . total so far: O(v)
  . graph_get_neighbors costs O(v)
    . total so far: O(v^2) AM
  . inner loop works like AL (it's mediated through neighbor list): O(e) overall
    . total cost so far: O(v^2 + e) = O(v^2) since e is always in O(v^2)
  . graph_free_neighbor costs O(e) OVERALL
  . therefore: graph_print costs O(v^2) with AM
- when to use what representation?
  . in dense graph e ~ v^2, so AL and AM yield the same effective complexity
  . in sparse graph, O(max(v,e)) is much better than O(v^2) so AL is a better option
