\section*{The graph interface}

This lab involves implementing a graph using an adjacency matrix
rather than an array of adjacency lists. Graphs will be specified by
the following C interface (as in \lstinline'graph.h'):

\begin{minipage}{0.38\textwidth}
\begin{lstlisting}[basicstyle=\smallbasicstyle]
typedef unsigned int vertex;
// typedef ______* graph_t;

// New graph with v vertices
graph graph_new(unsigned int v);
//@ensures \result != NULL;

void graph_free(graph G);
//@requires G != NULL;

unsigned int graph_size(graph G);
//@requires G != NULL;

bool graph_hasedge(graph G,
                   vertex v,
                   vertex w);
//@requires G != NULL;
//@requires v < graph_size(G);
//@requires w < graph_size(G);
\end{lstlisting}
\end{minipage}\hfill\rule[-10.5em]{0.01em}{21em}\hfill%
\begin{minipage}{0.57\textwidth}
\begin{lstlisting}[basicstyle=\smallbasicstyle]
void graph_addedge(graph G, vertex v, vertex w);
//@requires G != NULL;
//@requires v != w;
//@requires v < graph_size(G);
//@ensures w < graph_size(G);
//@requires !graph_hasedge(G, v, w);


typedef struct vert_list_node vert_list;
struct vert_list_node {
  vertex vert;
  vert_list *next;
};

vert_list* graph_get_neighbors(graph_t G, vertex v);
//@requires G != NULL;
//@requires v < graph_size(G);

void graph_free_neighbors(vert_list* neighbors);
\end{lstlisting}
\end{minipage}
