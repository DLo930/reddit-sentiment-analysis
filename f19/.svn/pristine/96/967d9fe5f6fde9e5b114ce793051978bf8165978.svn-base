LAST: int's
TODAY: arrays
- array mechanics
- naive memory model
- aliasing
- safety
NEXT: searching arrays, correctness

Important concepts (5 = highest, 1 = lowest)
============================================
[5] C0 memory model for simple types
[5] arrays
[5] allocated memory
[5] array safety (pre-/post-condition of array operations)
[5] aliasing
[4] garbage collection
[5] safety of array code
[5] correctness of array code
[3] unit testing

Review
======
- basic types: int, string, bool, char
- int's serve two purposes
  . represent numbers
  . represent bit patterns (e.g., pixels according to the ARGB model)
- some operations come with SAFETY CONSTRAINTS (= preconditions)
  . x/y, x%y:       //@requires y != 0 && !(x == int_min() && y == -1);
  . x << k, x >> k: //@requires 0 <= k && k < 32;

C0 Memory Model for Simple Types
================================
- value of local variables held in LOCAL MEMORY [do not call it the stack]
  [see OLI module]
- function calls extend local memory with parameters and declarations
  . this extension is called a FRAME (= parameters and declarations of a function call)
    [use mystery function as an example]
- parameters and declarations go away when returning from a function
- recursive function have one frame for each recursive call
- local memory for simple types:
  . int, bool, char require a single memory word (small types)
  . string gives the illusion it's a small type
- local memory can only contain values of small types

Arrays
======
- t[] = type of arrays whose elements are of type t
- coin: int[] A = alloc_array(int, 5)
  . returns an ADDRESS
- extend memory model with allocated memory
  . A (in local memory) contains the address of elements in allocated memory
  . drawn as arrows since exact addresses are unimportant
- coin: elementary array accesses
      --> A[0] = 42;
      --> A[0];             // 42
      --> A[2] = A[0] + 1;
  . C0 arrays are 0-indexed
  . arrays are different from python lists! Only indexable by continuous integers [0..length)
  . allocated memory is initialized to default values (0 for int's)
      --> A[1];  // 0
- safety: try A[5], A[100], A[-1]
  . precondition on A[i]: 0 <= i && i < length of A
  . precondition on alloc_array(t, n): n >= 0

Contracts for Array Operations Summary (fill as concepts are introduced in next example)
======================================
- alloc_array(t, n)
  . //@requires n >= 0;
  . //@ensures \length(\result) == n;
- A[i] (both read and write)
  . //@requires 0 <= i && i < \length(A);
- \length(A) -- contracts-only!
  . //@ensures \result >= 0;

Aliasing
========
- coin:
   . int[] B = A; // update picture
   . B[2];        // whatever was put in there
   . B[2] = 7;
   . A[2];        // 7
   . A == B;      // true
   . int[] C = alloc_array(int, 5);
   . C[2] = 7;
     A == C;      // false
- GARBAGE COLLECTION
   . A = alloc_array(int, 3);  // old A still accessible through B
   . B = alloc_array(int, 7);  // old A will be garbage collected


Coding with Arrays (the copy function)
==================
[draw and update memory picture all along]
- throughout, assume we have the following caller code:
    int[] J = array_copy(I);  // (for some small array I)
- int[] array_copy(int[] A) {
    return A;
  }
  . when doing array_copy(I), address of I is copied in cell for A
  . return A returns the address of A back to caller in cell for J
  no good: returns an alias to B
- int[] array_copy(int[] A) {
    int[] B = alloc_array(int, ???);
    ...
  }
  no good: we don't know what length to set
- int[] array_copy(int[] A, int n) {
    int[] B = alloc_array(int, n);
    ...
  }
  unsafe: we don't know that n >= 0
  incorrect: we don't know whether n is the length of A
- int[] array_copy(int[] A, int n)
  //@requires n == \length(A);
  {
    int[] B = alloc_array(int, n);
    ...
  }
  . \length can only be used in contracts
    . \length(A) has an implicit postcondition: \result >= 0
    . new postcondition for alloc_array(t, n): \length(\result) == n
  . now safe and correct so far; let's carry on
- int[] array_copy(int[] A, int n)
  //@requires n == \length(A);
  {
    int[] B = alloc_array(int, n);
    B = A;
    return B;
  }
  no good: returns an alias to A; B is garbage collected
- int[] array_copy(int[] A, int n)
  //@requires n == \length(A);
  {
    int[] B = alloc_array(int, n);
    for (int i = 0; i < n; i++) {
      B[i] = A[i];
    }
    return B;
  }
  . for loops are a convenient way to iterate through arrays
  . variable i is local to the loop -- cannot be accessed after

Safety of Array Code (function side)
====================
- how do we know that A[i] is safe?
  . to show: 0 <= i && i < \length(A)
  . \length(A) == n by precondition
  . i < n by loop guard
  . 0 <= i by ... operational reasoning: introduce loop invariant
- how do we know that B[i] is safe?
  . \length(B) == n (by alloc_array)
  . then like for A[i]
- int[] array_copy(int[] A, int n)
  //@requires n == \length(A);
  {
    int[] B = alloc_array(int, n);
    for (int i = 0; i < n; i++)
    //@loop_invariant 0 <= i;
    {
      B[i] = A[i];
    }
    return B;
  }
   is it a valid LI?
- INIT: obvious
- PRES:
  . assume 0 <= i
  . to show: 0 <= i'
  . i' = i+1 -- by line 5
  . i+1 >= 0 only if i != INT_MAX -- by math (two's complement)
  . i != INT_MAX because i < n (loop guard)

Safety of Array Code (caller side)
====================
int main() {
  int[] I = alloc_array(int, 3);
  for (int i=0; i<3; i++) I[i] = i+5; // I is [5, 6, 7]

  int[] J = array_copy(I,3);
  int[] K = array_copy(J,3);
  return 0;
}
- is int[] J = array_copy(I,3); safe?
  . Yes
- is int[] K = array_copy(J,3); safe?
  . we can't prove logically that \length(J) is 3
  . add postcondition
- int[] array_copy(int[] A, int n)
  //@requires n == \length(A);
  //@ensures \length(\result) == n;
  {
    int[] B = alloc_array(int, n);
    for (int i = 0; i < n; i++)
    //@loop_invariant 0 <= i;
    {
      B[i] = A[i];
    }
    return B;
  }
  Now it's safe

Correctness of Array Code
=========================
- is it correct?
  . can we prove postcondition assuming precondition?
    . Yes!
  . does B contain the same elements as A in same order?
    . no reason to believe so
    . we could add a post-condition that checks that the two arrays are isomorphic,
      . but it would be as complex as the code for copy
    . we often let go of full correctness in favor of checks for things we often get wrong
    . what do we do? TESTING!

Effects Visible to the Caller
=============================
- int[] array_copy(int[] A, int n)
  //@requires n == \length(A);
  //@ensures \length(\result) == n;
  {
    int[] B = alloc_array(int, n);
    for (int i = 0; i < n; i++)
    //@loop_invariant 0 <= i;
    {
      B[i] = A[i];
    }
    A = alloc_array(int, 42);  // ADDED
    return B;
  }
- upon return A is unchanged for the caller (do simulation)
- addresses are copied to array parameters
  . changes to those parameters do not affect the caller
    e.g.,  A = alloc_array(int, 42);
  . changes through those parameters are visible to the caller
    e.g.,  if (n > 0) A[0] = 17;
