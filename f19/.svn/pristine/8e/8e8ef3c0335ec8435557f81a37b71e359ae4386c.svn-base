\documentclass[12pt]{exam}
\newcommand{\hwnumber}{4}
\newcommand{\hwname}{Editorlab}

%%% begin hw-packages-and-macros.tex
\usepackage{amsmath}
\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{fancybox}
\usepackage{color}
\usepackage[all]{xy}
\usepackage{wrapfig}
\usepackage{fancyvrb}
\usepackage[T1]{fontenc}
\usepackage{listings}

\newcommand{\fillinlistings}{
    \lstset{ %
    language=C, numbers=left, numberstyle=\footnotesize, stepnumber=1,
    numbersep=4pt, showspaces=false, showstringspaces=false, tabsize=4,
    breaklines=true, breakatwhitespace=false,
    basicstyle=\normalsize\fontfamily{fvm}\selectfont, columns=flexible,
    mathescape=true, escapeinside={(*}{*)},
    morekeywords={alloc, allocarray, assert},
    otherkeywords={@requires, @ensures, @loop_invariant, @assert}
    }
}
\newcommand{\normallistings}{
    \lstset{ %
    language=C, numbers=left, numberstyle=\footnotesize, stepnumber=1,
    numbersep=4pt, showspaces=false, showstringspaces=false, tabsize=4,
    breaklines=true, breakatwhitespace=false,
    basicstyle=\footnotesize\fontfamily{fvm}\selectfont, columns=flexible,
    mathescape=true, escapeinside={(*}{*)},
    morekeywords={alloc, allocarray, assert},
    otherkeywords={@requires, @ensures, @loop_invariant, @assert}
    }
}

\newcommand{\semester}{Summer One 2013}

\newcommand{\Cnought}{C$0$}
\newcommand{\modulo}{\ \texttt{\%}\ }
\renewcommand{\lshift}{\ \texttt{<<}\ }
\renewcommand{\rshift}{\ \texttt{>>}\ }
\newcommand{\cgeq}{\ \texttt{>=}\ }
\newtheorem{task}{Task}
\newtheorem{ectask}{Extra Credit Task}
\newtheorem{exercise}{Exercise}

\newcommand{\answerbox}[1]{
\begin{framed}
\hspace{5.65in}
\vspace{#1}
\end{framed}}

\pagestyle{head}

\headrule \header{\textbf{15-122 Homework \hwnumber}}{}{\textbf{Page
\thepage\ of \numpages}}

\pointsinmargin \printanswers

\setlength\answerlinelength{2in} \setlength\answerskip{0.3in}
%%% end hw-packages-and-macros.tex

\begin{document}
\addpoints
\begin{center}
\textbf{\large{15-122 : Principles of Imperative Computation, \semester
\\  \vspace{0.2in} Homework~\hwnumber~Theory [RUBRIC]
}}

 \vspace{0.2in}

 \large{Due: Friday, June 7, 2013, at the {\bf beginning} of lecture}
\end{center}

\vspace{0.5in}

\hbox to \textwidth{Name:\enspace\hrulefill}


\vspace{0.2in}

\hbox to \textwidth{Andrew ID:\enspace\hrulefill}

\vspace{0.2in}

\hbox to \textwidth{Recitation:\enspace\hrulefill}


\vspace{0.5in}

\noindent The written portion of this week's homework will give you some practice working with amortized analysis, memory management, hashtables, and recursion. You can either type up your solutions or write them \textit{neatly} by hand in the spaces provided. You should submit your work in class on the due date just before lecture or recitation begins. Please remember to \textit{staple} your written homework before submission.
\vspace{0.2in}

\begin{center}
\gradetable[v][questions]
\end{center}

\vspace{0.2in}
\begin{center}
  \Large{You {\it must} use this printout, include this cover sheet,

    and staple the whole thing together before turning it in.
  
    Either type up the assignment using
    \href{http://www.cs.cmu.edu/~rjsimmon/15122-s13/hw/15122-theory4.tex}{15122-theory4.tex},

    or print this PDF and write your answers \textit{neatly} by
    hand.}
\end{center}


\newpage
\begin{questions}



 \newpage
 \question{\textbf{Amortized Analysis.}}

 \begin{parts}

 \part[1]There are $n$ students $\{s_1, s_2, ..., s_{n}\}$ who want to get into the Gates-Hillman Center after~6pm. Unfortunately, 15-122 TAs control the building and charge a toll for entrance. The toll policy is the following: for some $k < n$, student $s_i$ is charged $k^2$ tokens when $i \equiv 0 \bmod{k}$, or zero otherwise. If $i$ is a multiple of $k$, then student $s_i$ is charged $k^2$ tokens. Otherwise, the student enters for free. With this policy, how much do the students pay {\it altogether}? 

\begin{solution}
\begin{equation*}
k(n - (n \% k))
\end{equation*}

Full point for $\left\lfloor \frac{n}{k}\right\rfloor k^2$.

Half point for $kn$ or an unsimplified equivalent.

\vspace{1in}
\end{solution}

\part[1]
In Soviet Russia, TAs pay you (the TAs really want students at their
office hours). However, Soviet Russia is also communist, so the
students must split the money evenly between themselves. If the
\mbox{15-122} TAs in Soviet Russia used the same policy for entering
the Gavrilovich-Hashlov Center after 6pm -- student $s_i$ is paid
$k^2$ tokens when $i \equiv 0 \bmod{k}$ -- how much will each student
end up with in the end? (i.e. what is the amortized cost {\it per
  student}?)

\begin{solution}
\begin{equation*}
\frac{k(n - (n \% k))}{n}
\end{equation*}

Full point for their answer to (a) divided by $n$.

Full point for $k$.

Half point for $O(1)$ without an explanation showing they found one of
the solutions above.

\vspace{1in}
\end{solution}

\newpage
Famous Fred Hacker's friend, Ned Stacker, loves stacks. He loves them
so much that he implemented a queue using two stacks in the following
way:
\begin{itemize}
\item A Staqueue has an ``in'' and an ``out'' stack.
\item To enqueue an element, the element is pushed on the ``in'' stack.
\item To dequeue an element, there are two cases:
  \begin{itemize}
  \item If the ``out'' stack is non-empty, then we simply pop from the
    ``out'' stack.
  \item Otherwise, we reverse the ``in'' stack onto the ``out'' stack
    by sequentially popping elements from the ``in'' stack and pushing
    them onto the ``out'' stack. We then pop from the ``out'' stack.
  \end{itemize}
\end{itemize}

A token can pay for the $O(1)$ cost of a stack push or pop; your
answers should be in terms of tokens (not in terms of Big-O
notation).

\part[1]Fred Hacker says that Ned's implementation is too slow. What is the {\it
worst case} cost for dequeuing an element in terms of the number of
elements in the staqueue,~$n$?

\begin{solution}
Full point for $2n$, $2n+1$, or $2n-1$; or for $n$ or $n+1$.

If they say $2n+x$, their amortized cost should be 3 in part (d). If they say $n+x$, their amortized cost should be 2.
\end{solution}

\part[2]

Cheer up Ned by giving and justifying the amortized cost for the queue
operations (enqueue and dequeue). You'll need to show that it is
possible to account for the eventual cost of a dequeue by paying some
of that cost each time you enqueue. (It may help to consider $n$ calls
to dequeue in a staqueue with $n$ elements.)

\begin{solution}
Amortized constant cost. We will always have performed at least as
many enqueue operations as dequeue operations, otherwise the queue
would underflow. If each enqueue deposits an extra token, then there
will always be enough tokens to flip the in-stack, so dequeue doesn't
run out of coins. Hence each operation of the stack only needs a
constant amount of coins.\\

Sleator's proofs:

Proof 1 (aggregate method): As an element flows through the
two-stack data structure, it's PUSHed at most twice and
POPPed at most twice.  This shows that we can assign an
amortized cost of 4 to ENQUEUE and 0 to DEQUEUE.

To get the desired result, note that if an element is not
DEQUEUED it's only PUSHED twice and POPPED once.  So the
cost of 3 is paid for by the cost of 3 per ENQUEUE.  The
last POP is paid for by the DEQUEUE (if it happens).

Proof 2 (banker's method): Maintain a collection of tokens
on stack1.  In fact, keep 2 tokens for each thing in the
stack.

When we ENQUEUE, we have three tokens to work with.  We use
one to push the element onto stack1, and the other two are
put on the element for future use.  When we have to move
stack1 into stack2, we have enough tokens in the stack to
pay for the move (one POP and one PUSH for each element).
Finally, the last pop done by the DEQUEUE is paid for by the
1 we allocated for it. QED.

\textit{First point:}\\
1 point for correct amortized cost (see part (a); they could have a
greater cost, provided it's still constant and they have an
explanation). Their cost of enqueue can be 2 or 3, and their cost of
dequeue can be 1 (or more) or 0, if they used the accounting method.

0 points for Big-O notation.\\

\textit{Second point:}\\
1 point for a proper explanation along one of the lines
above. Students can get this point even if they had their answer in
terms of Big-O. No points if they don't either (1) show a constant
bound on pushes/pops per element, or (2) show the max cost of a
dequeue is bounded by the number of elements on the in stack (previous
enqueues) and paid for by their accrued ``tokens''.
\end{solution}

\end{parts}

\newpage
\question{\textbf{Memory Management.}}

Recall that pointers in C0 are just addresses in the {\it heap}, and
the heap is just one portion of the memory, which we can think of as
an enormous array of {\it bytes}.

\[\includegraphics[trim=0 420 0 00,width=0.80\textwidth]{diagrams/memory1.pdf}\]

For the purposes of this class, we will always think of a {\it byte}
as containing 8 {\it bits}. In the reference \Cnought{} implementation:
\begin{itemize}
\item a \verb"char" is represented using 8 bits (1 byte)
\item an \verb"int" is represented using 32 bits (4 bytes)
\item a pointer is represented using 64 bits (8 bytes)
\end{itemize}
Every time \verb'alloc(ty)' is called, there is code behind the
scenes that reserves a portion of the heap large enough to store the
desired data, initializes that portion of the heap to default values,
and returns the address of the beginning of that portion of the heap.

Consider a stack of characters implemented using a linked list:
\begin{verbatim}
    struct list_stack {
      struct list_node* top;
      struct list_node* bottom;
    };

    struct list_node {
      char data;
      struct list_node* next;
    };
\end{verbatim}

This is the most compact way that C0 could choose to store a
\verb'struct list_node' whose address -- the thing returned from
\verb'alloc(struct list_node)' -- was \verb'0x5040A0':
\[\includegraphics[trim=0 380 0 00,width=0.80\textwidth]{diagrams/memory2.pdf}\]

\newpage
An array in C0 includes some extra information: every time
\verb'alloc_array(ty,n)' is called, the default implementation of C0
works behind the scenes to reserve not just enough space for the
\verb'n' elements of type \verb'ty', but {\it also} 8
extra bytes: 4 bytes to store an integer representing how many
bytes one array element takes up, and another 4 bytes to store
an integer representing the number of elements in the array (this is
how we implement \verb'\length()' and check for array bounds
errors). If \verb'alloc_array(char, 7)' returned \verb'0x5040A0', then
this would be the most compact way C0 could choose to store this
array of seven \verb'char's:
\[\includegraphics[trim=0 380 0 00,width=0.80\textwidth]{diagrams/memory3.pdf}\]
The actual {\it value} of an array is an address (same as for a
pointer), so it takes 64 bits (8 bytes) to store the address where an
array lives.

Remember that we can also implement a stack of characters with an array:
\begin{verbatim}
    struct array_stack {
      int capacity;     /* 0 < capacity */
      int size;         /* 0 <= size && size <= capacity */
      char[] elems;     /* \length(elems) == capacity */
    };
\end{verbatim}


\begin{parts}

\part[1] 

In this problem, we want to fit our {\it entire} heap inside of 1 kB
($1024$ bytes, or $8192$ bits) of continuous memory addresses.

Suppose the lowest address that is part of the heap is
\verb'0x504000'. What is the highest address that \verb'alloc(char)'
could conceivably return? What is the highest address that
\verb'alloc(int*)' could conceivably return? (Give answers in hex.)

\begin{solution}
\begin{verbatim}
alloc(char): 0x5043FF         alloc(int*): 0x5043F8
\end{verbatim}
Half a point each. The answer must be in hex.
\end{solution}

\part[2] What is the maximum number of characters that can be stored
using a \verb"list_stack" if we pack everything as tightly as possible
into a 1 kB heap? Assume you have a dummy node. Show your work.
\begin{solution}
$\frac{1024-9-16}{9} = 111$ characters (9 for dummy node, 16 for header).

2 points for the right answer and work shown.\\
1 point for off-by-one (110 or 112 characters) with work shown.\\
1 point for using bits instead of bytes (91 characters) with work shown.\\
0 points if no work shown.
\end{solution}

\clearpage
\part[2] What is the maximum number of characters that can be stored
using an \verb"array_stack" if we pack everything as tightly as possible
into a 1 kB heap? Assume you use every position in the array
(don't ignore the 0th array element as we did in lecture 9). Show
your work.
\begin{solution}
$1024-(4-4)-(4-4-8) = 1000$ characters (4 for \texttt{count}, 4 for \texttt{elt\_size}; 4 for \texttt{capacity}, 4 for \texttt{size}, 8 for pointer to \texttt{elems}).

2 points for the right answer and work shown.\\
1 point for off-by-one (1008, 1006, 992 characters) with work shown.\\
1 point for using bits instead of bytes (832 characters) with work shown.\\
0 points if no work shown.
\end{solution}

\part[1] Because addresses are given in terms of bytes, the C0 implementation
obviously cannot reserve {\it less} than a byte at a time. Because of
a property called {\it alignment}, C0 will actually reserve {\it more}
than a byte at a time. In particular, the \verb'alloc()' and
\verb'alloc_array()' implementations always reserve multiples of 16
bytes (128 bits), so that even if we just need 1, 4, or 9 bytes, the
allocation will reserve all 16:
\[\includegraphics[trim=0 380 0 00,width=0.80\textwidth]{diagrams/memory4.pdf}\]
In light of this, how many characters
can be stored with a \verb'list_stack'?
\begin{solution}
$\frac{1024-16-16}{16} = 62$ characters.\\

Half point, all or nothing.
\vspace{0.5in}
\end{solution}
How many characters can be stored with an 
\verb'array_stack'?
\begin{solution}
$1024-16-8 = 1000$ characters.\\

Half point, all or nothing.
\vspace{0.5in}
\end{solution}
\end{parts}

\noindent
(While it doesn't matter for this particular
question, alignment is a bit more complicated than we have
described it here, and influences the positioning of fields
like \verb'data' and \verb'next' within a struct. You'll learn 
more about alignment in upper-level courses.)


\newpage
\question{\textbf{Hash Tables.}}

 In Java, strings are hashed using the following function:
 \[
 (s[0]*31^{n-1} + s[1]*31^{n-2} + ... + s[n-2]*31^1 + s[n-1]*31^0)
 \ \texttt{\%}\  m
 \]
 where $s[i]$ is the ASCII code for the $i$th character of string $s$, $n$ is the length of the string, and $m$ is the hash table size.

\begin{parts}
\part[1] If 15122 strings were stored in a hash table of size 4126, what would the load factor of the table be?
\begin{solution}
\begin{equation*}
\frac{15122}{4126} \simeq 3.665
\end{equation*}
Unsimplified is fine, or if they rounded up to 4.
\vspace{1in}
\end{solution}

\part[2] Using the hash function above with a table size of 4126,
give an example of two strings that would ``collide'' and would be
stored in the same chain. Note that strings are case sensitive and string length 
must be $\geq$ 3. Briefly describe your reasoning. (Think of short
strings please!) Do not use null characters (ASCII value 0) as they
can't be part of a C0 string.
\begin{solution}\\\\
1 point for two good strings. 1 point for a good argument.

If they write bad stuff, like "000" meaning "$\backslash 0 \backslash 0 \backslash 0$", then deduct a
point. (C0 strings cannot include the null character.)\\

1 point if they have strings of length 2, but it is correct and they described their reasoning.\\

\verb'hash_collision.c0' in the writeup directory works this problem out.

\vspace{1.5in}
\end{solution}
\end{parts}

\newpage
\question{\textbf{Linked Lists.}}

We want to find the maximum element in a linked list. The recursive
data structure of a linked list, as seen in lecture, is defined as:
\begin{verbatim}
struct list_node {
  elem data;
  struct list_node* next;
};
typedef struct list_node list;
\end{verbatim}

The client provides a helper function \verb"elem_compare". Its
signature is:
\vspace{-3mm}
\begin{verbatim}
int elem_compare(elem a, elem b)
//@ensures -1 <= \result && \result <= 1;
  ;
\end{verbatim}
\vspace{-3mm} and it returns -1 if \verb"a" is less than \verb"b", 0 if
\verb"a" is equal to \verb"b", and 1 if \verb"a" is greater than
\verb"b".

\vspace{3mm}
We've also written a function \verb"leq". Its signature is:
\vspace{-3mm}
\begin{verbatim}
bool leq(list* start, list* end, elem e)
//@requires is_segment(start, end);
  ;
\end{verbatim}
\vspace{-3mm} and it returns true if every node in the list from
\verb"start" (inclusive) to \verb"end" (exclusive) is less than or
equal to \verb"e". We treat the \verb'end' list node as a dummy node,
as we do in lecture, and this dummy node may not even contain valid
data.

\vspace{3mm} You can also use the \verb"is_segment" function described
in lecture. Its signature is:
\vspace{-3mm}
\begin{verbatim}
bool is_segment(list* start, list* end);
\end{verbatim}
\vspace{-3mm} and it returns true if \verb"start" and \verb"end"
delineate a valid list segment. Unlike the \verb'is_segment' from
lecture, this \verb'is_segment' function has no precondition: it will
just return \verb'false' if \verb'start' or \verb'end' are
\verb'NULL'.

\newpage
\begin{parts}
\part[2] 

Finish the \verb"find_max" function. It takes in two pointers, which
should delineate a valid list segment, and returns the maximum element
in the list segment. You will need to provide one more precondition in
order for line \verb'7' to make sense, and the loop invariant you give
on line 11 should be true initially, should be preserved by every
iteration of the loop, and should be strong enough to prove the
postcondition.

\begin{solution}
\begin{verbatim}
          elem find_max(list* start, list* end)
          //@requires is_segment(start, end);

/*  3 */  //@requires ____________start != end________________;
          //@ensures leq(start, end, \result);
          {
            list* curr = start;

/*  7 */    elem max = ___________start->data_________________; OR
            elem max = ___________curr->data__________________;

/*  8 */    while (_______________curr->next != end_________________)
              //@loop_invariant is_segment(start, curr);
              //@loop_invariant is_segment(curr->next, end);

/* 11 */      //@loop_invariant ____leq(start, curr->next, max)_____;
              {

/* 13 */        curr = ___________curr->next__________________;

/* 14 */        if (___elem_compare(max, curr->data) <   0__) { OR
                if (___elem_compare(max, curr->data) <=  0__) { OR
                if (___elem_compare(max, curr->data) == -1__) { OR
                if (___elem_compare(curr->data, max) >  0___) { OR
                if (___elem_compare(curr->data, max) >= 0___) { OR
                if (___elem_compare(curr->data, max) == 1___) {

/* 15 */          _____________max = curr->data_______________;
                }
              }
            return max;
          }

\end{verbatim}
1 point for a working function; 1 point for the correct invariants.

-0.5 points for not using \texttt{elem\_compare()} in line 14; -0.5
for off-by-one errors like
\verb'//@loop_invariant leq(start, curr,max);'  or \verb'while (curr != end)'. 

\end{solution}

\clearpage
\part[2] 
Prove that the first two loop invariants, on lines \verb'9' and
\verb'10', are valid loop invariants. (They are true initially and are
preserved by every iteration of the loop.) 

Remember that, when discussing preservation of the loop invariant, you
want to account for ${\it curr}$ (the value in \verb'curr' before the
loop guard is checked and returns \verb'true') and ${\it curr}'$ (the
value in \verb'curr' just before the loop guard is next checked).
\begin{solution}\\
1 point for proving initial preservation.

1 point for proving that the invariant is preserved by every iteration.\\

\textit{Initial:}

At this point, \texttt{curr = start} from line 6. Then,
\texttt{is\_segment(start, start)} is valid because it is the empty
segment, and \texttt{is\_segment(start->next, end)} is valid due to
the preconditions (lines 2 and 3).\\

\textit{Preservation:}

Since we know the invariant held for \texttt{curr}, we know
\texttt{is\_segment(start, curr')} also holds because \texttt{curr' =
  curr->next}, which is trivially linked to \texttt{curr}. We know
also \texttt{is\_segment(curr'->next, end)},
i.e. \texttt{is\_segment(curr->next->next, end)} because the loop
guard is true (\texttt{curr->next != end}) and
\texttt{is\_segment(start, end)}.
\end{solution}

\part[2] 
Prove that every pointer dereference you make is safe.
\begin{solution}\\
1 point for proving \texttt{start} is safe.\\
1 point for proving \texttt{curr} is safe.\\
-1 point if they mention something that is \textit{not} a pointer dereference.\\\\
Line 7: \texttt{elem max = start->data;}

We know that \texttt{start} is safe to access due to the precondition in \textbf{line 2}. If \texttt{start} is \texttt{NULL}, \texttt{is\_segment()} will return false.

Moreover, the data in \texttt{start} is valid due to the precondition in line 3. This isn't necessary for students to mention, but if they do, put a smiley face. :)\\\\
Line 13: \texttt{curr = curr->next;}

We know that \texttt{curr} is safe to access due to the loop invariants in \textbf{lines 9 and 10} (students can mention either one of them).\\\\
Line 14: \texttt{elem\_compare(max, curr->data)}

Same reasoning as line 13 (for \texttt{curr} access).\\\\
Line 15: \texttt{max = curr->data;}

Same reasoning as line 13.
\end{solution}
\end{parts}

\end{questions}

\end{document}
