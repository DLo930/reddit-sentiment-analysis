Add state diagram for the integer <--> operator mode explanation?


We need to make the autograder for dictionaries in clac/exp more
comprehensive. This implementation passed all tests:
==============
#use <string>
#use <conio>

/* Interface to dictionaries (leave this alone) */

// typedef ______* dict_t;
typedef struct dict_header* dict_t;

// Returns NULL if the input array has the same operator twice
dict_t dict_new(string[] A, int n)
/*@requires \length(A) == n; @*/
/*@requires is_infix_array(A, n); @*/;

// Returns -1 if no definition is found
int dict_lookup(dict_t D, string oper)
/*@requires D != NULL; @*/
/*@ensures \result >= -1; @*/;

/* Implementation to dictionaries should go here (implement this) */

struct dict_header {
  string[] data;
  int size;
};
typedef struct dict_header dict;

/*Check if the elment is an operator returns false otherwise */

bool is_operator(string operator) {
  if (string_equal(operator,"+")) return true;
  if (string_equal(operator,"-")) return true;
  if (string_equal(operator,"*")) return true;
  if (string_equal(operator,"/")) return true;
  if (string_equal(operator,"**")) return true;
  return false;
}

// Checks for the whole array if there is a duplicate element
bool is_in_total(string x, string[] A, int lower, int upper)
/*@requires 0 <= lower
         && lower <= upper
         && upper <= \length(A); @*/
{
  for (int i = lower; i < upper; i++)
    //@loop_invariant lower <= i && i <= upper;
    {
      int length = num_tokens(A[i]);
      string[] subA = parse_tokens(A[i]);
      for (int j = 0; j < length; j++) {
        if (string_equal(x, subA[j])) {
          return true;
        }
      }
    }
  return false;
}

// Finds the exact operator from the array
int finder(string x, string[] A, int lower, int upper)
/*@requires 0 <= lower
         && lower <= upper
         && upper <= \length(A); @*/
{
  for (int i = lower; i < upper; i++)
    //@loop_invariant lower <= i && i <= upper;
    {
      int length = num_tokens(A[i]);
      string[] subA = parse_tokens(A[i]);
      for (int j = 0; j < length; j++) {
        if (string_equal(x, subA[j])) {
          return i;
        }
      }
    }
  return -1;
}

//Checks for dupilcates inside the sub array

bool is_in_itself(string x, string[] A, int lower, int upper)
/*@requires 0 <= lower
         && lower <= upper
         && upper <= \length(A); @*/
{
  int count = 0;
  for (int i = lower; i < upper; i++)
  //@loop_invariant lower <= i && i <= upper;
  {
    if (string_equal(x, A[i])) {
      count ++;
    }
  }
  if (count > 1) return true;
  return false;
}

dict* dict_new(string[] A, int n)
/*@requires \length(A) == n; @*/
/*@requires is_infix_array(A, n); @*/
{
  dict* result = alloc(dict);
  result -> size = n;
  string[] D = alloc_array(string, n);
  for (int i = 0; i < n; i++)
  //@loop_invariant 0 <= i && i <= n;
  {
    string[] data = parse_tokens(A[i]);
    if(num_tokens(A[i]) == 0) {
      D[i] = "-1";
    } else if(num_tokens(A[i]) == 1) {
        if(is_operator(data[0])) {
          if (is_in_total(data[0], A, 0, i)) {
            return NULL;
          } else {
            D[i] = data[0];
          }
        } else {
          D[i] = "-1";
        }
    } else {
        for(int j =0; j < num_tokens(A[i]); j++)
        //@loop_invariant 0 <= j && j <= num_tokens(A[i]);
        {
          if (is_operator(data[j])) {
            if(is_in_itself(data[j], data, 0, num_tokens(A[i]))) {
              return NULL; // check for duplicates in the index of itself
            }
            if(is_in_total(data[j], A, 0, i)) { //check for duplicates
              return NULL;
            }
          }
        }
        D[i] = A[i];
      }
  }
  result -> data = D;
  return result;
}

//Looks up the following operator from the dictionary
int dict_lookup(dict* D, string oper)
//@requires D != NULL;
//@ensures \result >= -1;
{
  string[] A = D -> data;
  int size = D -> size;
  string x = oper;
  int answer = finder(x, A, 0, size);
  return answer;
}
==============
