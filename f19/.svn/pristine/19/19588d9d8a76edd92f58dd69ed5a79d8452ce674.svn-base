\section*{Representing undirected graphs with an adjacency matrix}

In class, we discussed the \emph{adjacency list} implementation of
graphs. In this lab, we'll work through the \emph{adjacency matrix}
implementation.

Recall that if a graph has $n$ vertices, then its adjacency matrix
\lstinline'adj' is an $n \times n$ array of booleans such that
\lstinline'adj[i][j]' is \lstinline'true' if there is an edge from
vertex $i$ to vertex $j$ (for valid $i$ and $j$), \lstinline'false'
otherwise.  Since the graph is undirected, if \lstinline'adj[i][j]' is
\lstinline'true', then \lstinline'adj[j][i]' should also be
\lstinline'true', and if \lstinline'adj[i][j]' is \lstinline'false',
then \lstinline'adj[j][i]' should also be \lstinline'false'.  The
graph should not have any self-loops (i.e., a vertex with an edge to
itself).

\newpage
\begin{part}\TAGS{ds-invariant, graph-representation}
  Complete the data structure invariant function \lstinline'is_graph'
  that returns \lstinline'true' if \lstinline'G' points to a valid
  graph given the definition above, or \lstinline'false' otherwise.

\begin{solution}
\begin{lstlisting}
bool is_graph(graph *G) {
  if (G == NULL) return false;
  if (G->adj == NULL) return false;
  for (unsigned int i = 0; i < G->size; i++) {
    if (G->adj[i] == NULL) return false;
    if (G->adj[i][i]) return false;
  }

  for (unsigned int u = 0; u < G->size; u++) {
    for (unsigned int v = u+1; v < G->size; v++) {
      if (G->adj[u][v] != G->adj[v][u]) return false;
    }
  }
  return true;
}
\end{lstlisting}
\end{solution}
\end{part}

Make sure to capture the fact that the graph is undirected in your data
structure invariant! Compare notes with a neighbor before you move on.

\onePT

\begin{part}\TAGS{graph-representation}
  Complete the \lstinline'graph_new' function that creates a new graph
  using a dynamically-allocated 2D array of boolean for the adjacency
  matrix. Create the 2D array in two steps: first create a new 1D
  array of type \lstinline'bool*', then for each array element, have
  it point to a new 1D array of type \lstinline'bool'.  You can then
  access the array using the 2D notation (e.g.,
  \lstinline'G->adj[0][1] = true'). %

\begin{solution}
\begin{lstlisting}
graph *graph_new(unsigned int size) {
  graph *G = xmalloc(sizeof(graph));
  G->size = size;
  G->adj = xcalloc(size, sizeof(bool*));
  for (unsigned int i = 0; i < size; i++) {
    G->adj[i] = xcalloc(size, sizeof(bool));
  }
  ENSURES(is_graph(G));
  return G;
}
\end{lstlisting}
\end{solution}
\end{part}

\textbf{Note:} Don't ever do this in practice! C has ways of
supporting 2D arrays that don't require an extra array of pointers;
you'll learn about this more efficient way of doing things in later
classes, like 15-213.

\begin{part}\TAGS{graph-representation}
  Complete the functions \lstinline'graph_hasedge' that checks if an
  edge is in the graph and \lstinline'graph_addedge' that adds a new
  edge to the graph.

\begin{solution}
\begin{lstlisting}
bool graph_hasedge(graph G, vertex v, vertex w);
  REQUIRES(is_graph(G) && is_vertex(G, v) && is_vertex(G, w));

  return G->adj[v][w];
}

void graph_addedge(graph *G, vertex v, vertex w) {
  REQUIRES(is_graph(G) && is_vertex(G, v) && is_vertex(G, w));
  REQUIRES(v != w && !graph_hasedge(G, v, w));

  G->adj[v][w] = true;
  G->adj[w][v] = true;

  ENSURES(is_graph(G));
}
\end{lstlisting}
\end{solution}
\end{part}

\begin{part}\TAGS{graph-representation}
  Complete the \lstinline'graph_free' function that frees any
  dynamically-allocated memory for the given graph G.

\begin{solution}
\begin{lstlisting}
void graph_free(graph *G) {
  REQUIRES(is_graph(G));
  for (unsigned int i = 0; i < G->size; i++) {
    free(G->adj[i]);
  }
  free(G->adj);
  free(G);
}
\end{lstlisting}
\end{solution}
\end{part}
The functions \lstinline'graph_get_neighbors' and
\lstinline'graph_free_neighbors' have been pre-implemented for you at
the very bottom of file \lstinline'graph.c', but for an extra
challenge write them yourself.

Once you are done implementing the functions above, you should have a
complete \lstinline'graph.c'. Compile your code and test it with the
given DFS and BFS searches in \lstinline'graph-search.c' and the given
graphs in \lstinline'graph-test.c':
\begin{lstlisting}[language={[coin]C}]
% make graphtest
% ./graphtest
\end{lstlisting}
All tests should pass. (Look at the graphs in \lstinline'graph-test.c'
to see why.) Be sure to use \lstinline'valgrind' also to make sure you
have freed all memory you allocated!

\twoPT
