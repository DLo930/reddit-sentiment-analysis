LAST: abstract data types
TODAY:
- using library interfaces
- stacks
- queues
NEXT: linked lists

Important concepts (5 = highest, 1 = lowest)
============================================
[3] worklists + [1] worklist interface
[5] stacks + stack interface, cost promises
[5] queues + queue interface, cost promises
[2] purity
[5] working with an interface whose implementation is unknown
[5] stack_size
[5] safety
[5] aliasing
[5] cost
[3] queue_copy

Review
======
- pointers and structs
- libraries (interface, implementation, client code)
- today: first useful data structures!

Worklists (TODO lists)
======================
- data structure that can hold elements and give us a way to get them back
  . enter tasks that need to be done, retrieve them one at a time
  . in what order to retrieve them?
    . most recently inserted? STACK
      . Last In First Out (LIFO)
    . longest in the worklist? QUEUE
      . First In First Out (FIFO)
    . most urgent? PRIORITY QUEUE --> we will see this in 1 month
      . FIDO (brings back most interesting :-)
  . pervasively used in CS
- Interface (assume tasks are strings)
    // typedef ________* wl_t;

    bool wl_empty(wl_t W)          // Is W empty?
    //@requires W != NULL;
    ;
    wl_t wl_new()                  // Create a new worklist
    //@ensures \result != NULL;
    //@ensures wl_empty(\result);
    ;
    void wl_add(wl_t W, string x)  // Add a task to W
    //@requires W != NULL;
    //@ensures !wl_empty(W);
    ;
    string wl_retrieve(wl_t W)     // Retrieve a task from W
    //@requires W != NULL;
    //@requires !wl_empty(W);
    ;
- We will learn in 2 weeks how to make elements generic

Stacks
======
- retrieve most recently added item (LIFO -- Last In First Out)
- add and retrieve operations are called PUSH and POP
- stack interface
    // typedef ________* stack_t;

    bool stack_empty(stack_t S)      // O(1)
    //@requires S != NULL;
    ;
    stack_t stack_new()              // O(1)
    //@ensures \result != NULL;
    //@ensures stack_empty(\result);
    ;
    void push(stack_t S, string x)   // O(1)
    //@requires S != NULL;
    //@ensures !stack_empty(S);
    ;
    string pop(stack_t S)            // O(1)
    //@requires S != NULL;
    //@requires !stack_empty(S);
    ;
- new idea: we provide complexity bounds in interface
- what about adding to push the postcondition
    //@ensures string_equal(pop(S), x);
  . when contracts are checked, changes the stack!
  . C0 disallows this: PURITY CHECK
- give example, possibly even in coin ("150", "beats", "122") -- [if time]
  . recall aliasing
- draw it: variable in local memory pointing to a stylized stack in allocated memory

Stack example 1 (peek)
======================
- write a function that returns the top element of the stack without removing it
  . preconditions?  !stack_empty(S)
     string peek(stack_t S)
     //@requires S != NULL && !stack_empty(S);
     {
       string x = pop(S);
       push(S, x);
       return x;
     }
- safety
  . pop(S)?  by preconditions
  . push(S, x)?  by first precondition:
    . pop(S) modifies the allocated memory pointed to by S, but not S itself
    . aliasing!
- cost?  O(1)
- what about writing it as:
     string peek(stack_t S)
     //@requires S != NULL && !stack_empty(S);
     {
       return S->data[S->top];
     }
  . we don't know anything about how stacks are implemented
  . we don't know whether there is a struct, an array, ...

Stack example 2 (size)
======================
- write a function that returns the number of elements in a stack
- v.1
     int stack_size(stack_t S)
     //@requires s != NULL;
     //@ensures \result >= 0;
     {
       int c = 0;
       while (!stack_empty(S)) {
         pop(S);
         c++;
       }
       return c;
     }
  . problem: we have destroyed the stack!
  . idea, save contents somewhere ... in another stack!
- v.2
     int stack_size(stack_t S)
     //@requires s != NULL;
     //@ensures \result >= 0;
     {
       stack_t T = stack_new();    // ADDED (temporary stack)
       int c = 0;
       while (!stack_empty(S)) {
         string x = pop(S);        // MODIFIED
         push(T, x);               // ADDED
         c++;
       }
       //@assert stack_empty(S);   // ADDED

       S = T;                      // ADDED
       return c;
     }
  . problem: T is in reverse order
  . bigger problem: caller's points to the empty stack -- aliasing!
    . EXPECT CONFUSION ON THIS: trace execution if needed
  . idea: put contents of T back into S
- v.3
     int stack_size(stack_t S)
     //@requires s != NULL;
     //@ensures \result >= 0;
     {
       stack_t T = stack_new();
       int c = 0;
       while (!stack_empty(S)) {
         string x = pop(S);
         push(T, x);
         c++;
       }
       //@assert stack_empty(S);

       while (!stack_empty(T)) {   // ADDED
         push(S, pop(T));          // ADDED
       }                           // ADDED
       //@assert stack_empty(T);   // ADDED

      return c;
     }
- note: no interesting loop invariants, really! (that's new!)
- cost? O(n)
  . can we do better?
    . not with this interface
    . smart implementation may achieve O(1)

Queues
======
- retrieve item longest in the worklist (FIFO -- First In First Out)
- add and retrieve operations are called enqueue and dequeue
- queue interface
    // typedef ________* queue_t;

    bool queue_empty(queue_t Q)      // O(1)
    //@requires Q != NULL;
    ;
    queue_t queue_new()              // O(1)
    //@ensures \result != NULL;
    //@ensures queue_empty(\result);
    ;
    void enq(queue_t Q, string x)    // O(1)
    //@requires Q != NULL;
    //@ensures !queue_empty(Q);
    ;
    string deq(queue_t Q)            // O(1)
    //@requires Q != NULL;
    //@requires !queue_empty(Q);
    ;
- give example, possibly even in coin ("150", "beats", "122") -- [if time]
- draw it: variable in local memory pointing to a stylized queue in allocated memory

Queue example (copy)
====================
- write a function that returns a (deep) copy of a queue
- v.1
     queue_t queue_copy(queue_t Q)
     //@requires Q != NULL;
     //@ensures \result != NULL;
     {
       queue_t C = Q;
       return C;
     }
  . problem? returns an alias
    . trace memory on simple example (e.g., < A B C <)
  . idea: create another queue and copy elements of Q into it
- v.2
     queue_t queue_copy(queue_t Q)
     //@requires Q != NULL;
     //@ensures \result != NULL;
     {
        queue_t C = queue_new();   // ADDED
        while (!queue_empty(Q)) {  // ADDED
          string x = deq(Q);       // ADDED
          enq(C, x);               // ADDED
        }                          // ADDED
        return C;
     }
  . problem? destroys Q (empty at the end)
  . idea: put elements back into queue
- v.3
     queue_t queue_copy(queue_t Q)
     //@requires Q != NULL;
     //@ensures \result != NULL;
     {
        queue_t C = queue_new();
        while (!queue_empty(Q)) {
          string x = deq(Q);
          enq(C, x);
          enq(Q, x);               // ADDED
        }
        return C;
     }
  . problem? runs forever (Q never gets smaller)
  . idea? save contents of Q somewhere else ... in another queue!
- v.4
     queue_t queue_copy(queue_t Q)
     //@requires Q != NULL;
     //@ensures \result != NULL;
     {
        queue_t C = queue_new();
        queue_t T = queue_new();   // ADDED (temporary queue)
        while (!queue_empty(Q)) {
          string x = deq(Q);
          enq(C, x);
          enq(T, x);
        }
        //@assert queue_empty(Q);  // ADDED

        Q = T;                     // ADDED
        return C;
     }
   . problem? caller's Q points to the empty queue -- aliasing!
     . EXPECT CONFUSION ON THIS: trace execution if needed
  . idea: save contents of Q into T first
- v.5
     queue_t queue_copy(queue_t Q)
     //@requires Q != NULL;
     //@ensures \result != NULL;
     {
        queue_t C = queue_new();
        queue_t T = queue_new();
        while (!queue_empty(Q)) {
          string x = deq(Q);
          enq(C, x);
          enq(T, x);
        }
        //@assert queue_empty(Q);

        while (!empty_queue(T))     // ADDED
          enq(Q, deq(T));           // ADDED

        return C;
     }
