#use <conio>

/*******************************************************/
/*** Some more exciting priority functions!  ****/
/********************************************************/


// Finds the element with k'th priority in the PQ
elem  k_priority(pq_t H, int k)
//@requires H != NULL && !pq_empty(H);
//@requires 1 <= k && k <= pq_size(H);
{
  elem result = NULL;

  // to keep track of the priority of the current elt
  int counter = 1;

  // array length needed to store heap
  int temp_length = pq_size(H) + 1;

  // allocate an array of the right size for PQ elts
  elem[] temp = alloc_array(elem, temp_length);

  while (counter <= k)
  {
   // pop off the top element
   result = pq_rem(H);

   // store it somewhere
   temp[counter] = result;

   // increment i
   counter++;
  }

  // add everything back to the array
  for (int i = 1; i < temp_length; i++)
  {
     pq_add(H, temp[i]);
  }

  return result;
}

/************************/
/*** Code for testing ***/
/************************/

bool higher_priority(void* x, void* y)
//@requires x != NULL && \hastag(int*, x);
//@requires y != NULL && \hastag(int*, y);
{
   return *(int*) x < *(int*) y;
}


int main() {

  // elements to add
  int* p = alloc(int);
  *p = 5;
  elem x =  (void*)p;

  int *q = alloc(int);
  *q = 6;
  elem y = (void*)q;

  int *r = alloc(int);
  *r = 7;
  elem z = (void*)r;

  // make a new priority queue
  // this is essentially a min-heap
  pq_t test = pq_new(&higher_priority);

  // insert some things into it
  pq_add(test, x);
  pq_add(test, y);
  pq_add(test, z);

  printint(pq_size(test));

  // set priority
  int k = 3;

  elem result = k_priority(test, k);
  // elem result = pq_rem(test);

  print("k-th: ");
  printint(*(int*)result);
  println("\n");

  return 0;
}
