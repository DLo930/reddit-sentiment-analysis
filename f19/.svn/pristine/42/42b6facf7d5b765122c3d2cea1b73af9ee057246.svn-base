\checkpoint*{\TAGS{array, ds-invariant}}

Implement the function \lstinline'arr_new(n)' for this version of
unbounded arrays, where \lstinline'n' is the initial size of the
array.  Give appropriate preconditions and postconditions, and make
sure that your contracts guard against overflow.  Your implementation
of \lstinline'arr_new' should handle the case that \lstinline'n' is
very small.

\begin{solution}
\begin{lstlisting}[numbers=left]
arr arr_new(int n)
//@requires 0 <= n;
//@requires n < int_max() / 3; // Can't handle bigger (unless we try harder)
//@ensures is_arr(\result);
{
  struct arr_header* AH = alloc(struct arr_header);
  AH->size = n;
  AH->limit = n < 2 ? 2 : 3 * n / 2;
  AH->data = alloc_array(string, AH->limit);
  return AH;
}
\end{lstlisting}

Note for controlling overflow: just requiring %
\lstinline'n < (int\_max() / 3)*2' %
doesn't work: \lstinline'int\_max() / 2' %
will pass this test, but if \lstinline'n = int\_max() / 2', %
then \lstinline'n * 3 / 2 = -536870913'. %
Most of the ways of dealing with this get complicated (I'd say
``needlessly complicated'')
\end{solution}
