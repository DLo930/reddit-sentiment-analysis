#use <string>

/* some convenience functions wrapping string_compare */
bool string_leq(string s, string t) {
  return string_compare(s, t) <= 0;
}

bool string_lt(string s, string t) {
  return string_compare(s, t) < 0;
}

bool string_gt(string s, string t) {
  return string_compare(s, t) > 0;
}

/* code from lecture, ported to string arrays */
bool is_in(string x, string[] A, int n)
//@requires 0 <= n && n <= \length(A);
{
  for (int i = 0; i < n; i++)
    //@loop_invariant 0 <= i && i <= n;
    if (string_equal(A[i], x)) return true;
  return false;
}

bool is_sorted(string[] A, int lo, int hi)
//@requires 0 <= lo && lo <= hi && hi <= \length(A);
{
  for (int i = lo; i < hi-1; i++)
    //@loop_invariant i == lo || (lo <= i && i <= hi-1);
    {
      if (!string_leq(A[i], A[i+1])) return false;
    }
  return true;
}


// a linear search
int linsearch(string x, string[] A, int n)
//@requires 0 <= n && n <= \length(A);
//@requires is_sorted(A, 0, n);
/*@ensures (-1 == \result && !is_in(x, A, n))
  || ((0 <= \result && \result < n)
      && string_equal(A[\result], x)); @*/
{
  for (int i = 0; i < n; i++)
    //@loop_invariant 0 <= i && i <= n;
    //@loop_invariant i == 0 || string_lt(A[i-1], x);
    {
      int cmp = string_compare(A[i], x);
      if (cmp == 0) return i;
      else if (cmp > 0)
	//@assert string_gt(A[i], x);
	return -1;
      //@assert string_lt(A[i], x);
      {}
    }
  return -1;
}

// a binary search
int binsearch(string x, string[] A, int n)
//@requires 0 <= n && n <= \length(A);
//@requires is_sorted(A, 0, n);
/*@ensures (-1 == \result && !is_in(x, A, n))
  || ((0 <= \result && \result < n)
      && string_equal(A[\result], x)); @*/
{
  int lo = 0;
  int hi = n;
  while (lo < hi)
    //@loop_invariant 0 <= lo && lo <= hi && hi <= n;
    //@loop_invariant (lo == 0 || string_lt(A[lo-1], x));
    //@loop_invariant (hi == n || string_gt(A[hi], x));
    {
      int mid = lo + (hi-lo)/2; // (lo + hi)/2 could overflow
      int cmp = string_compare(A[mid], x);
      if (cmp == 0)
	//@assert string_equal(A[mid], x);
	return mid;
      else if (cmp > 0)
	//@assert string_gt(A[mid], x);
	hi = mid;
      else
	//@assert string_lt(A[mid], x);
	lo = mid+1;
    }
  return -1;
}
