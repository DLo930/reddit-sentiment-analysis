\documentclass[12pt]{exam}
\newcommand{\hwnumber}{2}
\newcommand{\hwname}{Pixels}
\newcommand{\duedate}{\formatdate{12}{9}{\YEAR} by \progDueTime} % day-month-year

%\newcommand{\hwversion}{remove_red-count_zeroes} % F18 (up to S17)
\newcommand{\hwversion}{opacify-histogram}      % S18 F19
%\newcommand{\hwversion}{remove_green-summarize}  % S19 F17


\input{../../inc/preamble.tex}
\begin{document}
\hwTitle

\noindent
This second programming assignment is designed to get you used to
writing some preconditions and postconditions, deals with bitwise
operations on integers, and introduces the idea of an interface.

\bigskip
\noindent
The code handout for this assignment is on \autolab{} and at
\begin{center}
\whereisthetgz{pixels-handout.tgz}
\end{center}
The file \lstinline'README.txt' in the code handout goes over the contents
of the handout and explains how to hand the assignment in.  There is
a SEVEN (7) PENALTY-FREE HANDIN LIMIT, with the idea that for each task
you can test your code, hand in, and then fix any bugs found by \autolab{}
while working on and testing the next task.
Every additional handin will incur a small (5\%) penalty (even if
using a late day).


\section{Pixels}

To capture the contents of a single pixel, we need to know two things:
how opaque or transparent it is, and what color it is.

One common way to do this is called
\emph{ARGB}.\footnote{\url{http://en.wikipedia.org/wiki/RGBA\_color\_space}}
The transparency is stored as an integer in the range $[0, 256)$,
  where 0 is completely transparent and 255 is completely opaque. This
  is called the \emph{alpha (A)} value. The color is stored as
  three other integers, each also in the range $[0, 256)$, which
    respectively describe the intensity of the \emph{red (R)},
    \emph{green (G)}, and \emph{blue (B)} color in the pixel.
So a pixel is described by four numbers between 0 (inclusive) and 256
(exclusive).

There are many ways to \emph{represent} a pixel in a computer!  One
way is to take the four numbers that make up a pixel and pack them
inside a 32-bit C0 \lstinline'int', breaking that \lstinline'int' up
into 4 components with 8 bits each:
$$
a_0a_1a_2a_3a_4a_5a_6a_7\,
r_0r_1r_2r_3r_4r_5r_6r_7\,
g_0g_1g_2g_3g_4g_5g_6g_7\,
b_0b_1b_2b_3b_4b_5b_6b_7
$$
where:
$$
\begin{array}{ll}
   a_0a_1a_2a_3a_4a_5a_6a_7
 & \text{represents the alpha value (how opaque the pixel is)}
\\ r_0r_1r_2r_3r_4r_5r_6r_7
 & \text{represents the intensity of the red component of the pixel}
\\ g_0g_1g_2g_3g_4g_5g_6g_7
 & \text{represents the intensity of the green component of the pixel}
\\ b_0b_1b_2b_3b_4b_5b_6b_7
 & \text{represents the intensity of the blue component of the pixel}
\end{array}
$$

Each 8-bit component can range between a minimum of \lstinline'0' (binary
\lstinline'00000000' or hex \lstinline'0x00') to a maximum of \lstinline'255'
(binary \lstinline'11111111' or hex \lstinline'0xFF').

\clearpage
In the file \lstinline'pixel.c0', right at the top we announce that we will
be working with a type \lstinline'pixel' that is actually represented as a
single integer by writing a \emph{type definition}:
\begin{quote}
\begin{lstlisting}
typedef int pixel;
\end{lstlisting}
\end{quote}
The rest of the file should contain the implementation of an
\emph{interface} to the newly-defined pixel type (see
Section~\ref{sec:interfaces} for what interfaces are exactly). By
using this interface, we can manipulate pixels as four integers for
red, green, blue, and alpha values instead of worrying exactly how
they are packed into an integer --- or even represented in a totally
different way.

\begin{task}[4]
\TAGS{bit-pattern, correctness}
  Complete the C0 file \lstinline'pixel.c0'. Translate the English
  descriptions into code and the English contracts into C0 contracts.
\end{task}

\bigskip
\noindent
You can load your completed file into \lstinline'coin'. Remember to use the
\lstinline'-d' flag to check contracts.
\begin{quote}
\begin{lstlisting}[language={[coin]C}]
% coin -d pixel.c0
--> make_pixel(255, 238, 127, 45);
\end{lstlisting}
\end{quote}

\section{Testing}

We can generally think about four ways that a program might fail:
\begin{enumerate}
\item Do something \emph{unsafe}: access an array out of
  bounds, divide by zero, call a function with inputs that violate the
  function's preconditions.
\item Violate a loop invariant, an assertion, or a postcondition.
\item Return the wrong answer without violating any contracts.
\item Fail to terminate.
\end{enumerate}
For the fast exponent function we considered in lectures 1 and 2,
failure \#3 was impossible: the postcondition specified that exactly the
right answer was returned. That won't always be the case, and it isn't
the case for \lstinline'pixel.c0'.


\begin{task}[2]
\TAGS{correctness, safety, testing}
  Make a copy of the \lstinline'pixel.c0' file named \lstinline'pixel-bad.c0':
\begin{quote}
\begin{lstlisting}[language={[coin]C}]
% cp pixel.c0 pixel-bad.c0
\end{lstlisting}
\end{quote}
Edit this file so that it contains a broken implementation of
pixels. Keep the contracts the same, and avoid failures \#1 and \#4
--- the program should remain safe and should terminate. However, at
least one function should sometimes violate its postcondition (\#2, a
\emph{contract failure}) and at least one function should sometimes
give the wrong answer without violating a postcondition (\#3, a
\emph{contract exploit}).
\end{task}


\newpage
\begin{task}[7]
\TAGS{testing}
  Write a file \lstinline'pixel-test.c0' that checks for both contract
  failures and contract exploits in an implementation of the pixels interface.
  (See Appendix~\ref{appendix}, or the file \lstinline'puzzle-test.c0'
  distributed with the previous programming homework for an example of how to
  do this for the
%greatest common divisor
\lstinline'common_prefix'
function.)
At minimum, the test should catch
the bugs you made intentionally:
\begin{quote}
\begin{lstlisting}[language={[coin]C}]
% cc0 -d pixel.c0 pixel-test.c0
% ./a.out
   <Should run without errors>

% cc0 -d pixel-bad.c0 pixel-test.c0
% ./a.out
   <An assertion should fail>
\end{lstlisting}
\end{quote}
On \autolab{} we'll run your tests against some of our buggy pixel
implementations too; you'll need to catch bugs in our
buggy pixel implementations for full credit.
\end{task}


\section{Introduction to interfaces}
\label{sec:interfaces}

It's useful to be able to store all the parts of a pixel within a
single integer. But it's not necessary to store the alpha value in the
leftmost (also called \emph{high-order}) 8 bits, nor is it necessary
to store the blue value in the rightmost (or \emph{low-order}) 8 bits.
In fact, it's not even necessary to store pixels as integers at all!
The file \lstinline'pixel.c0' defines the type \lstinline'pixel' and
defines five functions: \lstinline'make_pixel(a,r,g,b)' tells us how
we can create pixels, and \lstinline'get_red(p)',
\lstinline'get_green(p)', \lstinline'get_blue(p)', and
\lstinline'get_alpha(p)' tell us what we can do to pixels. We can say
that these five functions form the \emph{interface} to pixels --- if a
program only uses those five functions to interact with the
\lstinline'pixel' type, then we can easily change the representation
of pixels without any of its code breaking. It's the
\emph{implementation} you wrote that declares a \lstinline'pixel' to
be an 32-bit integer.

A simple way we might change the implementation would be to store the
bits in a different order. A more drastic way that we might change the
implementation is in the file \lstinline'pixel-array.c0'. In that
implementation, pixels are stored not as single integers but as arrays
of four integers:
\begin{quote}
\begin{lstlisting}[language={[coin]C}]
% coin -d pixel.c0
--> pixel p = make_pixel(255,238,127,45);
p is -1147091 (int)
--> get_green(p);
127 (int)

% coin -d pixel-array.c0
--> pixel p = make_pixel(255,238,127,45);
p is 0x603A60 (int[] with 4 elements)
--> get_green(p);
127 (int)
\end{lstlisting}
\end{quote}

While the person implementing the pixel interface obviously knows
whether a pixel is an integer or an array, the person using the pixel
interface should treat the type pixel as an unknown type (or
\emph{abstract type}), and shouldn't rely on details of how the type
is implemented.  In this class, we'll use a \lstinline'typedef' with
underscores to emphasize that an interface defines an abstract type
and use the suffix ``\lstinline'_t''' in the name of this type:
\begin{quote}
\begin{lstlisting}
//typedef ______ pixel_t;
\end{lstlisting}
\end{quote}
The inner notation isn't actual valid C0, though, so you'll always see it as
a comment in a C0 file next to the actual type definition.

An interface allows us to separate the \emph{library code}, which
understands the implementation details, from the \emph{client code}, which
only knows about the interface. Setting up interfaces is an important part of
writing code --- and this is even true when you're the person writing both the
library code and the client code! Interfaces are the basis of how we organize
our code and our large software projects. We'll be talking a lot more about
interfaces later in this class.

As we will see later in more detail, \lstinline'pixel' is a nickname
for the type of pixels as seen by the library implementation (which
knows exactly how pixels are represented) while \lstinline'pixel_t' is
the type of pixels as seen by a client who uses this library (and
needs to know nothing about how pixels are represented).


\section{Pixel manipulation and array aliasing}

In this last part of this assignment, you will write code that uses
this \lstinline'pixel_t' interface:
\begin{quote}
\begin{lstlisting}
/* Interface to pixels */

//typedef ______ pixel_t

pixel_t make_pixel(int alpha, int red, int green, int blue)
int get_alpha(pixel_t p)
int get_red(pixel_t p)
int get_green(pixel_t p)
int get_blue(pixel_t p)
\end{lstlisting}
\end{quote}

The code you write for these tasks should \emph{respect the pixel
  interface} --- that is, your code shouldn't make any assumptions
about what a pixel is other than that a pixel can be created with the
\lstinline'make_pixel' function and passed to the four
\lstinline'get_' functions. If you write code that respects the pixel
interface, then you should be able to test your \lstinline'tasks.c0'
file against both your \lstinline'pixel.c0' and
\lstinline'pixel-array.c0'.
\begin{quote}
\begin{lstlisting}[language={[coin]C}]
% coin -d pixel.c0 tasks.c0
% coin -d pixel-array.c0 tasks.c0
\end{lstlisting}
\end{quote}
The converse is nearly true as well: if your \lstinline'tasks.c0' can compile
and run against both \lstinline'pixel.c0' and \lstinline'pixel-array.c0', you
can be pretty confident that it respects the interface.


The comments in \lstinline'tasks.c0' walk you through the tasks in the
rest of the assignment: component manipulation, quantization, and
returning multiple arguments. You can run and test your code with
\lstinline'coin' as described above, or you can write, compile, and
run a test file like \lstinline'tasks-test.c0', as described in
\lstinline'README.txt'.

\begin{task}[2]
\TAGS{interface}
Complete the function
\ifdefstring{\hwversion}{opacify-histogram}{\lstinline'opacify'}{}%
\ifdefstring{\hwversion}{remove_red-count_zeroes}{\lstinline'remove_red'}{}%
\ifdefstring{\hwversion}{remove_green-summarize}{\lstinline'remove_green'}{}
in file \lstinline'tasks.c0'.
\end{task}

\begin{task}[3]
\TAGS{bit-patterns, interface}
Complete function \lstinline'quantize' in file \lstinline'tasks.c0'.

\emph{Quantization} is a transformation on pixels.  It can be performed on all
the pixels in an image to reduce the total number of colors used in that
image.

Given a pixel and a quantization level $q$ in the range $[0,8)$, we
quantize by taking each color component (red, green and blue) and
clearing the lowest $q$ bits.  For example, suppose we have a pixel
with red intensity $R=\mathtt{0x6B}$ (decimal 107), green intensity
$G=\mathtt{0xBE}$ (decimal 190), and blue intensity $B=\mathtt{0xD7}$
(decimal 215). The color components of this pixel are represented by
these bytes:
\begin{verbatim}
RED       GREEN     BLUE
01101011  10111110  11010111
\end{verbatim}
If the quantization level is 5, then the resulting pixel should have
the following color components (note how the lower 5 bits are all cleared to 0):
\begin{verbatim}
RED       GREEN     BLUE
01100000  10100000  11000000
\end{verbatim}

A pixel processed with a quantization level of 0 should not change.
For each pixel, do not change its alpha component.
\end{task}



\begin{task}[4]
\TAGS{bit-patterns, interface, testing}
Complete the function \lstinline'test_quantize' in file \lstinline'tasks.c0'.
\end{task}

\begin{task}[3]
\TAGS{array, interface, safety}
Complete the function
\ifdefstring{\hwversion}{opacify-histogram}{\lstinline'histogram'}{}%
\ifdefstring{\hwversion}{remove_red-count_zeroes}{\lstinline'count_zeroes'}{}%
\ifdefstring{\hwversion}{remove_green-summarize}{\lstinline'summarize'}{}
in file \lstinline'tasks.c0'.
\end{task}


\clearpage
\appendix
\section{Testing GCD}
\label{appendix}
\enlargethispage{1ex}

Say we have a function that is supposed to find the \emph{greatest
  common divisor} of two positive integers. (We haven't talked about
how to write such a function, but you've seen bits and pieces;
search for ``Euclid's algorithm'' if you'd like to implement this
function.)
\begin{quote}
\begin{lstlisting}
int gcd(int x, int y)
//@requires x > 0 && y > 0;
//@ensures 0 < \result && x % \result == 0 && y % \result == 0;
\end{lstlisting}
\end{quote}
The postcondition isn't the best one we could write --- it checks that the
result is \emph{a} divisor of \lstinline'x' and \lstinline'y', not \emph{the
  greatest} common divisor. A function that ignores its inputs and always
returns 1 satisfies this contract but is nevertheless an incorrect
implementation of \lstinline'gcd'.

We'll write some unit tests in a file \lstinline'gcd-test.c0' that includes a
\lstinline'main' function. To check for contract exploits, we need to make
extra assertions that the output of the function is correct. We could do this
with the \assert{} contract, but it also makes sense to use the built-in
\lstinline'assert()' function that runs whether or not \lstinline'-d' is
selected.
\begin{quote}
\begin{lstlisting}[numbers=left]
#use <util>
#use <conio>

int main() {
  // Run some edge cases (check for contract errors only)
  gcd(1, 1);
  gcd(1, int_max());
  gcd(int_max(), int_max());
  gcd(int_max(), int_max() - 1);

  // Test some regular cases (check for contract errors & exploits)
  assert(gcd(2, 5) == 1);
  assert(gcd(19, 21) == 1);
  assert(gcd(81, 9) == 9);
  assert(gcd(16, 100) == 4);

  println("All tests passed!");
  return 0;
}
\end{lstlisting}
\end{quote}
Now we can use this test file to test both good and bad implementations of GCD:
\begin{quote}
\begin{lstlisting}[language={[coin]C}]
% cc0 -d gcd.c0 gcd-test.c0
% ./a.out
All tests passed!
0
% cc0 -d gcd-bad.c0 gcd-test.c0
% ./a.out
gcd-test.c0:14.3-14.27: assert failed
Abort trap: 6
\end{lstlisting}
\end{quote}



\end{document}
