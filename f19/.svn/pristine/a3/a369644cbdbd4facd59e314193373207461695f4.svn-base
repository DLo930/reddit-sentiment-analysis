/*
 * Clac, stack-based calculator language
 *
 * 15-122 Principles of Imperative Computation
 */

#use <string>
#use <parse>
#use <conio>
#use <args>
#use <util>

/* From the perspective of the clac-main.c0 file, state_t is an
 * abstract type. (typedef ____* state_t) This file contains the
 * implementation of the state_t type. You will add new fields to this
 * struct when you do task 4. */
struct state_header {
  /* Nothing in here initially */
};
typedef struct state_header* state_t;
state_t init_state()
//@ensures \result != NULL;
{
  return alloc(struct state_header);
}
//check if stack has at least two ints
bool size_valid(stack_t S)
{
  if(!stack_empty(S)){
    int a = pop(S);
    if(!stack_empty(S)){
      int b = pop(S);
      push(S, b);
      push(S, a);
      return true;
    }
    else return false;
  }
  else return false;
}

//size of stack
int stack_size(stack_t S)
{
  stack_t S1 = stack_new(); 
  int c = 0;
  while(!stack_empty(S)){
    push(S1, pop(S));
    c++;
  }
  while(!stack_empty(S1))
    push(S, pop(S1));
  return c;
}

//size of queue
int queue_size(queue_t Q1)
{
  queue_t Q = queue_read_only_copy(Q1);
  int c = 0;
  while(!queue_empty(Q)){
    deq(Q);
    c++;
  }
  return c;
}

//check if stack has at least three ints
bool size_valid3(stack_t S)
{
  if(!stack_empty(S)){
    int a = pop(S);
    if(!stack_empty(S)){
      int b = pop(S);
      if(!stack_empty(S)){
        int c = pop(S);
        push(S, c);
        push(S, b);
        push(S, a);
        return true;
      }
    else return false;
    }
  else return false;
  }
else return false;
}

//check if stack has at least three ints
bool qsize_valid(queue_t Q1)
{
  queue_t Q = queue_read_only_copy(Q1);
  if(!queue_empty(Q)){
    string a = deq(Q);
    if(!queue_empty(Q)){
      string b = deq(Q);
      if(!queue_empty(Q)){
        string c = deq(Q);
        return true;
      }
    else return false;
    }
  else return false;
  }
else return false;
}

//the oprations
int plus(int a, int b)
{ if((a>0 && b >0 && (a > int_max()-b)) || (a<0 && b<0 && (a < int_min() - b)))
  {
  error("Overflow caused by inputs");
  }
  return a + b;
}

int minus(int a, int b)
{ if((a>0 && b <0 && (a > int_max()+b)) || (a<0 && b>0 && (a < int_min() + b)))
  {
  error("Over flow caused by inputs");
  }
  return b - a;
}

int multi(int a, int b)
{
  if((a>0 && b>0 && a >int_max()/b) || 
     (a<0 && b<0 && -a >int_max()/(-b)) || 
     (a>0 && b<0 && a >-int_min()/b) || 
     (a<0 && b>0 && b >-int_min()/a)){
    error("Over flow caused by inputs");
  }
  return a * b;
}

int divide(int a, int b)
{
  if( a==0 ||(b == int_min() && a == -1)){
    error("division by zero");
  }
  return  b / a;
}

int modulus(int a, int b)
{
  if( a==0 ||(b == int_min() && a == -1)){
    error("modulo zero");
  }
  return b % a;
}

int lessT(int a, int b)
{
  if(b < a){
    return 1;
  }
  return 0;
}
/* Main clac interpreter. */
/* Return true: clac top-level interpreter will expect more input */
/* Return false: clac top-level interpreter will exit */
bool eval(queue_t Q, stack_t S, state_t ST)
//@requires Q != NULL && S != NULL && ST != NULL;
//@ensures \result == false || queue_empty(Q);
{
  while (!queue_empty(Q)) {
    string tok = deq(Q); /* Is this dequeue safe? */
    // Uncommenting these lines might help with debugging:
     print("Read: "); print(tok); print("\n");
    if (string_equal(tok, "print")) {
      if(!stack_empty(S)){
      int x = pop(S);
      printint(x); print("\n");
      }
      else{
        error("not enough elements on stack");    
    }
    } else if (string_equal(tok, "quit")) {
      return false;
    } else if (string_equal(tok, "+")) {
        if(size_valid(S)){
          int result = plus(pop(S), pop(S));
          push(S, result);
        }else error("not enough elements on stack");    
      }
      else if (string_equal(tok, "-")) {
        if(size_valid(S)){
          int result = minus(pop(S), pop(S));
          push(S,result);
        }else error("not enough elements on stack");    
      }
      else if (string_equal(tok, "*")) {
        if(size_valid(S)){
          int result = multi(pop(S), pop(S));
          push(S,result);
        }else error("not enough elements on stack");    
      }
      else if (string_equal(tok, "/")) {
        if(size_valid(S)){
          int result = divide(pop(S), pop(S));
          push(S,result);
        }else error("not enough elements on stack");    
      }
      else if (string_equal(tok, "%")) {
        if(size_valid(S)){
          int result = modulus(pop(S), pop(S));
          push(S,result);
        }else error("not enough elements on stack");    
      }
      else if (string_equal(tok, "<")){
        if(size_valid(S)){
          int result = lessT(pop(S), pop(S));
          push(S,result);
        }else error("not enough elements on stack"); 
      }
      else if (string_equal(tok, "drop")){
        if(!stack_empty(S)){
          pop(S);
        }else error("not enough elements on stack"); 
      }
      else if (string_equal(tok, "swap")){
        if(size_valid(S)){
          int a = pop(S);
          int b = pop(S);
          push(S, a);
          push(S, b);
        }else error("not enough elements on stack"); 
      }
      else if (string_equal(tok, "rot")){
        if(size_valid3(S)){
          int a = pop(S);
          int b = pop(S);
          int c = pop(S);
          push(S, b);
          push(S, a);
          push(S, c);
        }else error("not enough elements on stack"); 
      }
      else if (string_equal(tok, "if")){
        if(!stack_empty(S)){
          int last = pop(S);
          if (last == 0)
          {
            // check whether Queue has enough inputs
            if(qsize_valid(Q)){
              deq(Q);
              deq(Q);
              deq(Q);
              //tok= deq(Q);
            }
              else error("unexpected end of input");
          }
        }else error("not enough elements on stack"); 
      }
      else if (string_equal(tok, "pick")){
        if(!stack_empty(S)){
          int top = pop(S);
          print("top:");printint(top);print("\n");
          if(top > 0){
             int size = stack_size(S);
             print("size:");printint(size);print("\n");
             if(size >= top){
              stack_t SS = stack_new();
              for(int i=0; i< top; i++){
                int ss = pop(S);
                push(SS, ss);
                print("pushed:");printint(ss);print("\n");
              }
              int new_top = pop(SS);
              push(S, new_top);
              print("new stack:");printint(new_top);print(" \n");
              for(int i =0; i < top - 1; i++){
                int s = pop(SS);
                push(S, s);
                printint(s);print(" \n");
              }
              push(S, new_top);
              printint(new_top);print(" \n");
             }
             else error("not enough elements on stack");
          }
            else error("pick must be positive");
        }
        else error("not enough elements on stack");
      }
      else if (string_equal(tok, "skip")){
        if(!stack_empty(S)){
          int top = pop(S);
          if(top >= 0){
             int size = queue_size(Q);
             if(size >= top){
              for(int i=0; i< top; i++){
                deq(Q);
              } 
             }
             else error("unexpected end of input");
          }
            else error("skip must be nonnegative");
        }
        else error("not enough elements on stack");
      }
    else {
      /* Not defined as an operation name, should be an int */
      int* p = parse_int(tok, 10);
      if (p == NULL) { /* not an int */
        /* call error(msg) which prints msg and aborts */
        error(string_join("undefined token ", tok));
      }
      push(S, *p);
    }
  }

  /* When you return "true", don't pop anything off the stack! When we
   * grade your function, we'll check that the stack contains the
   * integers we expect. */
  return true;
}
