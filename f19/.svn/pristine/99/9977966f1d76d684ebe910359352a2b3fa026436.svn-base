/*
 * Dictionaries, implemented as assocation lists
 *
 * 15-122 Principles of Imperative Computation
 */

#use <string>
#use "queue_of_string.c0"


/******* Implementation of dictionaries as association lists ********/

/* Association lists */
typedef struct assoclist_node assoclist;
struct assoclist_node {
  string name;
  queue_t def;
  assoclist* next;
};

bool iz_assoclist_segment(assoclist* start, assoclist* end) {
  if (start == NULL) return false;
  if (start == end) return true;
  return start->def != NULL && iz_assoclist_segment(start->next, end);
}

bool iz_acyclic_assoclist(assoclist* p) {
  if (p == NULL || p->next == NULL) return true;

  assoclist* tortise = p;
  assoclist* hare = p->next;
  if (p->def == NULL) return false;
  while (tortise != hare)
  //@loop_invariant iz_assoclist_segment(tortise, hare);
  {
    if (hare->next == NULL || hare->next->next == NULL) return true;
    if (hare->def == NULL || hare->next->def == NULL) return false;
    tortise = tortise->next;
    hare = hare->next->next;
  }

  return false;
}

/* NULL is a valid (empty) association list; the only requirement we
 * make on association lists is that they be acyclic. */

/* Dictionaries */
typedef struct dicty_header dict;
struct dicty_header {
  assoclist* assoclist;
};

bool iz_dict(dict* D) {
  return D != NULL && iz_acyclic_assoclist(D->assoclist);
}

/* Allocating a new dictionary */
dict* dict_new()
//@ensures iz_dict(\result);
{
  dict* D = alloc(dict);
  D->assoclist = NULL;
  return D;
}

queue_t dict_lookup(dict* D, string name)
//@requires iz_dict(D);
{
  for (assoclist* p = D->assoclist; p != NULL; p = p->next)
  //@loop_invariant iz_acyclic_assoclist(p);
  {
    if (string_equal(name, p->name)) {
      return p->def;
    }
  }

  return NULL;
}

void dict_insert(dict* D, string name, queue_t def)
//@requires iz_dict(D);
//@requires def != NULL;
//@ensures iz_dict(D);
//@ensures dict_lookup(D, name) != NULL;
{
  for (assoclist* p = D->assoclist; p != NULL; p = p->next)
  //@loop_invariant iz_acyclic_assoclist(p);
  {
    if (string_equal(name, p->name)) {
      p->def = def;
      return;
    }
  }

  assoclist* p = alloc(struct assoclist_node);
  p->name = name;
  p->def = def;
  p->next = D->assoclist;
  D->assoclist = p;
  return;
}

// Client type
typedef dict* dict_t;


/********************* Interface to dictionaries *********************/

// typedef ______* dict_t;

dict_t dict_new()
  /*@ensures \result != NULL; @*/;

// Returns NULL if no definition is found
queue_t dict_lookup(dict_t D, string name)
  /*@requires D != NULL; @*/;

void dict_insert(dict_t D, string name, queue_t def)
  /*@requires D != NULL; @*/
  /*@requires def != NULL; @*/;
