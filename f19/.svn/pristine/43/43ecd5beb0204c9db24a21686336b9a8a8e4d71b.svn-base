#use <args>
#use <string>
#use <parse>
#use <conio>

int[] arr(int i) { return alloc_array(int, i); }

int main() {
  args_t args = args_parse();
  if (args->argc != 1) error("Wrong number of args");
  string arg = args->argv[0];

  if (string_equal(arg, "get-contracts1")) {       get_bit(arr(0), 0);
  } else if (string_equal(arg, "get-contracts2")) { get_bit(arr(0), 1);
  } else if (string_equal(arg, "get-contracts3")) { get_bit(arr(0), -1);
  } else if (string_equal(arg, "get-contracts4")) { get_bit(arr(15), 480);
  } else if (string_equal(arg, "get-contracts5")) { get_bit(arr(15), -1);

  } else if (string_equal(arg, "set-contracts1")) { set_bit(arr(0), 0);
  } else if (string_equal(arg, "set-contracts2")) { set_bit(arr(0), 1);
  } else if (string_equal(arg, "set-contracts3")) { set_bit(arr(0), -1);
  } else if (string_equal(arg, "set-contracts4")) { set_bit(arr(15), 480);
  } else if (string_equal(arg, "set-contracts5")) { set_bit(arr(15), -1);

  } else if (string_equal(arg, "range")) {
    for (int n = 0; n < 15; n++) {
      int[] A = alloc_array(int, n);
      for (int i = 0; i < n*32; i++) {
        get_bit(A, i);
        set_bit(A, i);
      }
    }

  } else if (string_equal(arg, "correctness")) {
    // Functional correctness test

    int[] A = parse_ints("0 -1 1000000000 -2000000000 15122", 10);
    bool[] Ref = alloc_array(bool, 160);
    bool some_are_off = false;

    // Figure out how the student stored these as bits
    for (int i = 0; i < 160; i++) {
      Ref[i] = get_bit(A, i);
      if (!Ref[i]) some_are_off = true;
    }

    // Prevents an unlikely exploit (get_bit always returns true)
    if (!some_are_off) return 1;

    // Slowly turn bits to 1 and track the changes
    for (int i = 77; i < 159; i++) {
      // Check that the reference array remains accurate
      for (int j = 0; j < 160; i++) 
        if (Ref[j] != get_bit(A, j)) return 1;

      Ref[i] = true;
      set_bit(A, i);
    }

  } else {
    error("Bad arg");

  }

  return 0;
}