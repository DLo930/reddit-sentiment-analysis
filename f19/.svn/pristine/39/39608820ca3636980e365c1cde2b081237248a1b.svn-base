#use <conio>
#use <string>

string stack_peek(stack_t S)
//@requires S != NULL;
//@requires !stack_empty(S);
// Time O(1)
{
  // Write me!
  return "";
}

int stack_size(stack_t S)
//@requires S != NULL;
{
  int c = 0;
  while (!stack_empty(S)) {
    pop(S);
    c++;
  }
  return c;
}


// Using the queue interface

queue_t queue_copy(queue_t Q)
//@requires Q != NULL;
//@ensures \result != NULL;
{
  // Write me!
  return Q;
}


// Tests

int main() {
  stack_t S = stack_new();
  push(S, "a");
  push(S, "b");
  // peek gives the right answer:
  assert(string_equal(stack_peek(S), "b"));
  // peek is nondestructive:
  assert(string_equal(stack_peek(S), "b"));
  assert(stack_size(S) == 2);

  queue_t Q = queue_new();
  enq(Q, "c");
  enq(Q, "d");
  queue_t Q2 = queue_copy(Q);
  assert(string_equal(deq(Q),deq(Q2)));
  assert(string_equal(deq(Q),deq(Q2)));
  assert(queue_empty(Q) && queue_empty(Q2));

  print("All tests passed\n");
  return 0;
}
