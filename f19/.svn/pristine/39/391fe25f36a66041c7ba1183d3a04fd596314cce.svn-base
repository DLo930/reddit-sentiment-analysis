\clearpage
\bgroup
\newcommand{\X}{y}%{s}{x}
\newcommand{\I}{n}%{j}{k}{i}

\newcommand{\FST}{fst}%{first\_part}{part1}
\newcommand{\SND}{snd}%{second\_part}{part2}

\Question{Pass by Reference Using C}

At various points in our C0 programming experience, we had to use
somewhat awkward workarounds to deal with functions that need to
return more than one value. Stack-allocated data structures and the
address-of operator (\lstinline"&") in C give us a new way of dealing
with this issue.

Sometimes, a function needs to be able to both 1) signal whether it
can return a result, and 2) return that result if it is able
to. Consider the following function \lstinline'parse_string' that
attempts to parse a string into an integer:

\smallskip
\begin{lstlisting}
bool parse(char *[*\X*], int *[*\I*]);  // Returns true iff parse succeeds

void parse_string(char *[*\X*]) {
  REQUIRES([*\X*] != NULL);
  int *[*\I*] = xmalloc(sizeof(int));
  if (parse([*\X*], [*\I*]))
    printf("Success: %d.\n", *[*\I*]);
  else
    printf("Failure.\n");
  free([*\I*]);
  return;
}
\end{lstlisting}

The function \lstinline'parse_string' relies on
\lstinline'parse', a function which both sets \lstinline'*'\texttt{\I} to an
integer equivalent to the integer pattern in \lstinline'*'\texttt{\X} (if
possible) and also returns a boolean value of \lstinline'true' if the
parse succeeds, or \lstinline'false' otherwise.

\begin{parts}

\part[2]\TAGS{c-memory}
Using the address-of operator, rewrite the body of the
\lstinline'parse_string' function so that it does not heap-allocate,
free, or leak any memory on the heap. You may assume \lstinline"parse"
has been implemented (its prototype is given above).

\begin{framed}
\begin{lstlisting}[belowskip=0pt]
void parse_string(char *[*\X*]) {
  REQUIRES([*\X*] != NULL);
\end{lstlisting}
\ifprintanswers
\begin{lstlisting}[basicstyle=\basicstyle\color{\answerColor}]
   int [*\I*];
   if (parse(s, &[*\I*])) {
     printf("Success: %d.\n", [*\I*]);
   else
     printf("Failure.\n");
\end{lstlisting}
\else\vspace{2in}\fi
\begin{lstlisting}[aboveskip=0pt]
  return;
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (a)
TAGS: c-memory

Gradescope rubric:
+0.5pt stack allocate an int (e.g., int i)
+0.75pt call parse using & (e.g., if (parse(s, &i)))
+0.75pt uses local in success case (e.g., printf("Success: %d.\n", i))
-0.75pt there should not be uses of free()

Commentary:
- variable names change from semester to semester: update the rubric accordingly

   int i;                          1/2 point stack allocate an int
   if (parse(s, &i)) {             3/4 point call parse with &
     printf("Success: %d.\n", i);  3/4 point call success with i
   else
     printf("Failure.\n");
   return;

   3/4 point penalty if there is a free()
ENDRUBRIC


\newpage
\part[2]\TAGS{c-memory, struct}
In both C and C0, multiple values can be `returned' by bundling
them in a struct:

\begin{lstlisting}
struct bundle {
  int [*\FST*];
  int [*\SND*];
};

struct bundle *split_int(int p) {
  struct bundle *A = xmalloc(sizeof(struct bundle));
  A->[*\FST*] = p>=0 ? 1 : -1;  // first value to be returned
  A->[*\SND*] = abs(p);         // second value to be returned
  return A;            // return both values together as a struct
}

int main() {
  ...
  struct bundle *B = split_int(-42);
  int sign  = B->[*\FST*];
  int value = B->[*\SND*];
  free(B);
  ...
}
\end{lstlisting}

Complete the declaration of the function \lstinline'split_int', as
well as the snippet of \lstinline'main', to avoid heap-allocating,
freeing, or leaking any memory on the heap. The rest of the code
(\lstinline"...") should continue to behave exactly as it did before.

\begin{framed}
\begin{lstlisting}[aboveskip=2.5ex, belowskip=0pt]
void split_int([*\uanswer{22em}{struct bundle *A}*], int p) {
  A->[*\FST*] = p>=0 ? 1 : -1;
  A->[*\SND*] = abs(p);
  return;
}

int main() {
  ...
  struct bundle B;

  split_int([*\uanswer{25.5em}{\&B}*], -42);

  int sign  = [*\uanswer{28em}{B.\FST}*];

  int value = [*\uanswer{28em}{B.\SND}*];
  ...
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (b)
TAGS: c-memory, struct

Gradescope rubric:
+0.5pt 1st blank: struct bundle *A
+0.5pt 2nd blank: &B
+1pt last two blanks: B.sign and B.value
-0.5pt (&B)->FST and (&B)->SND work but are atrocious

Commentary:
- fields vary FST and SND from semester to semester: UPDATE RUBIC ACCORDINGLY

   void split_int(___struct bundle *A___, int p) { 1/4 point
   split_int(___&B___, p)                          1/4 point
   int sign  = ___B.FST___;                  <---- 1/2 point (Must be . not ->)
   int value = ___B.SND___                   <---/

   (&B)->FST and (&B)->SND work but are atrocious, take off the half point
   &B->FST and &B->SND do NOT work because of C precedence
ENDRUBRIC

\end{parts}
\egroup