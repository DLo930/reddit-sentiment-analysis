/*
 * Clac, stack-based calculator language
 *
 * 15-122 Principles of Imperative Computation
 */

#use <string>
#use <parse>
#use <conio>
#use <args>
#use <util>

/* From the perspective of the clac-main.c0 file, state_t is an
 * abstract type. (typedef ____* state_t) This file contains the
 * implementation of the state_t type. You will add new fields to this
 * struct when you do task 4. */
struct state_header {
  /* Nothing in here initially */
  qstack_t r_stack;
  dict_t defs;
};
typedef struct state_header* state_t;
state_t init_state()
//@ensures \result != NULL;
{
  state_t st =alloc(struct state_header);
  st->r_stack=qstack_new();
  st->defs=dict_new();
  return st;
}

qstack_t get_stack(state_t st)
//@requires st != NULL;
//@ensures \result != NULL;
{
  return st->r_stack;
}

dict_t get_defs(state_t st)
//@requires st != NULL;
//@ensures \result != NULL;
{
  return st->defs;
}


/* Main clac interpreter. */
/* Return true: clac top-level interpreter will expect more input */
/* Return false: clac top-level interpreter will exit */
bool eval(queue_t Q, stack_t S, state_t ST)
//@requires Q != NULL && S != NULL && ST != NULL;
//@ensures \result == false || queue_empty(Q);
{
  qstack_t r_stack= get_stack(ST);
  dict_t defs= get_defs(ST);
  queue_t current_q=Q;
  while (!queue_empty(current_q))
  {
    
    string tok = deq(current_q); 
    /* Is this dequeue safe? */
    // Uncommenting these lines might help with debugging:
    // print("Read: "); print(tok); print("\n");
    int* p = parse_int(tok, 10);
    if (p != NULL) { /* not an int */
      push(S, *p);
    } 
    else if (string_equal(tok, "quit")) {
      return false;
    } 
    else if (string_equal(tok, ":")) {
      queue_t newdef=queue_new();
      string name="";
      if(!queue_empty(current_q)) name=deq(current_q);
      else error("definition not completed");
      if(string_equal(name, ";")) error("no name argument");
      while(!string_equal(tok, ";"))
      {
        if(queue_empty(current_q)) error("definition not completed");
        tok=deq(current_q);
        if(!string_equal(tok, ";")) enq(newdef, tok);
      }
      dict_insert(defs, name, newdef);
      assert(dict_lookup(defs, name)!=NULL);
    }
    else if (string_equal(tok, "print")) {
      if(stack_empty(S)) error("not enough arguments");
      int x = pop(S); /* This line is unsafe and must be fixed! */
      printint(x); print("\n");
    }
    else if (string_equal(tok, "+")) {
      if(stack_empty(S)) error("not enough arguments");
      int x = pop(S);
      int y = 0;
      if(!stack_empty(S)) y=pop(S);
      else error("not enough arguments");
      push(S, x+y);
    }
    else if (string_equal(tok, "-")) {
      if(stack_empty(S)) error("not enough arguments");
      int x = pop(S);
      int y = 0;
      if(!stack_empty(S)) y=pop(S);
      else error("not enough arguments");
      push(S, y-x);
    }
    else if (string_equal(tok, "*")) {
      if(stack_empty(S)) error("not enough arguments");
      int x = pop(S);
      int y = 0;
      if(!stack_empty(S)) y=pop(S);
      else error("not enough arguments");
      push(S, x*y);
    }
    else if (string_equal(tok, "/")) {
      if(stack_empty(S)) error("not enough arguments");
      int y = pop(S);
      int x = 0;
      if(!stack_empty(S)) x=pop(S);
      else error("not enough arguments");
      if(y==0) error("illegal operation");
      if(x==int_min() && y==-1) error("illegal operation");
      push(S, x/y);
    }
    else if (string_equal(tok, "%")) {
      if(stack_empty(S)) error("not enough arguments");
      int y = pop(S);
      int x = 0;
      if(!stack_empty(S)) x=pop(S);
      else error("not enough arguments");
      if(y==0) error("illegal operation");
      if(x==int_min() && y==-1) error("illegal operation");
      push(S, x%y);
    }
    else if (string_equal(tok, "<")) {
      if(stack_empty(S)) error("not enough arguments");
      int y = pop(S);
      int x = 0;
      if(!stack_empty(S)) x=pop(S);
      else error("not enough arguments");
      if(x<y) push(S,1);
      else push(S,0);
    }
    else if (string_equal(tok, "drop")) {
      if(stack_empty(S)) error("not enough arguments");
      pop(S);
    }
    else if (string_equal(tok, "swap")) {
      if(stack_empty(S)) error("not enough arguments");
      int x = pop(S);
      int y = 0;
      int z = 0;
      if(!stack_empty(S)) y=pop(S);
      else error("not enough arguments");
      push(S,x);
      push(S,y);
    }
    else if (string_equal(tok, "rot")) {
      if(stack_empty(S)) error("not enough arguments");
      int z = pop(S);
      int y = 0;
      int x = 0;
      if(!stack_empty(S)){
        y=pop(S);
        if(!stack_empty(S)) x=pop(S);
        else error("not enough arguments");
      }
      else error("not enough arguments");
      push(S,y);
      push(S,z);
      push(S,x);
    }
    else if (string_equal(tok, "if")) {
      if(stack_empty(S)) error("not enough arguments");
      int x=pop(S);
      if(x==0){
        for(int i=0; i<3; i++){
          if(queue_empty(current_q)) error("nothing to skip");
          deq(current_q);
        }
      }
    }
    else if (string_equal(tok, "pick")) {
      if(stack_empty(S)) error("not enough arguments");
      int x=pop(S);
      if(x<=0) error("input must be positive");
      stack_t T=stack_new();
      for(int i=0; i<x-1; i++){
        if(stack_empty(S)) error("not enough arguments");
        push(T,pop(S));
      }
      if(stack_empty(S)) error("not enough arguments");
      int n=pop(S);
      push(S, n);
      while(!stack_empty(T)){
        push(S,pop(T));
      }
      push(S, n);
    }
    else if (string_equal(tok, "skip")) {
      if(stack_empty(S)) error("not enough arguments");
      int x=pop(S);
      if(x<0) error("input must be nonnegative");
      for(int i=0; i<x; i++){
        if(queue_empty(current_q)) error("nothing to skip");
        deq(current_q);
      }
    }
    else {
      queue_t def=dict_lookup(defs, tok);
      if(def==NULL) error(string_join("undefined token ", tok));
      if(!queue_empty(current_q)) qpush(r_stack, current_q);
      current_q=queue_read_only_copy(def);
    }
    if(!qstack_empty(r_stack)&& queue_empty(current_q)) current_q=qpop(r_stack);
  }

  /* When you return "true", don't pop anything off the stack! When we
   * grade your function, we'll check that the stack contains the
   * integers we expect. */
  return true;
}
