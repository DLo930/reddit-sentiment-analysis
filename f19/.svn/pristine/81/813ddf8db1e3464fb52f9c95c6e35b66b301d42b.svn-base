/**
 *****************************************************************************
 *                              HOMEWORK  15-122
 *****************************************************************************
 *      This is a back-end for a one character text editor.
 *
 *      Run William Lovas' front-end "locas-E0.c0" for a full demo.
 *
 * @author:
 *****************************************************************************/

#use "gap-buffer.c0"
#use "text-buffer.c0"

/* INTERFACE */

bool is_tbuf(tbuf B);     /* Checks if a text buffer satisfies invariants */

bool tbuf_empty(tbuf B);  /* Checks if the text buffer is empty  */
bool tbuf_empty(tbuf B)   /* Checks if the text buffer is empty  */
//@requires is_tbuf(B);
{
  return B->start->next == B->end->prev &&
         gapbuf_empty(B->point->data);
}

bool is_tbuf(tbuf B)      /* Checks if the text buffer is valid  */
{
  if (!is_linked(B)) return false;
  if (B->start->next == B->end->prev)
  {
    if (!is_gapbuf(B->point->data)) return false;
    if (gapbuf_max_size(B->point->data) != 16) return false;
    if (gapbuf_empty(B->point->data)) return true;
  }
  dll p = B->start->next;
  while (p != B->point)
  //@loop_invariant p != NULL;
  {
    if (!is_gapbuf(p->data)) return false;
    if (gapbuf_empty(p->data)) return false;
    if (gapbuf_max_size(p->data) != 16) return false;
    if (!gapbuf_at_right(p->data)) return false;
    p = p->next;
  }
  //@assert (p == B->point);
  if (!is_gapbuf(p->data)) return false;
  if (gapbuf_empty(p->data)) return false;
  if (gapbuf_max_size(p->data) != 16) return false;
  p = p->next;
  while (p != B->end)
  //@loop_invariant p != NULL;
  {
    if (!is_gapbuf(p->data)) return false;
    if (gapbuf_empty(p->data)) return false;
    if (gapbuf_max_size(p->data) != 16) return false;
    if (!gapbuf_at_left(p->data)) return false;
    p = p->next;
  }
  return true;
}

tbuf tbuf_new();          /* Creates an empty text buffer, with  */
                          /*   with gap buffers of size 16       */
tbuf tbuf_new()           /* Creates an empty text buffer, with  */
                          /*   with gap buffers of size 16       */
//@ensures is_tbuf(\result);
{
  tbuf B = alloc(struct text_buffer);
  B->start = alloc(struct list_node);
  B->point = alloc(struct list_node);
  B->end = alloc(struct list_node);
  B->point->data = gapbuf_new(16);
  B->start->next = B->point;
  B->point->prev = B->start;
  B->point->next = B->end;
  B->end->prev = B->point;
  return B;
}

//Move the cursor forward by n characters. If n is negative, then move the cursor backwards.
void gapbuf_forwardn(gapbuf G, int n)
//@requires 0 <= gapbuf_left_pos(G) + n && gapbuf_right_pos(G) + n <= gapbuf_max_size(G);
//@ensures \old(gapbuf_right_pos(G)) + n == gapbuf_right_pos(G);
//@ensures \old(gapbuf_left_pos(G)) + n == gapbuf_left_pos(G);
{
  if (n >= 0) {
    for (int i = 0; i < n; i++) 
    //@loop_invariant 0 <= i && i <= n;
    // loop_invariant \old(gapbuf_right_pos(G)) + i == gapbuf_right_pos(G);
    // loop_invariant \old(gapbuf_left_pos(G)) + i == gapbuf_left_pos(G);
      gapbuf_forward(G);
  } else {
    for (int i = 0; i > n; i--)
    //@loop_invariant n <= i && i <= 0;
    // loop_invariant \old(gapbuf_right_pos(G)) + i == gapbuf_right_pos(G);
    // loop_invariant \old(gapbuf_left_pos(G)) + i == gapbuf_left_pos(G);
      gapbuf_backward(G);
  }
  return;
}

void gapbuf_deleten(gapbuf G, int n)
//@requires 0 <= n && n <= gapbuf_left_pos(G);
//@ensures \old(gapbuf_right_pos(G)) == gapbuf_right_pos(G);
//@ensures \old(gapbuf_left_pos(G)) == gapbuf_left_pos(G) + n;
{
  for (int i = 0; i < n; i++)
    //@loop_invariant 0 <= i && i <= n;
    // loop_invariant \old(gapbuf_right_pos(G)) == gapbuf_right_pos(G);
    // loop_invariant \old(gapbuf_left_pos(G)) == gapbuf_left_pos(G) + i;
    gapbuf_delete(G);
  return;
}

void split_point(tbuf B); /* Splits a full point into two nodes, */
                          /*   so that the new point is not full */
void split_point(tbuf B)  /* Splits a full point into two nodes, */
                          /*   so that the new point is not full */
//@requires is_tbuf(B) && gapbuf_full(B->point->data);
//@ensures is_tbuf(B);
{
  gapbuf origbuf = B->point->data;
  gapbuf newbuf = gapbuf_new(gapbuf_max_size(origbuf));
  int ppos = gapbuf_left_pos(origbuf);
  //@assert gapbuf_max_size(origbuf) % 2 == 0;
  int half = gapbuf_max_size(origbuf) / 2;
  int offset = ppos < half ? 0 : half;
  for (int i = 0; i < half ; i++)
  {
    gapbuf_insert(newbuf,gapbuf_char_at(origbuf,i+offset));
  }
  int rpos = half + offset - ppos;
  //@assert 0 <= rpos && rpos <= half;

  gapbuf_forwardn(newbuf,-rpos);
  //@assert gapbuf_left_pos(newbuf) + offset == ppos;

  gapbuf_forwardn(origbuf,rpos);
  gapbuf_deleten(origbuf,half);

  dll newpoint = alloc(struct list_node);
  newpoint->data = newbuf;
  dll point = B->point;
  B->point = newpoint;
  if (offset > 0) {
    // point <-> newpoint
    newpoint->next = point->next;
    newpoint->next->prev = newpoint;
    newpoint->prev = point;
    point->next = newpoint;
  }
  else {
    // newpoint <-> point
    newpoint->prev = point->prev;
    newpoint->prev->next = newpoint;
    newpoint->next = point;
    point->prev = newpoint;
  }
  return;
}


void forward_char(tbuf B);  /* Move the cursor forward 1 char, to the right  */
void forward_char(tbuf B)   /* Move the cursor forward 1 char, to the right  */
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  if (tbuf_at_right(B) && gapbuf_at_right(B->point->data)) return;
  if (gapbuf_at_right(B->point->data)) tbuf_forward(B);
  gapbuf_forward(B->point->data);
  return;
}

void backward_char(tbuf B); /* Move the cursor backward 1 char, to the left  */
void backward_char(tbuf B)  /* Move the cursor backward 1 char, to the left  */
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  if (tbuf_at_left(B) && gapbuf_at_left(B->point->data)) return;
  if (gapbuf_at_left(B->point->data)) tbuf_backward(B);
  gapbuf_backward(B->point->data);
  return;
}

void insert_char(tbuf B, char c); /* Insert the char c before the cursor     */
void insert_char(tbuf B, char c)  /* Insert the char c before the cursor     */
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  if (gapbuf_full(B->point->data)) split_point(B);
  gapbuf_insert(B->point->data,c);
  return;
}

void delete_char(tbuf B);         /* Delete the character before the cursor, */
                                  /*   also deletes the point if it is empty */
void delete_char(tbuf B)          /* Delete the character before the cursor, */
                                  /*   also deletes the point if it is empty */
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  if (gapbuf_at_left(B->point->data) && tbuf_at_left(B)) return;
  if (gapbuf_at_left(B->point->data)) tbuf_backward(B);
  gapbuf_delete(B->point->data);
  if (gapbuf_empty(B->point->data))
  {
    if (tbuf_at_left(B) && tbuf_at_right(B)) return;
    tbuf_delete_point(B);
  } else return;
  return;
}


/* IMPLEMENTATION */
