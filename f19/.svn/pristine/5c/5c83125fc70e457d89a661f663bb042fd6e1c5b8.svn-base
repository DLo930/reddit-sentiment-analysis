\part[2]\TAGS{c-numbers, bit-patterns}
For this question, assume that \lstinline'char' is a 1-byte signed
integer type and that \lstinline'unsigned int' is a 4-byte unsigned
integer type.

Write the C function \lstinline'pack_cui' which takes a \lstinline'char'
array of length 4 and packs it into a single \lstinline'unsigned int'. We
want the 0th character aligned at the most significant byte, and the last
character aligned at the least significant byte. For example, given an array
\lstinline'C = {1, 2, -1, 4}', \lstinline'pack_cui(C)' should return
\lstinline'0x0102FF04'.

For full credit,
\begin{itemize}
\item%
  Make all casts explicit.
\item%
  Do not cast (or otherwise convert types) directly between signed and
  unsigned types of different sizes.
\item%
  Do not rely on the \emph{endianness}\footnote{``Endianness'' refers
      to the natural storage order of bytes for a particular hardware
      architecture; you can read about it on Wikipedia, and don't
      forget to read \emph{Gulliver's Travels} in your no doubt
      copious spare time.} of your machine. For example, the
  following code is incorrect:
\begin{lstlisting}[numbers=none]
unsigned int pack_cui(char* C) { return *((unsigned int*) C); }
\end{lstlisting}
\item%
  Make sure your solution works for \lstinline'char' arrays containing
  negative values.
\item%
  Write code that is clear and straightforward.
\end{itemize}

\begin{framed}
\begin{lstlisting}[aboveskip=0pt]
unsigned int pack_cui(char *C) {
\end{lstlisting}
\ifprintanswers
\begin{lstlisting}[basicstyle=\basicstyle\color{\answerColor}]
  return (  ((unsigned char)C[0]) << 24
          | ((unsigned char)C[1]) << 16
          | ((unsigned char)C[2]) << 8
          | (unsigned char)C[3]);
\end{lstlisting}
\else\vspace{3in}\fi
\begin{lstlisting}[belowskip=0pt]
}
\end{lstlisting}
\end{framed}

\RUBRIC
Part (b)
TAGS: c-numbers, bit-patterns

Gradescope rubric:
+ 1 pt Obtaining an unsigned char from a char (or goes through int and masks very carefully)
+ 1 pt Obtaining an unsigned int
+ 1 pt Correctly performs the shift and logical operations

Commentary:
No credit for "unsigned int pack_cui(char* C) { return *((unsigned
int*) C);" or similar (unlikely anyway).

One point for correctly obtaining an unsigned char from a char (by
casting or by assignment).

One point for correctly obtaining an unsigned int (by return,
assignment, or explicit cast)

One point for correct shift and logical ops; addition may be used
instead of logical disjunction.

Half credit for casting between unsigned and signed types of different
sizes, if it works.

One correct solution:
  return (((unsigned char)C[0]) << 24
          | ((unsigned char)C[1]) << 16
          | ((unsigned char)C[2]) << 8
          | (unsigned char)C[3]);

Another correct solution:
  unsigned int result = 0;
  for (int i=0 ; i < 4 ; i++) {
    unsigned char c = C[i];
    result = (result << 8) | c;
  }
  return result;
ENDRUBRIC
