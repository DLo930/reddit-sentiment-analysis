/*
 * Bloom filters
 * Task 1 solution
 *
 * 15-122 Principles of Imperative Computation */

#use <string>
#use <util>


/************************ Implementation ***********************/

typedef struct bloom_filter bloom;
struct bloom_filter {
  bool[] data;
  int capacity;
};

bool is_bloom(bloom* B) {
  if (B == NULL) return false;
  //@assert \length(B->data) == B->capacity;
  return B->capacity > 0;
}

bloom* bloom_new(int capacity)
//@requires capacity > 0;
//@ensures is_bloom(\result);
{
  bloom* B = alloc(bloom);
  B->capacity = capacity;
  B->data = alloc_array(bool, capacity);
  return B;
}

int hash_mul31(string x) {
  int h = 0;
  for (int i = 0; i < string_length(x); i++) {
    int c = char_ord(string_charat(x, i));
    h = h*31 + c;
  }
  return h;
}

int get_index(bloom* B, int hash_value)
//@requires is_bloom(B);
{
  return abs(hash_value % B->capacity);
}

bool bloom_contains(bloom* B, string x)
//@requires is_bloom(B);
{
  return B->data[get_index(B, hash_mul31(x))];
}

void bloom_add(bloom* B, string x)
//@requires is_bloom(B);
//@ensures is_bloom(B);
//@ensures bloom_contains(B, x);
{
  B->data[get_index(B, hash_mul31(x))] = true;
}

// Client type
typedef bloom* bloom_t;


/*********************** Interface to bloom filters ***********************/

// typedef ______* bloom_t;

bloom_t bloom_new(int table_size)
  /*@requires table_size > 0; @*/
  /*@ensures \result != NULL; @*/ ;

bool bloom_contains(bloom_t B, string x)
  /*@requires B != NULL; @*/ ;

void bloom_add(bloom_t B, string x)
  /*@requires B != NULL; @*/
  /*@ensures bloom_contains(B, x); @*/ ;
