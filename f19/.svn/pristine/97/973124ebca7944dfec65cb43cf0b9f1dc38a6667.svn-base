\bgroup
\newcommand{\thebound}
%{10000} % S18 and before
%{15122} % F18
{12345} % F19
\newcommand{\bound}{\textcolor{\contractColor}{\thebound}}

\newcommand{\total}
{total} %F19, S18 and before
%{sum} % F18

\clearpage
\Question{Proving a Function Correct}

In this question, we'll do part of the proof of correctness for a
function \lstinline'compute_sum' relative to a specification function
\lstinline'SUM'. We won't prove that the loop invariants are true
initially, and we won't prove that they're preserved by an arbitrary
iteration of the loop.

\begin{lstlisting}
int compute_sum(int n) {
  int [*\total*] = 0;
  while (n > 0) {
      [*\total*] = [*\total*] + n;
      n = n - 1;
  }
  return [*\total*];
}
\end{lstlisting}

\begin{parts}

\part[1]\TAGS{correctness}
Complete the specification function below with the simple mathematical
formula that gives the sum of numbers from 0 to $n$.

\begin{lstlisting}[frame=single, numbers=left]
int SUM(int n)
//@requires 0 <= n && n < [*\bound*];
{
  return [*\uanswer{33em}{n * (n + 1) / 2}*];
}
\end{lstlisting}

Give a postcondition for \lstinline'compute_sum' using this
specification function.

\begin{lstlisting}[frame=single, numbers=left, firstnumber=7]
int compute_sum(int num_ints)
//@requires 0 <= num_ints && num_ints < [*\bound*];

//@ensures [*\uanswer{32em}{\result{} == SUM(num\_ints)}*];[*\label{l:postcondition}*]
{
  int n = num_ints;
  int [*\total*] = 0;
  while (n > 0)[*\label{l:fcor1:lg}*]
  //@loop_invariant 0 <= n;[*\label{l:fcor1:LI1}*]
  //@loop_invariant n <= [*\bound*];
  // Additional loop invariant will go here[*\label{l:additional_LI}*]
  {
      [*\total*] = [*\total*] + n;
      n = n - 1;
  }
  return [*\total*];
}
\end{lstlisting}

\emph{Note: in the real world we wouldn't have an efficient
  closed-form solution used as a specification function for an
  inefficient loop-based solution. We usually use the slow, simple
  version as the specification function for the fast one!}

\RUBRIC
Part (a)
TAGS: correctness

Gradescope rubric:
+ 0.5 pts return n * (n + 1) / 2
+ 0.5 pts @ensures \result == SUM(num_ints)

Commentary:
  Equivalent formulations for the first one:
  (n * (n + 1)) / 2
  n * (n + 1) / 2    (operators are left associative)
  (n * n + n) / 2

  Not okay: n * (n + 1) * 0.5
  Not okay: n * n / 2 + n / 2
  Not okay to use "total" or "result" instead of "\result"

  ("total" is the local variable -- it may have been renamed in the writeup)
ENDRUBRIC


\clearpage
\part[2]\TAGS{correctness, loop-invariant}
Why was it necessary to add the new local \lstinline'num_ints' in the
second version of \lstinline'compute_sum' above?
\begin{framed}
\ifprintanswers{\color{\answerColor}
When using an argument variable in a postcondition in C0, we have to
make sure that the function won't change the argument variable when
the function executes, or the function won't compile. This avoids
ambiguity as to whether the postcondition is referring to the old
value of \lstinline'num_ints' or the new value.
}\else~\vspace{0.7in}\fi
\end{framed}

Give a suitable extra invariant that would allow us to prove the
function correct.

\begin{lstlisting}[frame=single, lineskip=5ex, belowskip=0pt,
                   numbers=left, firstnumber=17]
//@loop_invariant [*\uanswer{27em}{\total{} == SUM(num\_ints) - SUM(n)}*];
\end{lstlisting}

Which line numbers would we point to to justify that \lstinline'n == 0'
when the loop terminates?
\begin{framed}
\ifprintanswers{\color{\answerColor}
Lines~\ref{l:fcor1:lg} and~\ref{l:fcor1:LI1}.
}\else~\vspace{0.4in}\fi
\end{framed}

Substitute in 0 for \lstinline'n' in your loop invariant on
line~\ref{l:additional_LI} and then simplify.
\begin{framed}
\ifprintanswers{\color{\answerColor}
  \texttt{\total} \lstinline'== SUM(num_ints) - SQUARE(0)', so when we simplify,
  we have \texttt{\total} \lstinline'== SUM(num_ints)'.
}\else~\vspace{0.4in}\fi
\end{framed}

When you substitute \lstinline'\result' for \texttt{\total} in the
simplified version, you should have exactly the postcondition on
line~\ref{l:postcondition}.  This proves that the loop invariant and
the negation of the loop guard imply the postcondition.

\RUBRIC
Part (b)
TAGS: correctness, loop-invariant

Gradescope rubric:
+ 0.5 pts First blank: When using an argument variable in a postcondition in C0, we have to make sure that the function won't change the argument variable when the function executes or the function won't compile. This avoids ambiguity as to whether the postcondition is referring to the old value of num_ints or the new value.
+ 0.5 pts Second blank: //@loop_invariant total == SUM(num_ints) - SUM(n)
+ 0.5 pts Third blank: mentions lines 14 and 15, and no other lines
+ 0.5 pts Fourth blank: total == SUM(num_ints) - SUM(0), so when we simplify, we have total == SUM(num_ints)

Commentary:
- "total" is the local variable -- it may have been renamed in the writeup
ENDRUBRIC

\enlargethispage{5ex}
\part[1]\TAGS{correctness}
Termination arguments for loops (in this class, at least) must have the
following form:

\medskip

\emph{During an arbitrary iteration of the loop, the quantity
  \underline{\makebox[2.1em]{\ldots}} gets strictly
  \smash{\underline{larger}}, but from the loop invariants, we know
  this quantity can't ever get \smash{\underline{bigger}} than
  \underline{\makebox[2.1em]{\ldots}}}.

{\rule{0em}{0ex}\hfill or \hfill}

\emph{During an arbitrary iteration of the loop, the quantity
  \underline{\makebox[2.1em]{\ldots}} gets strictly
  \smash{\underline{smaller}}, but from the loop invariants, we know
  this quantity can't ever get \smash{\underline{smaller}} than
  \underline{\makebox[2.1em]{\ldots}}.}

\medskip
Assuming that your loop invariants are true initially and are preserved by
every iteration of the loop (which we didn't prove), why does the
loop in \lstinline'compute_sum' terminate?

\medskip
\begin{framed}
\newcommand{\vsep}{\rule{0em}{5ex}}%
During an arbitrary iteration of the loop, the quantity%
\uanswer{5em}{\texttt{n}}\vsep{} gets strictly%
\uanswer{5em}{smaller}\vsep{} but from the loop invariants, we know that
this quantity can't ever get%
\uanswer{5em}{smaller}\vsep{} than%
\uanswer{5em}{0}\vsep{}.
\end{framed}

\RUBRIC
Part (c)
TAGS: correctness

Gradescope rubric:
+ 1 pt -- EITHER -- n strictly decreases and never gets negative
+ 1 pt -- OR -- total strictly increases and never gets past B * (B + 1) / 2 = ... (where B is the bound in the precondition)
+ 1 pt -- OR -- some other correct answer

Commentary
- "total" is the local variable -- it may have been renamed in the writeup
ENDRUBRIC

\end{parts}

\egroup