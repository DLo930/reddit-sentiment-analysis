\clearpage
\Question{Debugging Preconditions and Postconditions}

Here is an initial, buggy specification of the function
\search{} that returns the index of the first occurrence of
an element \lstinline'x' in an array \lstinline'A'. You should assume
the \search{} function does not modify the contents of the
array \lstinline'A' in any way.

\lstinputlisting[numbers=left, lastline=7]{\code/search0.c0}

\begin{parts}
\part[0\half]\TAGS{array, search, safety, testing}
Give values of \lstinline'A' and \result{} below, such that the
precondition evaluates to \lstinline'true' and checking the
postcondition will cause an array-out-of-bounds exception.

\begin{framed}
\begin{itemize}
\item \lstinline'x = '\texttt{\thenum}
\item \lstinline'A = '\arraysol{\thenum}\arraytemplate
\item \lstinline'n = 5'
\item \result{}\lstinline' = '\uanswer{5em}{0}
\end{itemize}
\end{framed}

\RUBRIC
Part (a)
TAGS: array, search, safety, testing

Gradescope rubric:
+ 0.25 pts A[0] = THENUM
+ 0.25 pts \result = 0

Commentary:
. THENUM = 122 (changes each semester)
. Boxes irrelevant to the answer can be left blank
ENDRUBRIC


\part[0\half]\TAGS{array, correctness, testing}
Notice that the postcondition seems to be relying on \lstinline'A'
being sorted, although the precondition does not specify this. It
might be possible, then, that unsorted input will reveal additional
bugs in our initial specification.

Give values for \lstinline'A' and \result{} below, such that
\result{}\lstinline' != -1', the precondition and the postcondition
both evaluate to \lstinline'true', and \result{} is \emph{not} the
index of the first occurrence of \lstinline'x' in the array.
%Even in cases where we don't access an array out of bounds, the
%specification is buggy because we left off an important precondition
%that should have appeared as line 3:
%\lstinline'@requires is_sorted(A, 0, n)'.
%
%Of course, we can perform linear search on an unsorted array, but if
%our array is not necessarily sorted, line 7 doesn't actually
%enforce that \result{} is the first occurrence of \lstinline'x' in the
%array.
%
%Give specific values for inputs and output such that the precondition
%on line 2 and the postcondition both evaluate to true but the
%result is not the index of the first occurrence of \lstinline'x' in the
%array. (Hint: the array \lstinline'A' should not be sorted.)

\begin{framed}
\begin{itemize}
\item \lstinline'x = '\texttt{\thenum}
\item \lstinline'A = '\arraysol{\thenum\qquad-10~\qquad\thenum}\arraytemplate
\item \lstinline'n = 5'
\item \result{}\lstinline' = '\uanswer{5em}{2}
\end{itemize}
\end{framed}

\RUBRIC
Part (b)
TAGS: array, correctness, testing

Gradescope rubric:
+ 0.25 pts A contains multiple occurrences of THENUM, including one that is to the left of \result.
+ 0.25 pts A[\result - 1] < THENUM

Commentary:
. THENUM = 122 (changes each semester)
. Boxes irrelevant to the answer can be left blank
. \result is given and is the index of the not-first occurrence of THENUM in the array
ENDRUBRIC


\part[0\half]\TAGS{array, correctness, testing}
Give values for \lstinline'A' and \result{} below, such that the precondition
evaluates to \lstinline'true', the postcondition evaluates to
\emph{\lstinline'false'}, and \result{} \emph{is} the index of the
first occurrence of \lstinline'x' in the array.

\begin{framed}
\begin{itemize}
\item \lstinline'x = '\texttt{\thenum}
\item \lstinline'A = '\arraysol{\thenum{0}\qquad\thenum}\arraytemplate
\item \lstinline'n = 5'
\item \result{}\lstinline' = '\uanswer{5em}{1}
\end{itemize}
\end{framed}

\RUBRIC
Part (c)
TAGS: array, correctness, testing

Gradescope rubric:
+ 0.25 pts A[\result] is the first occurrence of THENUM
+ 0.25 pts A[\result - 1] > THENUM

Commentary:
. THENUM = 122 (changes each semester)
. Boxes irrelevant to the answer can be left blank
. \result is >0, is the index of the first occurrence of THENUM in the array
ENDRUBRIC

\part[1]\TAGS{array, safety, sorting}
Edit line 7 slightly so that, if we added an additional precondition
\begin{lstlisting}[firstnumber=3]
//@requires is_sorted(A, 0, n);
\end{lstlisting}
the postcondition for \search{} would be safe and it would correctly
enforce that \lstinline'A['\result{}\lstinline']' is the first occurrence of
\lstinline'x' in \lstinline'A'. Do \emph{not} use any of the
\lstinline'arrayutil.c0' specification functions.

\emph{The addition you make to the postcondition
should run in constant time ($O(1)$). (We don't
usually care about the complexity of our contracts, of course, but
this limits what kinds of answers you can give. In the future, unless we
specifically say otherwise, you can assume that the efficiency of
contracts doesn't matter.)}

\begin{lstlisting}[frame=single, numberblanklines=false, lineskip=1ex,
                   numbers=left, firstnumber=6]

  [*\uanswer{37em}{(\result{} == 0 || A[\result-1] < x)}*];
\end{lstlisting}

\RUBRIC
Part (d)
TAGS: array, safety, sorting

Gradescope rubric:
+0pt  @TAs: Any answer below (use one only)
+1pt  (\result == 0 || A[\result-1] < x)
+1pt  (\result <= 0 || A[\result-1] < x)
+1pt  (\result < 1 || A[\result-1] < x)
+1pt  (\result - 1 < 0 || A[\result-1] < x)
+1pt  (result == 0 ? true : A[\result-1] < x)

Commentary:
. THENUM = 122 (changes each semester)
. Don't penalize for leaving off the leading "&&" or the final
  trailing "); @*/" or for not clearly indicating the need for
  parentheses - there's a danger they will come away from this with
  the wrong idea about relative &&/|| precedence, but I wanna pick my
  battles.

. 1pt: ANY OF THE ABOVE, but with A[\result-1] != x

. 0.5pt: something like "if (result != 0) A[\result-1] < x" - good
  idea not C0 (Give 1/2 point adjustment and leave a "Not valid C0,
  but right idea" comment)

. 0pt: Counterexample to safety or correctness
. 0pt: \result > 0 && A[\result-1] < x
       (counterexample: \result == 0 and A[0] == THENUM incorrectly fails postcond)
. 0pt: A[\result-1] != x
       (counterexample: \result == 0 and A[0] == THENUM segfaults)
. 0pt: (remove entirely)
       (counterexample: \result == 1, A[0] == THENUM, A[1] == THENUM)
ENDRUBRIC


\part[1]\TAGS{array, correctness, safety}
Edit line 7 so that \emph{whether or not} we require that the
array is sorted, the postcondition for \search{} is safe and
correct. Make the answer as simple as possible. You'll need to use one
of the \lstinline!arrayutil.c0! specification functions.

\begin{lstlisting}[frame=single, numberblanklines=false, lineskip=1ex,
                   numbers=left, firstnumber=6]

  [*\uanswer{37em}{!is\_in(x,A,0,\result)}*];
\end{lstlisting}

\RUBRIC
Part (e)
TAGS: array, correctness, safety

Gradescope rubric:
+1pt    EITHER -- !is_in(x,A,0,\result)
+0.5pt  OR -- (simple, safe, but nor right-idea). E.g., gt_seg(x,A,0,\result) or gt_seg(x,A,0,\result) && lt_seg(x,A,0,\result) or similar
+0.5pt  OR -- (right-idea but not simple or safe). E.g., (\result == 0 || !is_in(x,A,0,\result)) or (\result == 0 || is_in(x,A,0,\result - 1))

Commentary:
. Same as before about not sweating the leading "&&" or trailing @*/
. 1pt: !is_in(x,A,0,\result)

SIMPLE AND SAFE, but not RIGHT IDEA
. 0.5pt: gt_seg(x,A,0,\result) or other assumption that array is sorted
. 0.5pt: gt_seg(x,A,0,\result) && lt_seg(x,A,0,\result)
         That's not how quantifiers work.

RIGHT IDEA, but not SIMPLE AND SAFE
. 0.5pt: Extra information that isn't wrong, like this:
         (\result == 0 || !is_in(x,A,0,\result))
. 0.5pt: Seeming to believe that functions have inclusive upper bounds
         (\result == 0 || is_in(x,A,0,\result - 1))

. 0pt: \result == 0 || gt_seg(x,A,0,\result)
. 0pt: is_in(x,A,0,\result - 1) -- this would have safety issues even
       if is_in had inclusive upper bounds
. 0pt: (\result == 0 || gt_seg(x,A,0,\result-1)) -- too many errors
. 0pt: Counterexample to safety or correctness
. 0pt: is_in(x,A,0,\result) or simple negation of the actual property
. 0pt: is_in(x,A,0,n) or some other tautology
. 0pt: unsafe or worse than the 1/2 point answer above
ENDRUBRIC

\end{parts}
