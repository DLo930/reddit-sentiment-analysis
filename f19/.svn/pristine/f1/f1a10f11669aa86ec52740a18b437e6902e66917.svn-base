\section*{\lstinline'switch' statements%
\TAGS{other-types}}

A \lstinline'switch' statement is a different way of expressing a
conditional.  Here's an example:

\bgroup
\smalllistings
\lstinputlisting{\code/print_dir.c}
\egroup

Each case's value should evaluate to a constant integer type (this can
be of any size, so \lstinline'char's, \lstinline'int's,
\lstinline'long long int's, etc).

The \lstinline'break' statements here are important: If we don't have
them, we get fall-through: without the break on line 11 we'd print
``Up'' and then ``Down'' for case \lstinline|'u'|.

Here's some code that takes a positive number at most 10 and
determines whether it is a perfect square. The behavior here is called
fall-through.

\bgroup
\smalllistings
\lstinputlisting{\code/is_perfect_square.c}
\egroup

Fall-through is useful but can be tricky. What's wrong with the
following code? How do you fix it?


\checkpoint*{\TAGS{other-types}}

\bgroup
\smalllistings
\lstinputlisting{\code/badswitch.c}
\egroup

\begin{solution}
  There are two cases: when the input is odd and when it is
  even. Let's look at both of them.
\begin{verbatim}$ ./badswitch 1
x is odd!
$ ./badswitch 2
x is even!
x is odd!\end{verbatim}

The code is missing an essential break statement at the end of the first case.
\end{solution}


\checkpoint*{\TAGS{c-memory, c-numbers, undefined-behavior}}

What's wrong with each of these pieces of code?


\begin{enumerate}
\smalllistings

\item\hfill\\[-4ex]%
\begin{lstlisting}[numbers=left]
int* add_sorta_maybe(int a, int b) {
    int x = a + b;
    return &x;
}
\end{lstlisting}

\item\hfill\\[-4ex]%
\begin{lstlisting}[numbers=left]
int main () {
    unsigned int x = 0xFE1D;
    short y = (short)x;
    return 0;
}
\end{lstlisting}

\item\hfill\\[-4ex]%
\begin{lstlisting}[numbers=left]
int main() {
    char* s = "15-122";
    s[4] = '1'; // blasphemy
    printf(s);
    return 0;
}
\end{lstlisting}

\item\hfill\\[-4ex]%
\begin{lstlisting}[numbers=left]
int main() {
    int x = 0;
    if (x = 1)
        printf("woo\n");
    return x;
}
\end{lstlisting}

\item\hfill\\[-4ex]%
\begin{lstlisting}[numbers=left]
int main() {
    char s[] = {`a', `b', `c'};
    printf("%s\n", s);
    return 0;
}
\end{lstlisting}

\item\hfill\\[-4ex]%
\begin{lstlisting}[numbers=left]
void print_int(int* i) {
    printf("%d\n", *i);
    free(i);
}

int main() {
    int x = 6;
    print_int(&x);
    return 0;
}
\end{lstlisting}
\end{enumerate}

\begin{solution}
Spend some time here! There are many things not covered in the rest of the
handout, like the different parts of memory (stack, heap, read-only, text),
NUL-terminated strings, etc.

\begin{enumerate}
\item%
  Never return a stack address outside of its scope! Not exactly
  undefined behavior yet, but can basically only lead to undefined
  behavior.

\item%
  We cast from an unsigned int to a signed short, which is
  implementation defined.

\item%
  String literals (strings created with literal quotation marks, not
  arrays) are immutable --- you can't assign to them. Also, this is
  15-122, not 15-112.

\item%
  This will print woo, because it's actually modifying x and returning
  its value. Then because x has changed, the main function will return
  1, indicating error.

\item%
  This will cause undefined behavior by reading off the end of the
  array until a NUL character \lstinline"'\0'" is found.

\item%
  \lstinline'print_int' attempts to free the pointer it is passed, but
  that pointer is a pointer to a location on the stack. Since it
  doesn't point to memory returned by \lstinline'malloc' or
  \lstinline'calloc', this is undefined behavior.

\end{enumerate}
\end{solution}
