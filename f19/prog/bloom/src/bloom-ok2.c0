/* 
 * Interface for bloom filters (sets)
 * Task 3-5 solution with three LCG implementations 
 * 
 * 15-122 Principles of Imperative Computation */

#use <string>
#use <util>

/*** Interface to bloom filters ***/

// typedef ______* bloom_t;
typedef struct bloom_header* bloom_t;

bloom_t bloom_new(int table_size)
  /*@requires table_size > 0; @*/
  /*@ensures \result != NULL; @*/ ;

bool bloom_contains(bloom_t B, string x)
  /*@requires B != NULL; @*/ ;

void bloom_add(bloom_t B, string x)
  /*@requires B != NULL; @*/
  /*@ensures bloom_contains(B, x); @*/ ;

/*** Implementation of bloom filters ***/

typedef struct bloom_header bloom;
struct bloom_header {
  int[] data;
  int limit;
};

bool is_bloom(bloom* B) {
  if (B == NULL) return false;
  //@assert \length(B->data) == B->limit;
  return B->limit > 0;
}

bloom* bloom_new(int capacity) 
//@requires capacity > 0;
//@ensures is_bloom(\result);
{
  bloom* B = alloc(bloom);
  B->limit = (capacity + 31)/32;
  B->data = alloc_array(int, B->limit);
  return B;
}

int hash1(string x) { // Numerical Recipies
  int h = 0;
  for (int i = 0; i < string_length(x); i++) {
    int c = char_ord(string_charat(x, i));
    h = h + c;
    h = h*1664525 + 1013904223;
  }
  return h;
}

int hash2(string x) { // Borland
  int h = 0xC0FFEE;
  for (int i = 0; i < string_length(x); i++) {
    int c = char_ord(string_charat(x, i));
    h = h + c;
    h = h*134775813 + 1;
  }
  return h;
}

int hash3(string x) { // Microsoft
  int h = 0xDEADBEEF;
  for (int i = 0; i < string_length(x); i++) {
    int c = char_ord(string_charat(x, i));
    h = h + c;
    h = h*214013 + 2531011;
  }
  return h;
}

bool get_bit(int[] A, int i) 
//@requires 0 <= i && i/32 < \length(A);
{
  int j = i >> 5;
  int k = i & 31;
  return 1 == ((A[j] >> k) & 1); 
}

void set_bit(int[] A, int i)
//@requires 0 <= i && i/32 < \length(A);
{
  int j = i >> 5;
  int k = i & 31;
  A[j] |= 1 << k;
}

int get_index(bloom* B, int hash_value) 
//@requires is_bloom(B);
{
  return abs(hash_value % (B->limit << 5));
}

bool bloom_contains(bloom* B, string x)
//@requires is_bloom(B);
{
  return get_bit(B->data, get_index(B, hash1(x)))
    && get_bit(B->data, get_index(B, hash2(x)))
    && get_bit(B->data, get_index(B, hash3(x)));
}

void bloom_add(bloom* B, string x) 
//@requires is_bloom(B);
//@ensures is_bloom(B);
//@ensures bloom_contains(B, x);
{
  set_bit(B->data, get_index(B, hash1(x)));
  set_bit(B->data, get_index(B, hash2(x)));
  set_bit(B->data, get_index(B, hash3(x)));
}