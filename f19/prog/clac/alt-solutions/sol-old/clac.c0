/*
 * Clac, stack-based calculator language
 * Uses extended libraries
 *
 * 15-122 Principles of Imperative Computation */

#use <string>
#use <parse>
#use <conio>
#use <args>
#use <util>

struct state_header {
  bool trace;
};
typedef struct state_header* clacstate;

clacstate init_state()
//@ensures \result != NULL;                                                     
{
  return alloc(struct state_header);
}

void register_trace(clacstate ST)
//@requires \result != NULL;
{
  ST->trace = true;
}

void print_header() {
  print("                                 stack ||");
  print("queue                                 \n");
}

string pad(string S, bool left_aligned) {
  int len = string_length(S);

  if (len > 38) {
    if (left_aligned) {
      return string_join(string_sub(S, 0, 35), "...");
    } else {
      return string_join("...", string_sub(S, len-35, len));
    }
  }

  int padding = 38 - len + 1;
  char[] chr = alloc_array(char, padding);
  for (int i = 0; i < padding - 1; i++) {
    chr[i] = ' ';
  }
  chr[padding-1] = '\0';

  if (left_aligned) {
    return string_join(S, string_from_chararray(chr));
  }
  return string_join(string_from_chararray(chr), S);
}

/* auxiliary arithmetic functions that check for overflow */
int div(int x, int y) {
  if (y == 0) error("division by zero");
  if (x == int_min() && y == -1) error("division overflow");
  return x / y;
}

int mod(int x, int y) {
  if (y == 0) error("modulo zero");
  if (x == int_min() && y == -1) error("modulus overflow");
  return x % y;
}

/* auxiliary deq and pop functions that check for emptiness */
string DEQ(queue Q) {
  if (queue_empty(Q)) error("unexpected end of input");
  return deq(Q);
}

int POP(stack S) {
  if (stack_empty(S)) error("not enough elements on stack");
  return pop(S);
}

int PICK(stack S, int n) 
//@requires n > 0;
{
  int i = POP(S);
  if (n == 1) { 
    push(S, i);
    return i;
  } else {
    int j = PICK(S, n-1);
    push(S, i);
    return j;
  }
}

void print_state(queue Q, stack S) {
  print(pad(stack_to_string_autograder(S), false));
  print(" || ");
  print(pad(queue_to_string_autograder(Q), true));
  print("\n");
}

/* return false to exit interpreter */
bool eval(queue Q, stack S, bool trace)
{ 
  if (trace) print_header();
  while (!queue_empty(Q)) {
    if (trace) print_state(Q, S);
    string tok = DEQ(Q);
    // print("Read: "); print(tok); print("\n");
    if (string_equal(tok, "+")) {
      int y = POP(S);
      int x = POP(S);
      push(S, x+y);
    } else if (string_equal(tok, "-")) {
      int y = POP(S);
      int x = POP(S);
      push(S, x-y);
    } else if (string_equal(tok, "*")) {
      int y = POP(S);
      int x = POP(S);
      push(S, x*y);
    } else if (string_equal(tok, "/")) {
      int y = POP(S);
      int x = POP(S);
      push(S, div(x,y));
    } else if (string_equal(tok, "%")) {
      int y = POP(S);
      int x = POP(S);
      push(S, mod(x,y));
    } else if (string_equal(tok, "<")) {
      int y = POP(S);
      int x = POP(S);
      push(S, (x < y) ? 1 : 0);
    } else if (string_equal(tok, "drop")) {
      POP(S);
    } else if (string_equal(tok, "swap")) {
      int y = POP(S);
      int x = POP(S);
      push(S, y); push(S, x);
    } else if (string_equal(tok, "dup")) {
      int x = POP(S);
      push(S, x); push(S, x);
    } else if (string_equal(tok, "rot")) {
      int z = POP(S);
      int y = POP(S);
      int x = POP(S);
      push(S, y); push(S, z); push(S, x);
    } else if (string_equal(tok, "print")) {
      int x = POP(S);
      printint(x); print("\n");
    } else if (string_equal(tok, "quit")) {
      return false; /* do not continue */
    } else if (string_equal(tok, "skip")) {
      int n = POP(S);
      if (n < 0) error("negative skip not valid");
      while (n > 0) {
        DEQ(Q);
        n--;
      }
    } else if (string_equal(tok, "if")) {
      /* if false, skip two tokens; otherwise just continue */
      if (POP(S) == 0) {
        DEQ(Q);
        DEQ(Q);
      } /* if true (!= 0), just continue */
    } else if (string_equal(tok, "else")) {
      /* skip next token */
      DEQ(Q);
    } else if (string_equal(tok, "pick")) {
      int n = POP(S);
      if (n <= 0) error("pick must be positive");
      push(S,PICK(S, n));
    } else {
      int* p = parse_int(tok, 10);
      if (p != NULL) {
        /* input token was number, stored in p */
        push(S, *p);
      } else {
        error(string_join("undefined token ", tok));
      }
    }
  }

  if (trace) print_state(Q, S);
  return true; /* continue */
}

