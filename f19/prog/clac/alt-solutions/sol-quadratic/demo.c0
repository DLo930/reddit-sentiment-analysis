/*
 * Clac, stack-based calculator language
 *
 * 15-122 Principles of Imperative Computation, Fall 2012
 * Frank Pfenning
 */

#use <string>
#use <parse>
#use <conio>
#use <args>
#use <util>

#use "lib/queues_string.c0"
#use "lib/stacks_int.c0"
#use "lib/tokenize.c0"

int stack_size(stack S) {
  int x = 0;
  stack R = stack_new();
  while(!stack_empty(S)) {
    x++;
    push(R, pop(S));
  }

  while(!stack_empty(R)) {
    push(S, pop(R));
  }

  return x;
}

/* auxiliary arithmetic functions that check for overflow */
int div(int x, int y) {
  if (y == 0) error("Error: division by zero");
  if (x == int_min() && y == -1) error("Error: division overflow");
  return x / y;
}

int mod(int x, int y) {
  if (y == 0) error("Error: modulo zero");
  if (x == int_min() && y == -1) error("Error: modulus overflow");
  return x % y;
}

/* auxiliary deq and pop functions that check for emptiness */
string DEQ(queue Q) {
  if (queue_empty(Q)) error("Error: unexpected end of input");
  return deq(Q);
}

/* return false to exit interpreter */
bool eval(queue Q, stack S)
//@ensures \result == false || queue_empty(Q);
{
  while (!queue_empty(Q)) {
    string tok = DEQ(Q);
    // print("Read: "); print(tok); print("\n");
    if (string_equal(tok, "+")) {
      if (stack_size(S) < 2) error("Not enough elements on stck");
      int y = pop(S);
      int x = pop(S);
      push(S, x+y);
    } else if (string_equal(tok, "-")) {
      if (stack_size(S) < 2) error("Not enough elements on stck");
      int y = pop(S);
      int x = pop(S);
      push(S, x-y);
    } else if (string_equal(tok, "*")) {
      if (stack_size(S) < 2) error("Not enough elements on stck");
      int y = pop(S);
      int x = pop(S);
      push(S, x*y);
    } else if (string_equal(tok, "/")) {
      if (stack_size(S) < 2) error("Not enough elements on stck");
      int y = pop(S);
      int x = pop(S);
      push(S, div(x,y));
    } else if (string_equal(tok, "%")) {
      if (stack_size(S) < 2) error("Not enough elements on stck");
      int y = pop(S);
      int x = pop(S);
      push(S, mod(x,y));
    } else if (string_equal(tok, "<")) {
      if (stack_size(S) < 2) error("Not enough elements on stck");
      int y = pop(S);
      int x = pop(S);
      push(S, (x < y) ? 1 : 0);
    } else if (string_equal(tok, "drop")) {
      if (stack_size(S) < 1) error("Not enough elements on stck");
      pop(S);
    } else if (string_equal(tok, "swap")) {
      if (stack_size(S) < 2) error("Not enough elements on stck");
      int y = pop(S);
      int x = pop(S);
      push(S, y); push(S, x);
    } else if (string_equal(tok, "dup")) {
      if (stack_size(S) < 1) error("Not enough elements on stck");
      int x = pop(S);
      push(S, x); push(S, x);
    } else if (string_equal(tok, "rot")) {
      if (stack_size(S) < 3) error("Not enough elements on stck");
      int z = pop(S);
      int y = pop(S);
      int x = pop(S);
      push(S, y); push(S, z); push(S, x);
    } else if (string_equal(tok, "print")) {
      if (stack_size(S) < 1) error("Not enough elements on stck");
      int x = pop(S);
      printint(x); print("\n");
    } else if (string_equal(tok, "quit")) {
      return false;		/* do not continue */
    } else if (string_equal(tok, "if")) {
      /* if false, skip two tokens; otherwise just continue */
      if (stack_size(S) < 1) error("Not enough elements on stck");
      if (pop(S) == 0) {
	DEQ(Q);
	DEQ(Q);
      } /* if true (!= 0), just continue */
    } else if (string_equal(tok, "else")) {
      /* skip next token */
      DEQ(Q);
    } else {
      /* not defined as an operation name, must be int */
      int* x = parse_int(tok, 10);
      if (x == NULL) error(string_join("Error: undefined symbol ", tok));
      push(S, *x);
    }
  }
  return true;			/* continue */
}
