\documentclass[12pt]{exam}
\newcommand{\hwnumber}{5}
\newcommand{\hwname}{Clac}
\newcommand{\duedate}{\formatdate{10}{10}{\YEAR} by \progDueTime} % day-month-year

\input{../../inc/preamble.tex}
\lstdefinelanguage[clac]{C}[C0]{C}{%
  numbers=none,
  deletekeywords={if},
  alsoletter={+, -, *, /, \%, <, :, ;},
%  morekeywords={print, quit, +, -, *, /, \%, <, drop, swap, rot, if, pick, skip},
  morekeywords={:, ;},
  moredelim=[l][\shellstyle]{\%},
  moredelim=[l][\coinheaderstyle]{Clac\ top\ level},
  moredelim=**[l][\coininputstyle]{clac>>},
  moredelim=[l][\coinerrorstyle]{Abort\ trap:},
}

\begin{document}
\hwTitle

\noindent
In this assignment, you will implement a
\emph{claculator}\textsuperscript{\texttrademark} for the Clac programming
language.

\bigskip
\noindent
The code handout for this assignment is on \autolab{} and at
\begin{center}
\whereisthetgz{clac-handout.tgz}
\end{center}
The file \lstinline'README.txt' in the code handout goes over the
contents of the handout and explains how to hand the assignment in.
There is a SEVEN (7) PENALTY-FREE HANDIN LIMIT.
Every additional handin will incur a small (5\%) penalty (even if
using a late day).


\paragraph{Testing}

% Because we are setting a low handin limit, we are going to be
% very clear how we intend to test your programs.
We will test your
Clac implementation by running tests of the following form:
\begin{quote}
\begin{lstlisting}
test_prog(clac_program, state, initial_stack, final_stack, result);
\end{lstlisting}
\end{quote}

\noindent
We will check four things:
\begin{enumerate}
\item%
  Your code must respect the library interfaces described in the
  \lstinline'lib' directory. We will compile your code against
  \emph{different} implementations of stacks and queues, so you must
  only use the functions and types given as part of the interface.
\item%
  When given valid input, your interpreter must run without errors and
  wind up with the correct stack.
\item%
  When given invalid input, your interpreter must halt with a call to
  \lstinline'error', signaling that the user has written an invalid
  program.
\item%
  All operations must have good asymptotic running time when we
  compile without \lstinline'-d'. (This means that all operations
  should take constant time except for \lstinline'**',
  \lstinline'pick' and \lstinline'skip'. The time it takes to copy the
  $n^\emph{th}$ stack element or delete $n$ tokens from the queue
  should be in $O(n)$.)
\end{enumerate}
The file \lstinline'clac-test.c0' includes examples of how to write
and run tests of this form, and the \lstinline'README.txt' explains
how to compile and run these tests.





%% You will complete some starter
%% code in three C0 files, and optionally submit some code in the
%% Clac language for extra credit.
%% \begin{itemize}
%% \item \lstinline"demo.c0" (described in Sections~\ref{sec:demo} and~\ref{sec:cond})
%% \item \lstinline"dict.c0" (described in Section~\ref{sec:dict}),
%% \item \lstinline"clac.c0" (described in Section~\ref{sec:def})
%% \item \lstinline'bonus.clac' (optional, described in Section~\ref{sec:bonus})
%% \end{itemize}

%% \vspace{0.1in}
%% \noindent
%% You should submit these files electronically by 11:59 pm on the due date.
%% Detailed submission instructions can be found below.

%% \vspace{0.1in} This assignment does not require a lot of code, but may
%% be conceptually difficult.
%% \begin{itemize}
%% \item Please read all parts of the assignment carefully.
%% \item Frequently and incrementally test your code.  You can do small
%%   claculations interactively for the first two tasks, and run small
%%   Clac programs for Task 4.  Take advantage of that to catch
%%   conceptual errors early.
%% \end{itemize}
%% The starter code in \lstinline'demo.c0' is set up so that it compiles and
%% runs as given, even though it cannot do anything interesting
%% initially.

\paragraph{Sharing tests}

The academic integrity policy for this course does not allow you to
view other people's C0 code or share your C0 code with
others. However, you may share Clac code, including \underline{\em
  Clac-only} test cases, via \qatool{} posts. If you share tests, tag
your post with \lstinline'#clactest'.

\clearpage
Task 4 asks you to write a Clac program for integer logarithm, but you
may find it fun and educational to try something more challenging as
well.  Every semester, one or two ambitious students write prime-number
tests in Clac; one student in Fall 2014 wrote an implementation of
\emph{another} programming language, Bitwise Cyclic Tag, in the Clac
language! What will you come up with?


\section{Introducing the \emph{Clac}ulator}
\label{sec:demo}

Clac is a new stack-based programming language developed by a
Pittsburgh-area startup called Reverse Polish Systems (RPS).  Any
similarities of Clac with Forth or PostScript are purely coincidental.
In the first part of this assignment, we will be implementing the core
features of the Claculator, and later we will be adding a few more
interesting features.

Clac works like an interactive calculator.  When it runs, it maintains
an \emph{operand stack}.  Entering numbers will simply push them onto
the operand stack.  When an operation such as addition \lstinline'+' or
multiplication \lstinline'*' is encountered, it will be applied to the top
elements of the stack (consuming them in the process) and the result
is pushed back onto the stack.  When a newline is read, the number on
top of the stack will be printed.  This is an example where we start Clac
and type \lstinline'3 4 +', followed by a newline:
\begin{quote}
\begin{lstlisting}[language={[clac]C}]
% ./clac
Clac top level
clac>> 3 4 +
7
\end{lstlisting}
\end{quote}
Clac responded by printing \lstinline'7', which is now on top of the stack
(which is otherwise empty).  We now enter \lstinline'-9 2 /' and a newline,
after which Clac responds with \lstinline'-4'.
\begin{quote}
\begin{lstlisting}[language={[clac]C}]
clac>> -9 2 /
-4
\end{lstlisting}
\end{quote}
At this point the stack has \lstinline'7' (the result of the addition)
and \lstinline'-4' (the result of the integer division) and we can
subtract them simply by typing \lstinline'-' and a newline.
\begin{quote}
\begin{lstlisting}[language={[clac]C}]
clac>> -
11
\end{lstlisting}
\end{quote}
We obtain \lstinline'11', since $7-(-4) = 11$.  We can quit our interactions by
typing \lstinline'quit'.
\begin{quote}
\begin{lstlisting}[language={[clac]C}]
clac>> quit
11
Bye!
\end{lstlisting}
\end{quote}
We can type multiple inputs (numbers and operations) on
the same line.  For example,
\begin{quote}
\begin{lstlisting}[language={[clac]C}]
% ./clac
Clac top level
clac>> 11 10 2 9 - + *
33
\end{lstlisting}
\end{quote}
Please make sure you understand why the above yields \lstinline'33'
on the stack.

\newpage
\input{clacrules}

In addition to the arithmetic operations, there are a few special
operations you will have to implement.  The table at the top of
Figure~\ref{fig:allclac} is the complete set of operations that you
will be implementing in Task 1.  To specify the operations, we use the
notation
$$
S \mid\mid Q \longrightarrow S' \mid\mid Q'
$$
to mean that the stack $S$ and the queue $Q$ transition to become
stack $S'$ and the queue $Q'$.  We use a queue to hold the numbers and
operations Clac evaluates (and for other purposes as well --- see
below).  Stacks are written with the \emph{top element at the right
  end}!  For example, the action of multiplication is stated as
$$
S, x, y \mid\mid \mbox{\texttt{*}}, Q
\qquad\longrightarrow\qquad
S, x \times y \mid\mid Q
$$
which means: \emph{``When you dequeue the token \texttt{*} from the
  queue, pop the top element ($y$) and the next element ($x$) from the
  stack, multiply $y$ by $x$, and push the result $x \times y$ back onto
  the stack.''} The fact that we write $S$ in the rule above means
that there can be many other integers on the stack that will not be
affected by the operation.

Every operation in Clac is determined by the token that has just been dequeued
from the queue. The \lstinline'<' and \lstinline[language={[clac]C}]'if'
tokens cause \emph{different} things to happen depending on the specific
values on the stack.
\begin{align*}
S, x, y \mid\mid \mbox{\texttt{<}}, Q \qquad\longrightarrow\qquad
S, 1 \mid\mid Q & & \mbox{if $x < y$}
\\
S, x, y \mid\mid \mbox{\texttt{<}}, Q \qquad\longrightarrow\qquad
S, 0 \mid\mid Q & & \mbox{if $x \geq y$}
\end{align*}
In Clac, we use the integer $0$ to mean \lstinline'false' and we treat
non-zero values like $1$ as \lstinline'true'. The
\lstinline[language={[clac]C}]'if' token runs some code (the next
three tokens) only if the integer on the top of the stack is
\lstinline'true' (that is, nonzero). If the
\lstinline[language={[clac]C}]'if' token is reached while 0 is at the
top of the stack, the following three tokens are skipped.

As you implement the Clac operations in Figure~\ref{fig:allclac}, if
the instructions indicate that Clac should raise an error, you should
call the function \lstinline'error()' with the appropriate error
message.  The \lstinline'error()' function takes a string as its
argument and is built into C0, like \lstinline'assert()'.  User
errors (errors in Clac code) should always cause \lstinline'error' to
be called; assertions should only be used for programmer errors.


\section{Implementing Clac}

In \lstinline'clac.c0', you should not change any of the \lstinline'#use'
directives, and you should not change the type of \lstinline'eval', its
preconditions, or its postconditions:
\begin{quote}
\begin{lstlisting}[numbers=none]
bool eval(queue Q, stack S, state_t ST)
//@requires Q != NULL && S != NULL && ST != NULL;
//@ensures \result == false || queue_empty(Q);
\end{lstlisting}
\end{quote}
You do not need to worry about the \lstinline'state_header' struct, the
\lstinline'state_t' type, or the \lstinline'init_state()' function until Task 3.

The \lstinline'main' function in file \lstinline'clac-main.c0' and the
\lstinline'test_prog' function in \lstinline'clac-test.c0' both take lines of
input and convert them to a \emph{queue of tokens}. Each token is just
a string.  This part of the Clac implementation has already been
programmed for you, and you are welcome to examine it, but you should
not change this code.  In Clac, tokens are only separated by
white space.  For example, \lstinline'3 4+' will be read as two tokens
(\lstinline'"3"' followed by \lstinline'"4+"') and will therefore lead to an
error since the token \lstinline'"4+"' is not defined.

When \lstinline'eval' is first called, the \emph{stack of integers} $S$
will be empty.  But since the input is processed line-by-line, the
\lstinline'eval' function may also be called with nonempty stacks,
representing the values from prior computations.
The \lstinline'eval' function should dequeue tokens from the queue $Q$ and
process them according to the Clac definition.  When the queue is
empty, \lstinline'eval' should return \lstinline'true', leaving the stack in
whatever state it was already in.  Upon encountering the token ``\lstinline'quit''',
\lstinline'eval' should return \lstinline'false', indicating to the \lstinline'main'
function that it should exit.

\begin{task}[9]
\TAGS{correctness, interface, queue, safety, stack}
  In \lstinline'clac.c0', make sure the given implementations of
  \lstinline'print' and \lstinline'quit' are safe and correct, fixing
  them if they are not. Add implementations of \lstinline'+',
  \lstinline'-', \lstinline'*', \lstinline'**', \lstinline'/',
  \lstinline'%', and \lstinline'<' according to the specification in
  Figure~\ref{fig:allclac}.
\end{task}

\begin{task}[7]
\TAGS{correctness, interface, queue, safety, stack}
  In \lstinline'clac.c0', add definitions of \lstinline'drop',
  \lstinline'swap', \lstinline'rot',
  \lstinline[language={[clac]C}]'if', \lstinline'skip', and
  \lstinline'pick' according to the specification in
  Figure~\ref{fig:allclac}.
\end{task}

It is possible to write a lot of long and confusing code to safely and
efficiently implementing these two tasks, but it is also possible to
use helper functions to write very clear and concise code. As you
design your helper functions, remember the conditions we said we would
be checking on the first page!

The interfaces to stacks and queues, which are similar to the ones
from lecture, are given in the \lstinline'lib' directory. You may not
change these implementations, and you must respect their interfaces.

\section{Dictionaries}

Before we can talk about our final Clac feature, \emph{definitions},
we need to introduce a \emph{dictionary} data type that will associate
names with their definitions.
%%
%% For this purpose we program dictionaries using so-called
%% \emph{association lists}.  An association list is a linked list where
%% each list node contains a key (here the name) and data item (here the
%% definition).  Definitions are simply queues of tokens, so an
%% association list node is defined as follows:
%% \begin{quote}
%% \begin{lstlisting}
%% typedef struct alist_node alist;
%% struct alist_node {
%%   string name;
%%   queue def;
%%   alist* next;
%% };
%% \end{lstlisting}
%% \end{quote}
%%
%% The implementation of dictionaries as association lists can be very
%% simple: they're just a header struct with a pointer to an association
%% list.
%% \begin{quote}
%% \begin{lstlisting}
%% typedef struct dict_header* dict_t;
%% struct dict_header {
%%   alist* assoclist;
%% };
%% \end{lstlisting}
%% \end{quote}
%%
The interface to dictionaries contains three functions:
\begin{quote}
\begin{lstlisting}[numbers=none]
dict_t dict_new()
/*@ensures \result != NULL; @*/ ;

queue_t dict_lookup(dict_t D, string name)
/*@requires D != NULL; @*/ ;

void dict_insert(dict_t D, string name, queue_t def)
/*@requires D != NULL; @*/
/*@requires def != NULL; @*/ ;
\end{lstlisting}
\end{quote}
Lookup returns the most recently inserted queue for a given name, or
\lstinline'NULL' if no such queue exists.  Insertion with
\lstinline'dict_insert(D, name, def)' updates the dictionary so that
future lookups on \lstinline'name' will return \lstinline'def'. This
must handle the case where \lstinline'name' is not already defined in
the dictionary, in which case we have to add it, as well as the case
where \lstinline'name' is already defined, in which case we have to
override or replace the old definition with the new.

You should take a look at the implementation of dictionaries we give
you, which is probably the simplest but least efficient implementation
imaginable, based on \emph{association lists}, which are linked lists
where each node contains a key (the string) and a value (the
queue). The dictionaries don't ever use the queue interface, they just
store and return references to queues.

\section{Definitions}

Finally, we add definitions to Clac. A \emph{definition} has the form
$$
\mbox{\tt\bf :}\;
\mathit{name}\;\mathit{token}_1 \ldots \mathit{token}_n\;
\mbox{\tt\bf ;}
$$
When we encounter the token \lstinline':' (colon) in the input queue,
we interpret the following token as a $\mathit{name}$.  Then we create
a new (separate) queue, intended to hold the definition of
$\mathit{name}$.  Then we continue to scan the input queue, copying
each token to the new queue until we encounter a token \lstinline';'
(semicolon) which signals the end of the definition.  Then we add
$\mathit{name}$, with the new queue as its definition, to the
dictionary.

If the input queue ends after the colon (\lstinline':'), or if there
is no semicolon (\lstinline';') in the remainder of the input queue
after $\mathit{name}$, an error should be signaled.  In a definition,
$\mathit{name}$ can be any token, but if it is a built-in operator or
a number, then the definition can never be invoked since it is always
superseded by the predefined meaning.

Let's consider a simple example.
\begin{quote}
\begin{lstlisting}[language={[clac]C}]
: dup 1 pick ;
: square dup * ;
\end{lstlisting}
\end{quote}
This defines \lstinline'dup' and \lstinline'square'.  Whenever we see
\lstinline'square' in the input subsequently, it has the effect of
replacing $n$ on the top of the stack with $n^2$.  For example,
\begin{quote}
\begin{lstlisting}[language={[clac]C}]
% clac-ref
Clac top level
clac>> : dup 1 pick ; : square dup * ;
(defined dup)
(defined square)
(stack empty)
clac>> 5 square
25
\end{lstlisting}
\end{quote}
Note that \lstinline'5 square' should be identical to \lstinline'5 1 pick *'
which duplicates $5$ on the stack and then performs a multiplication.

\clearpage
How do we process a defined name when we encounter it in the queue of
tokens?  This is not entirely straightforward, as the following
example illustrates:
\begin{quote}
\begin{lstlisting}[language={[clac]C}]
clac>> 3 square 4 square +
25
\end{lstlisting}
\end{quote}
When we see the first occurrence of \lstinline'square' we cannot simply
replace the rest of the queue with the definition of \lstinline'square',
since after squaring $3$ we have to continue to process the rest
of the queue, namely \lstinline'4 square +'.

In order to implement this, we maintain a \emph{stack of queues of
  tokens} (which has already been implemented for you, see the file
\lstinline'lib/stack_of_queue_of_string.c0').  This is called the
\emph{return stack} or sometimes the \emph{call stack}.  When we
encounter a defined token, we push the remainder of the queue onto the
return stack, and begin using the definition as our queue of
tokens. When we finish executing a definition we pop the prior queue
of tokens from the return stack and continue with processing it.  When
there are no longer any queues on the return stack we return from the
\lstinline'eval' function.  Here's a trace of the above execution:
$$
\begin{tabular}{lrl}
\textbf{Operand Stack} & \textbf{Queue of Tokens\quad} & \textbf{Return Stack} \\
(empty) & \lstinline'3 square 4 square +' & (empty) \\
$3$ & \lstinline'square 4 square +' & (empty) \\
$3$ & \lstinline'dup *' & (\lstinline'4 square +') \\
$3$ & \lstinline'1 pick' & (\lstinline'4 square +'), (\lstinline'*') \\
$3, 1$ & \lstinline'pick' & (\lstinline'4 square +'), (\lstinline'*') \\
$3, 3$ & (empty) & (\lstinline'4 square +'), (\lstinline'*') \\
$3, 3$ & \lstinline'*' & (\lstinline'4 square +') \\
$9$ & (empty) & (\lstinline'4 square +') \\
$9$ & \lstinline'4 square +' & (empty) \\
$9, 4$ & \lstinline'square +' & (empty) \\
$9, 4$ & \lstinline'dup *' & (\lstinline'+') \\
$9, 4$ & \lstinline'1 pick' & (\lstinline'+'), (\lstinline'*') \\
$9, 4, 1$ & \lstinline'pick' & (\lstinline'+'), (\lstinline'*') \\
$9, 4, 4$ & (empty) & (\lstinline'+'), (\lstinline'*') \\
$9, 4, 4$ & \lstinline'*' & (\lstinline'+') \\
$9, 16$ & (empty) & (\lstinline'+') \\
$9, 16$ & \lstinline'+' & (empty) \\
$25$ & (empty) & (empty)
\end{tabular}
$$
After the last step, both the token queue and the return stack are
empty, so we return from the \lstinline'eval' function with an operand
stack consisting of the single number $25$.

If you run this example in the reference Clac interpreter with the
\lstinline'-trace' option, you'll see that the reference interpreter orders
the return stack in the other order, so that you always see the most
recent part of the return stack first.  The \lstinline'-trace' option
is not available in your own Clac implementation.


\clearpage
\section{Implementing Definitions}

\textbf{Before you work on this task, make sure you have tested your
  previous implementation yourself and with Autolab.} An Autolab
submission will also make sure you have a working backup to go back
to.  This task is the most challenging part of the assignment.

How to support definitions in your Clac interpreter?  This is where
the struct \lstinline'state_header' defined in \lstinline'clac.c0'
comes into play.  You'll modify your existing interpreter to use a
dictionary to store definitions by adding a field to the
\lstinline'state_header' --- part of the challenge is figuring out
what this field should be.  This struct is initialized by calling the
function \lstinline'init_state()' one time when the Clac interpreter
is first run; the pointer that \lstinline'init_state()' returns is
then passed back to \lstinline'eval' every time it is run.  You'll
therefore modify \lstinline'init_state' to initialize your new struct
field.

You'll need to allocate a return stack as well. The return stack can
be a field of the \lstinline'state_header' struct or you can allocate a new
return stack whenever \lstinline'eval()' is called.

You may use the same queue from a dictionary more than one time,
like the queue associated with \lstinline'square' in the example
above.  Therefore, it's important that each time you look up a queue
in the dictionary, you make a copy of it before you dequeue from that
queue.  The interface to queues in \lstinline'lib/queue_of_string.c0'
has a function \lstinline'queue_read_only_copy(Q)' that makes a
dequeue-only copy of a queue in $O(1)$ time.

\begin{task}[6]
\TAGS{dictionary, interface, queue, stack, struct}
Modify the \lstinline'state_header' struct and use it to
implement definitions in your Clac interpreter.
\end{task}

Some Clac examples are given in the files in the \lstinline'def/'
directory with the handout.  As an example, here is the definition of
the Fibonacci function with several auxiliary names like
\lstinline'noop' (which does nothing).
\begin{quote}
\begin{lstlisting}[language={[clac]C}]
: noop ;
: dup 1 pick ;
: fib dup if fib1 1 skip noop ;
: fib1 dup 1 - if fib_body 1 skip noop ;
: fib_body dup 1 - fib swap 2 - fib + ;
\end{lstlisting}
\end{quote}
It has the following summary effect:
$$
 S, n \mid\mid \texttt{fib}, Q \qquad\longrightarrow\qquad S, \mathit{fib}(n) \mid\mid Q
$$
(provided $n \geq 0$) where $\mathit{fib}$ is the standard
mathematical Fibonacci function.  It's a useful exercise to work
through by hand how, for example, \lstinline'2 fib' computes, starting
with the empty operand and return stacks.


\section{Writing a Clac Program}

\vspace{-\bigskipamount}
\begin{task}[3]
\TAGS{application, compilation}
  Write and submit a file \lstinline'log.clac' that defines a Clac function
  to compute the integer logarithm to the base 2 of the stack top.
\end{task}

Specifically, your definition of \lstinline'log' should have the
following summary effect:
$$
 S, n \mid\mid \texttt{log}, Q \qquad\longrightarrow\qquad S, \log n \mid\mid Q
$$
(provided $n > 0$) where $\log n$ is the integer logarithm of $n$ to
the base 2.  If $n \leq 0$, it doesn't matter what your Clac program
does. You may define as many (or few) other names in your program as
you like, but you \emph{must} define \lstinline'log'.

It will be helpful to understand how the definition of Fibonacci
(above) works, and it will also be helpful to code the integer $\log$
function recursively in C0 if you haven't already done so.

Example:
\begin{quote}
\begin{lstlisting}[language={[clac]C}]
clac>> 1 log
0
clac>> 2 log
1
clac>> 3 log
1
clac>> 4 log
2
clac>> 7 log
2
clac>> 8 log
3
clac>> 127 log
6
clac>> 128 log
7
\end{lstlisting}
\end{quote}


%% \section{Bonus: Clacworks}
%% \label{sec:bonus}

%% We've described the behavior of 10 tokens: \lstinline'drop',
%% \lstinline'swap', \lstinline'dup', \lstinline'rot', \lstinline'print',
%% \lstinline'quit', \lstinline'skip', \lstinline[language={[clac]C}]'if',
%% \lstinline'else', and \lstinline'pick'. As long as you leave the meaning of
%% programs with numbers and these 10 tokens alone, you can extend Clac with
%% new features and write programs that use these new tokens.

%% \begin{ectask}
%%   Add some new features to your Claculator by defining the meaning of
%%   new tokens. Write a cool or surprising program in \lstinline'bonus.clac',
%%   and describe the behavior of your new features and your Clac program
%%   in \lstinline'bonus.txt'.
%% \end{ectask}


\end{document}
