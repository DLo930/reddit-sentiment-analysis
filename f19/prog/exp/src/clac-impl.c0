/* 
 * Full clac implementation
 * Hastily assembled from pieces of the clac solutions set
 * The only incompatibility is that "stack_t" in clac is "istack_t" here. 
 */

#use <string>
#use <parse>
#use <conio>
#use <args>
#use <util>

/*
 * Dictionaries, implemented as assocation lists
 *
 * 15-122 Principles of Imperative Computation
 */

/* Interface to dictionaries */

// typedef ______* dict_t;
typedef struct dicty_header* dict_t;

dict_t dict_new()
  /*@ensures \result != NULL; @*/;

// Returns NULL if no definition is found
queue_t dict_lookup(dict_t D, string name)
  /*@requires D != NULL; @*/;

void dict_insert(dict_t D, string name, queue_t def)
  /*@requires D != NULL; @*/
  /*@requires def != NULL; @*/;

/* Implementation of dictionaries as association lists */

/* Association lists */
typedef struct assoclist_node assoclist;
struct assoclist_node {
  string name;
  queue_t def;
  assoclist* next;
};

bool iz_assoclist_segment(assoclist* start, assoclist* end) {
  if (start == NULL) return false;
  if (start == end) return true;
  return start->def != NULL && iz_assoclist_segment(start->next, end);
}

bool iz_acyclic_assoclist(assoclist* p) {
  if (p == NULL || p->next == NULL) return true;

  assoclist* tortise = p;
  assoclist* hare = p->next;
  if (p->def == NULL) return false;
  while (tortise != hare) 
  //@loop_invariant iz_assoclist_segment(tortise, hare);
  {
    if (hare->next == NULL || hare->next->next == NULL) return true;
    if (hare->def == NULL || hare->next->def == NULL) return false;
    tortise = tortise->next;
    hare = hare->next->next;
  }

  return false;
}

/* NULL is a valid (empty) association list; the only requirement we
 * make on association lists is that they be acyclic. */

/* Dictionaries */
typedef struct dicty_header dict;
struct dicty_header {
  assoclist* assoclist;
};

bool iz_dict(dict* D) {
  return D != NULL && iz_acyclic_assoclist(D->assoclist);
}

/* Allocating a new dictionary */
dict* dict_new()
//@ensures iz_dict(\result);
{
  dict* D = alloc(dict);
  D->assoclist = NULL;
  return D;
}

queue_t dict_lookup(dict* D, string name)
//@requires iz_dict(D);
{
  for (assoclist* p = D->assoclist; p != NULL; p = p->next) 
  //@loop_invariant iz_acyclic_assoclist(p);
  {
    if (string_equal(name, p->name)) {
      return p->def;
    }
  }

  return NULL;
}

void dict_insert(dict* D, string name, queue_t def)
//@requires iz_dict(D);
//@requires def != NULL;
//@ensures iz_dict(D);
//@ensures dict_lookup(D, name) != NULL;
{
  for (assoclist* p = D->assoclist; p != NULL; p = p->next) 
  //@loop_invariant iz_acyclic_assoclist(p);
  {
    if (string_equal(name, p->name)) {
      p->def = def;
      return;
    }
  }
  
  assoclist* p = alloc(struct assoclist_node);
  p->name = name;
  p->def = def;
  p->next = D->assoclist;
  D->assoclist = p;
  return;
}


/*
 * Clac, stack-based calculator language
 * Uses extended libraries
 *
 * 15-122 Principles of Imperative Computation */


struct state_header {
  bool trace;
  dict_t dictionary;
};
typedef struct state_header* state_t;

state_t init_state()
//@ensures \result != NULL;
{
  state_t ST = alloc(struct state_header);
  ST->trace = false;
  ST->dictionary = dict_new();
  return ST;
}

void register_trace(state_t ST)
//@requires ST != NULL;
{
  ST->trace = true;
}

/* auxiliary arithmetic functions that check for overflow */
int div(int x, int y) {
  if (y == 0) error("division by zero");
  if (x == int_min() && y == -1) error("division overflow");
  return x / y;
}

int mod(int x, int y) {
  if (y == 0) error("modulo zero");
  if (x == int_min() && y == -1) error("modulus overflow");
  return x % y;
}

// Power spec from lecture
int POW(int x, int y)
//@requires y >= 0;
{
  if (y == 0) return 1;
  return POW(x, y-1) * x;
}

// Power function from lecture
int fastpow(int x, int y)
//@ensures y >= 0 && \result == POW(x, y);
{
  if (y < 0) error("negative exponent");

  int b = x;
  int e = y;
  int r = 1;
  while (e > 0)
    //@loop_invariant e >= 0;
    //@loop_invariant POW(x, y) == r * POW(b, e);
    {
      if (e % 2 == 1) {
        r = b * r;
      }
      b = b * b;
      e = e / 2;
    }
  return r;
}

/* auxiliary deq and pop functions that check for emptiness */
string DEQ(queue_t Q)
//@requires Q != NULL;
{
  if (queue_empty(Q)) error("unexpected end of input");
  return deq(Q);
}

int POP(istack_t S)
//@requires S != NULL;
{
  if (istack_empty(S)) error("not enough elements on stack");
  return ipop(S);
}

int PICK(istack_t S, int n)
//@requires S != NULL;
//@requires n > 0;
{
  int i = POP(S);
  if (n == 1) {
    ipush(S, i);
    return i;
  } else {
    int j = PICK(S, n-1);
    ipush(S, i);
    return j;
  }
}

/* return false to exit interpreter */
bool eval(queue_t Q, istack_t S, state_t ST)
{
  qstack_t R = qstack_new();
  // if (ST->trace) print_header();

  while (!queue_empty(Q) || !qstack_empty(R)) {
    // if (ST->trace) print_state(Q, S, R);

    if (queue_empty(Q)) {
      //@assert !qstack_empty(R);
      Q = qpop(R);

    } else {
      //@assert !queue_empty(Q);

      string tok = DEQ(Q);
      // print("Read: "); print(tok); print("\n");
      if (string_equal(tok, "+")) {
        int y = POP(S);
        int x = POP(S);
        ipush(S, x+y);
      } else if (string_equal(tok, "-")) {
        int y = POP(S);
        int x = POP(S);
        ipush(S, x-y);
      } else if (string_equal(tok, "*")) {
        int y = POP(S);
        int x = POP(S);
        ipush(S, x*y);
      } else if (string_equal(tok, "**")) {
        int y = POP(S);
        int x = POP(S);
        ipush(S, fastpow(x, y));
      } else if (string_equal(tok, "/")) {
        int y = POP(S);
        int x = POP(S);
        ipush(S, div(x,y));
      } else if (string_equal(tok, "%")) {
        int y = POP(S);
        int x = POP(S);
        ipush(S, mod(x,y));
      } else if (string_equal(tok, "<")) {
        int y = POP(S);
        int x = POP(S);
        ipush(S, (x < y) ? 1 : 0);
      } else if (string_equal(tok, "drop")) {
        POP(S);
      } else if (string_equal(tok, "swap")) {
        int y = POP(S);
        int x = POP(S);
        ipush(S, y); ipush(S, x);
      } else if (string_equal(tok, "rot")) {
        int z = POP(S);
        int y = POP(S);
        int x = POP(S);
        ipush(S, y); ipush(S, z); ipush(S, x);
      } else if (string_equal(tok, "print")) {
        int x = POP(S);
        printint(x); print("\n");
      } else if (string_equal(tok, "quit")) {
        return false; /* do not continue */
      } else if (string_equal(tok, "if")) {
        /* if false, skip three tokens; otherwise just continue */
        if (POP(S) == 0) {
          DEQ(Q);
          DEQ(Q);
          DEQ(Q);
        } /* if true (!= 0), just continue */
      } else if (string_equal(tok, "pick")) {
        int n = POP(S);
        if (n <= 0) error("pick must be positive");
        ipush(S,PICK(S, n));
      } else if (string_equal(tok, "skip")) {
        int n = POP(S);
        if (n < 0) error ("skip must be nonnegative");
        while (n > 0) { n--; DEQ(Q); }
      } else if (string_equal(tok, ":")) {
        string name = DEQ(Q);
        queue_t DEF = queue_new();
        string next = DEQ(Q);

        while (!string_equal(next, ";")) {
          enq(DEF, next);
          next = DEQ(Q);
        }

        dict_insert(ST->dictionary, name, DEF);
        print("(defined "); print(name); println(")");

      } else {
        int* p = parse_int(tok, 10);
        queue_t DEF = dict_lookup(ST->dictionary, tok);
        if (p != NULL) {
          /* input token was number, stored in p */
          ipush(S, *p);
        } else if (DEF != NULL) {
          qpush(R, Q);
          Q = queue_read_only_copy(DEF);
        } else {
          error(string_join("undefined token ", tok));
        }
      }
    }
  }

  //if (ST->trace) print_state(Q, S, R);
  return true; /* continue */
}

int test(queue_t Q, istack_t S, state_t ST) 
//@requires Q != NULL && S != NULL && ST != NULL;
{
  bool cont = eval(Q, S, ST);

  if (cont && !queue_empty(Q)) {
    return -128;
  }

  if (istack_empty(S)) {
    return -128;
  }

  int result = ipop(S);
  if (!istack_empty(S)) {
    return -128;
  }

  return result;
}

queue_t input_file(string path) {
  queue_t Q = queue_new();
  file_t file = file_read(path);
  if (file == NULL) error("Error: file does not exist");

  while (!file_eof(file)) {
    string line = file_readline(file);
    int n = num_tokens(line);
    string[] A = parse_tokens(line);

    for (int i = 0; i < n; i++) 
    //@loop_invariant 0 <= i;
      enq(Q, A[i]);
  }

  file_close(file);
  return Q;
}


int main() {
  /* pass file names on command line, no flags */
  /* these will be processed in order */
  args_t args = args_parse();
  int argc = args->argc;
  if (argc < 1) error("Must be at least one arg, a clac program");

  istack_t S = istack_new();
  state_t ST = init_state();

  int result = 0;

  for (int i = 0; i < argc - 1; i++)
  //@loop_invariant 0 <= i;
  {
    string filename = args->argv[i];
    print("Loading file "); print(filename); print("\n");
    result = test(input_file(args->argv[i]), S, ST);
  }

  return test(tokenize(args->argv[argc-1]), S, ST);
}

