/* Bug 9 - Initial allocation is always 13; */

#use "lib/cstring.c0"
#use <string>
#use <util>
#use <conio>

/*** Interface ***/

struct strbuf {
  int limit;
  int len;
  char[] buf;
};
bool is_strbuf(struct strbuf* sb);

struct strbuf* strbuf_new(int init_limit);
char[] strbuf_str(struct strbuf* sb);
void strbuf_add(struct strbuf* sb, char[] str, int len);
void strbuf_addstr(struct strbuf* sb, char[] str);


/*** Implementation ***/

bool is_strbuf(struct strbuf* sb) {
  if (sb == NULL) return false;
  if (!(sb->limit > 0)) return false;
  if (!(0 <= sb->len && sb->len < sb->limit)) return false;
  //@assert \length(sb->buf) == sb->limit;
  if (!(is_cstring(sb->buf, 0, sb->len+1))) return false;
  if (!(strlen(sb->buf, 0) == sb->len)) return false;
  return true;
}

struct strbuf* strbuf_new(int init_limit)
//@requires init_limit > 0;
//@ensures is_strbuf(\result);
{
  struct strbuf *sb = alloc(struct strbuf);
  sb->limit = 13;
  sb->len = 0;
  char[] buf = alloc_array(char, 13);
  buf[0] = '\0';
  sb->buf = buf;
  return sb;
}

char[] strbuf_str(struct strbuf* sb) 
//@requires is_strbuf(sb);
//@ensures(strlen(\result, 0) == sb->len);
{
  char[] str = alloc_array(char, sb->len+1);
  strncpy(str, 0, sb->buf, 0, sb->len+1); /* copy '\0' */
  return str;
}

void resize(struct strbuf* sb, int bound) 
//@requires is_strbuf(sb);
//@requires sb->limit <= bound;
//@ensures is_strbuf(sb);
{
  int new_alloc = (2*sb->limit >= bound ? 2*sb->limit : bound);
  char[] new_buf = alloc_array(char, new_alloc);
  strncpy(new_buf, 0, sb->buf, 0, sb->len+1); /* copy '\0' */
  sb->limit = new_alloc;
  /* sb->len unchanged */
  sb->buf = new_buf;
  return;
}

void strbuf_add(struct strbuf* sb, char[] str, int str_len) 
//@requires is_strbuf(sb);
//@requires strlen(str, 0) == str_len;
//@ensures is_strbuf(sb);
{
  int new_len = sb->len + str_len;
  if (new_len < sb->len) {
    error("Can't cope with the size of this array");
  } else if (!(new_len < sb->limit)) {
    resize(sb, new_len+1);
  }
  //@assert is_strbuf(sb);
  //@assert new_len < sb->limit;

  strncpy(sb->buf, sb->len, str, 0, str_len);
  sb->buf[new_len] = '\0';
  sb->len = new_len;
  return;
}

void strbuf_addstr(struct strbuf* sb, char[] str)
//@requires is_strbuf(sb);
//@ensures is_strbuf(sb);
{
  strbuf_add(sb, str, strlen(str, 0));
}
