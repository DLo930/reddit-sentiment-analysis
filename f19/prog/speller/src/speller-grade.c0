// [speller] grader

#use <conio>
#use <args>
#use <string>
#use "lib/arrayutil.c0"
#use "lib/readfile.c0"


/* Obfuscated solution */

// function that performs a binary search on an array of strings
int sekret_obfuscate_binsearch(string[] A, int n, string e)
//@requires \length(A) == n;
//@requires is_sorted(A,0,n);
/*@ensures (-1 == \result && !is_in(e, A, 0, n))
        || (0 <= \result && \result < n
            && string_compare(A[\result], e) == 0);
@*/
{
  int lo = 0;
  int hi = n;
  while (lo < hi)
  //@loop_invariant 0 <= lo && hi <= n;
  //@loop_invariant lo == 0 || string_compare(A[lo-1], e) == -1;
  //@loop_invariant hi == n || string_compare(e, A[hi]) == -1;
  {
     int mid = lo + (hi - lo)/2;
     int comp = string_compare(A[mid], e);

     if (comp == 0)
         return mid;
     else if (comp < 0)
         lo = mid + 1;
     else
         hi = mid;
  }

  return -1;
}


// function that merges two sorted segments removing duplicates
// returns the number of array elements without duplicates
int sekret_obfuscate_merge(string[] A, int lo1, int hi1, int lo2, int hi2)
//@requires 0 <= lo1 && lo1 < hi1 && hi1 <= lo2 && lo2 < hi2 && hi2 <= \length(A);
//@requires is_sorted(A, lo1, hi1) && is_sorted(A, lo2, hi2);
//@requires no_dupes(A, lo1, hi1) && no_dupes(A, lo2, hi2);
//@ensures is_sorted(A, lo1, lo1 + \result);
//@ensures no_dupes(A, lo1, lo1 + \result);
//@ensures 0 <= \result && \result <= hi2 - lo1;
{
   // total interval of things we care about
   int interval = (hi1 - lo1) + (hi2 - lo2);

   // Allocate a temporary array
   string[] B = alloc_array(string, interval);

   int i = lo1;   // i ranges over the  first array interval [lo1,hi1)
   int j = lo2;   // j ranges over the second array interval [lo2,hi2)
   int k = 0;     // k ranges over [0, interval)

   while (i < hi1 && j < hi2)
     //@loop_invariant lo1 <= i && i <= hi1;
     //@loop_invariant lo2 <= j && j <= hi2;
     {
       int cmp = string_compare(A[i], A[j]);
       // if have duplicate words, we want to collapse them
       if (cmp == 0) {  // take one of them but increment both indices
         B[k] = A[i];
         i++;
         j++;
       }

       else if (cmp < 0) {   // usual mergesort code
         B[k] = A[i];
         i++;
       }
       else {
         B[k] = A[j];
         j++;
       }

       k++;
     }

   while (i < hi1)  // if j == hi2, copy rest of first interval
     //@loop_invariant lo1 <= i && i <= hi1;
     {
       B[k] = A[i];
       i++;
       k++;
     }

   while (j < hi2)  // if i == hi1, copy rest of second interval
     //@loop_invariant lo1 <= j && j <= hi2;
     {
       B[k] = A[j];
       j++;
       k++;
     }

   // copy the k nonduplicates back into A
   for (int m = 0; m < k; m++)
   //@loop_invariant lo1 <= lo1 + m && lo1 + m <= hi2;
   //@loop_invariant 0 <= m && m <= interval;
       A[lo1 + m] = B[m];

   return k;
}


// function that sorts an array of strings and removed duplicates
// returns the number of elements with the duplicates removed
int sekret_obfuscate_mergesort (string[] A, int lo, int hi)
//@requires 0 <= lo && lo <= hi && hi <= \length(A);
//@ensures is_sorted(A, lo, lo + \result);
//@ensures no_dupes(A, lo, lo + \result);
//@ensures 0 <= \result && \result <= hi - lo;
{
  // array of size <= 1, no duplicates to remove
  if (hi - lo <= 1)
    return (hi - lo);

  int mid = lo + (hi - lo)/2;

  // keep a running total of the array elements without duplicates
  int elts1 =  sekret_obfuscate_mergesort(A, lo, mid);
  int elts2 =  sekret_obfuscate_mergesort(A, mid, hi);

  // set the new upper bounds
  int hi1 = lo + elts1;
  int hi2 = mid + elts2;

  // call the merge with the new bounds
  int elts3 = sekret_obfuscate_merge(A, lo, hi1, mid, hi2);

  return elts3;
}


// just does a binary search for a given string in the dictionary
bool sekret_obfuscate_check_word(string[] dict, int d, string w)
//@requires \length(dict) == d;
//@requires is_sorted(dict,0,d);
//@requires no_dupes(dict,0,d);
//@ensures \result == true ? is_in(w,dict,0,d) : !is_in(w,dict,0,d);
{
  return sekret_obfuscate_binsearch(dict, d, w) >= 0;
}


// we give them a sorted dictionary and some text to spell check against it
// returns the number of mispelled words and populates the mispelled array
int sekret_obfuscate_check_text_naive(string[] dict, int d, string[] text, int t, string[] miss)
//@requires \length(dict) == d;
//@requires \length(text) == t;
//@requires \length(miss) >= t;
//@requires is_sorted(dict,0,d) && no_dupes(dict,0,d);
//@ensures 0 <= \result && \result <= t;
//@ensures no_dupes(miss, 0, \result);
{
  int m = 0;                         // Number of mispelled words

  // check every word in the (no duplicates) text array
  for (int j = 0; j < t; j++)
  //@loop_invariant 0 <= j && j <= t;
  //@loop_invariant 0 <= m && m <= t;
  {
    if (!sekret_obfuscate_check_word(dict, d, text[j])     // the word was NOT found
        && !is_in(text[j], miss, 0, m)) { // and it was not recorded before
      miss[m] = text[j];                  // add to misspelled words
      m++;                                // increment the mispelled counter
    }
  }

  return m;
}


int sekret_obfuscate_check_sorted_text(string[] dict, int d, string[] text, int t, string[] miss)
//@requires \length(dict) == d;
//@requires \length(text) >= t;
//@requires \length(miss) >= t;
//@requires is_sorted(dict, 0, d) && no_dupes(dict, 0, d);
//@requires is_sorted(text, 0, t) && no_dupes(text, 0, t);
//@ensures 0 <= \result && \result <= t;
//@ensures is_sorted(miss, 0, \result) && no_dupes(miss, 0, \result);
{
  int i = 0;  // range over (sorted) dictionary -- [0, d)
  int j = 0;  // range over sorted text -- [0, t)
  int m = 0;  // number of mispelled words -- range over [0, t)

// don't search through the duplicates
  while (i < d && j < t)
  //@loop_invariant 0 <= i && i <= d;
  //@loop_invariant 0 <= j && j <= t;
  //@loop_invariant 0 <= m && m <= t;
  {
    int cmp = string_compare(text[j], dict[i]);
    if (cmp > 0)         // need to look farther in the dictionary for this word
       i++;
    else if (cmp < 0) {  // we've passed this word
      miss[m] = text[j]; // add to misspelled words
      m++;               // word is misspelled
      j++;               // move to next text word
    }
    else {               // this means text[j] == dict[i]
      i++;               // move both indices forward
      j++;
    }
  }
  // ran out of dictionary words
  while (j < t) {
    miss[m] = text[j]; // add to misspelled words
    m++;               // word is misspelled
    j++;               // move to next text word
  }

  return m;
}


// we give them a sorted dictionary and some text to spell check against it
// returns the number of mispelled words and populates the mispelled array
int sekret_obfuscate_check_text_better(string[] dict, int d, string[] text, int t, string[] miss)
//@requires \length(dict) == d;
//@requires \length(text) == t;
//@requires \length(miss) >= t;
//@requires is_sorted(dict,0,d) && no_dupes(dict,0,d);
//@ensures 0 <= \result && \result <= t;
//@ensures no_dupes(miss, 0, \result);
{
  int t_nd = sekret_obfuscate_mergesort(text, 0, t);
  int m = sekret_obfuscate_check_sorted_text(dict, d, text, t_nd, miss);

  return m;
}


/* Helper functions */

typedef struct words_header words;
struct words_header {
  string[] w;  // words
  int      l;  // length
  string[] m;  // mispelled array,  if needed
};

// Reads a dictionary from file
words* read_dict(string fname) {
  bundle_t bundle = read_words(fname);
  words* dict = alloc(words);
  dict->w = string_bundle_array(bundle);
  dict->l = string_bundle_length(bundle);
  return dict;
}

// Reads a text from file
words* read_text(string fname) {
  bundle_t bundle = read_words(fname);
  words* text = alloc(words);
  text->w = string_bundle_array(bundle);
  text->l = string_bundle_length(bundle);
  text->m = alloc_array(string, text->l);
  return text;
}


// Do student and reference check_word agree on a word?
bool eq_word_to_ours(words* D, string w) {
  return check_word(D->w, D->l, w) == sekret_obfuscate_check_word(D->w, D->l, w);
}

// Determine if an argument starts with "fast"
string dispatch_arg(string arg, bool* fast) {
  if (string_equal(string_sub(arg, 0, 4), "fast")) {
    *fast = true;
    return string_sub(arg, 4, string_length(arg));
  }
  *fast = false;
  return arg;
}

// Call either check_text_naive or check_text_better
int test1text(string[] dict, int d, string[] text, int t, string[] miss,
              bool fast) {
  if (fast)
    return check_text_better(dict, d, text, t, miss);
  return check_text_naive(dict, d, text, t, miss);
}

// Do student and reference check_text_naive/check_text_better agree on a text?
bool cmp_spell_to_ours(string dict, string text, int version) {
  int naive  = 0;
  int better = 1;
  int sorted = 2;

  words* D = read_dict(dict);
  words* T1 = read_text(text);
  words* T2 = read_text(text);

  int m1;
  int m2;

  if (version == naive) {
    m1 = check_text_naive(D->w, D->l, T1->w, T1->l, T1->m);
    m2 = sekret_obfuscate_check_text_naive(D->w, D->l, T2->w, T2->l, T2->m);
  } else if (version == better) {
    m1 = check_text_better(D->w, D->l, T1->w, T1->l, T1->m);
    m2 = sekret_obfuscate_check_text_better(D->w, D->l, T2->w, T2->l, T2->m);
  } else { //@assert version == sorted;
    m1 = check_sorted_text(D->w, D->l, T1->w, T1->l, T1->m);
    m2 = sekret_obfuscate_check_sorted_text(D->w, D->l, T2->w, T2->l, T2->m);
  }

  if (m1 != m2)  return false;                            // length differ
  int l1 = sekret_obfuscate_mergesort(T1->m, 0, m1);
  int l2 = sekret_obfuscate_mergesort(T2->m, 0, m2);
  if (l1 != l2)  return false;
  for (int i = 0; i < l1; i++)
    if (!string_equal(T1->m[i], T2->m[i]))  return false; // words differ

  return true;
}

// do student and reference merge produce the same array?
bool cmp_merge_to_ours(string text, int lo1, int hi1, int lo2, int hi2) {
  words* D1 = read_dict(text);
  words* D2 = read_dict(text);
  if (lo1 < 0) lo1 = 0;
  if (hi1 < 0) hi1 = D1->l/2;
  if (lo2 < 0) lo2 = D1->l/2;
  if (hi2 < 0) hi2 = D1->l;

           sekret_obfuscate_mergesort(D1->w, lo1, hi1);
  int l1 = sekret_obfuscate_mergesort(D2->w, lo1, hi1);
           sekret_obfuscate_mergesort(D1->w, lo2, hi2);
  int l2 = sekret_obfuscate_mergesort(D2->w, lo2, hi2);

  int n1 = merge(D1->w, lo1, lo1+l1, lo2, lo2+l2);
  int n2 = sekret_obfuscate_merge(D2->w, lo1, lo1+l1, lo2, lo2+l2);

  if (n1 != n2)  return false;
  for (int i = 0; i < n2; i++)
    if (!string_equal(D1->w[i], D2->w[i]))  return false;

  return true;
}

// do student and reference mergesort produce the same array?
bool cmp_msort_to_ours(string text, int lo, int hi) {
  words* D1 = read_dict(text);
  words* D2 = read_dict(text);
  if (lo < 0) lo = 0;
  if (hi < 0) hi = D1->l;

  int n1 = mergesort(D1->w, lo, hi);
  int n2 = sekret_obfuscate_mergesort(D2->w, lo, hi);

  if (n1 != n2)  return false;
  for (int i = 0; i < n2; i++)
    if (!string_equal(D1->w[i], D2->w[i]))  return false;

  return true;
}

/* Testing functions */

bool test_check_word(string arg) {

// Checking if preconditions are met

  if (string_equal(arg, "cw-prec1a")) { // \length(dict) == d
    words* D = read_dict("texts/small-dict.txt");
    check_word(D->w, D->l + 42, "WhatEveR");
    return false;
  }
  if (string_equal(arg, "cw-prec1b")) { // \length(dict) == d
    words* D = read_dict("texts/small-dict.txt");
    check_word(D->w, -1, "WhatEveR");
    return false;
  }
  if (string_equal(arg, "cw-prec2")) { // is_sorted(dict, 0, d)
    words* D = read_dict("texts/unsorted-dict.txt");
    check_word(D->w, D->l, "WhatEveR");
    return false;
  }
  if (string_equal(arg, "cw-prec3")) { // no_dupes(dict, 0, d)
    words* D = read_dict("texts/dup-dict.txt");
    check_word(D->w, D->l, "WhatEveR");
    return false;
  }

// Checking functionality on small example (Scott Harbaugh's tweet)

  if (string_equal(arg, "cw-scott1")) { // Can find one word
    words* D = read_dict("texts/scott-dict.txt");
    if (!check_word(D->w, D->l, "burrow"))
      return false;
  }

  if (string_equal(arg, "cw-scott2")) { // Complete: finds all words
    words* D = read_dict("texts/scott-dict.txt");
    if (   !check_word(D->w, D->l, "phil")
        || !check_word(D->w, D->l, "is")
        || !check_word(D->w, D->l, "out")
        || !check_word(D->w, D->l, "of")
        || !check_word(D->w, D->l, "his")
        || !check_word(D->w, D->l, "burrow"))
      return false;
  }

  if (string_equal(arg, "cw-scott3")) { // Sound: Does not find absent words
    words* D = read_dict("texts/scott-dict.txt");
    if (   check_word(D->w, D->l, "punxsutawney")
        || check_word(D->w, D->l, "Phil") // uppercase
        || check_word(D->w, D->l, "scott")
        || check_word(D->w, D->l, "Harbaugh")
        || check_word(D->w, D->l, "phill") // extension
        || check_word(D->w, D->l, "phi")  // prefix
        || check_word(D->w, D->l, "h")  // middle
        || check_word(D->w, D->l, "hil")) // suffix
      return false;
  }

// Checking functionality on medium example (medium-dict)

  if (string_equal(arg, "cw-sloth1")) { // finds present words
    words* D = read_dict("texts/small-dict.txt");
    if (   !check_word(D->w, D->l, "metabolic")
        || !check_word(D->w, D->l, "predators")
        || !check_word(D->w, D->l, "sloths")
        || !check_word(D->w, D->l, "sloth")
        || !check_word(D->w, D->l, "adaptations")
        || !check_word(D->w, D->l, "idleness"))
      return false;
  }

  if (string_equal(arg, "cw-sloth2")) { // does not find absent words
    words* D = read_dict("texts/small-dict.txt");
    if (   check_word(D->w, D->l, "energie")
        || check_word(D->w, D->l, "idlleness")
        || check_word(D->w, D->l, "algee")
        || check_word(D->w, D->l, "scott")
        || check_word(D->w, D->l, "Harbaugh")
        || check_word(D->w, D->l, "Sloths") // uppercase
        || check_word(D->w, D->l, "named after") // multiple words
        || check_word(D->w, D->l, "anna")
        || check_word(D->w, D->l, "hannah"))
      return false;
  }

// Checking functionality on large example (dict)

  if (string_equal(arg, "cw-large")) { // behaves correctly on large dictionary
    words* D = read_dict("texts/dict.txt");
    if (   !eq_word_to_ours(D, "rose")
        || !eq_word_to_ours(D, "sloth")
        || !eq_word_to_ours(D, "chihuahua")
        || !eq_word_to_ours(D, "chiwawa")
        || !eq_word_to_ours(D, "facebook")
        || !eq_word_to_ours(D, "x")
        || !eq_word_to_ours(D, "einstein")
        || !eq_word_to_ours(D, "farfalla")
        || !eq_word_to_ours(D, "praslin")
        || !eq_word_to_ours(D, "sesel"))
    return false;
  }

// Checking corner cases
  if (string_equal(arg, "cw-empty")) {   // empty string
    words* D = read_dict("texts/scott-dict.txt");
    if (check_word(D->w, D->l, "")) return false;
  }
  if (string_equal(arg, "cw-number")) {   // numbers
    words* D = read_dict("texts/small-dict.txt");
    if (   check_word(D->w, D->l, "0")
        || check_word(D->w, D->l, "122")) return false;
  }
  if (string_equal(arg, "cw-class")) {   // class
    words* D = read_dict("texts/small-dict.txt");
    if (   check_word(D->w, D->l, "15-122")
        || check_word(D->w, D->l, "15-112")) return false;
  }
  if (string_equal(arg, "cw-nonalpha")) {   // Non-word characters
    words* D = read_dict("texts/small-dict.txt");
    if (   check_word(D->w, D->l, "@#$%") // garbage
        || check_word(D->w, D->l, "\n")   // new line
        || check_word(D->w, D->l, " "))   // space
      return false;
  }
  if (string_equal(arg, "cw-none")) {   // empty dictionary
    words* D = read_dict("texts/empty-dict.txt");
    if (   check_word(D->w, D->l, "the")  // Valid but not present
        || check_word(D->w, D->l, ""))    // empty string
      return false;
  }

  // Couldn't find anything wrong
  return true;
}

bool test_merge(string arg) {

// Checking if preconditions are met
  if (string_equal(arg, "merge-prec1a")) { // 0 <= lo1
    words* D = read_dict("texts/scott-dict.txt");
    merge(D->w, -5, 0, D->l/2, D->l);
    return false;
  }
  if (string_equal(arg, "merge-prec1b")) { // lo1 < hi1
    words* D = read_dict("texts/scott-dict.txt");
    merge(D->w, 1, 0, D->l/2, D->l);
    return false;
  }
  if (string_equal(arg, "merge-prec1bb")) { // lo1 < hi1
    words* D = read_dict("texts/scott-dict.txt");
    merge(D->w, 0, 0, D->l/2, D->l);
    return false;
  }
  if (string_equal(arg, "merge-prec1c")) { // hi1 <= lo2
    words* D = read_dict("texts/scott-dict.txt");
    merge(D->w, 0, D->l/2, 1, D->l);
    return false;
  }
  if (string_equal(arg, "merge-prec1d")) { // lo2 < hi2
    words* D = read_dict("texts/scott-dict.txt");
    merge(D->w, 0, 1, D->l, D->l/2);
    return false;
  }
  if (string_equal(arg, "merge-prec1dd")) { // lo2 < hi2
    words* D = read_dict("texts/scott-dict.txt");
    merge(D->w, 0, 1, D->l, D->l);
    return false;
  }
  if (string_equal(arg, "merge-prec1e")) { // hi2 <= \length(A)
    words* D = read_dict("texts/scott-dict.txt");
    merge(D->w, 0, 1, D->l/2, D->l + 5);
    return false;
  }
  if (string_equal(arg, "merge-prec2")) { // is_sorted(A, lo1, hi1)
    words* D = read_dict("texts/scott-tweet.txt");
    int hi2 = sekret_obfuscate_mergesort(D->w, D->l/2, D->l);
    merge(D->w, 0, D->l/2, D->l/2, hi2);
    return false;
  }
  if (string_equal(arg, "merge-prec3")) { // no_dupes(A, lo1, hi1)
    words* D = read_dict("texts/1000a.txt");
    merge(D->w, 0, 2, 2, 3);
    return false;
  }
  if (string_equal(arg, "merge-prec4")) { // is_sorted(A, lo2, hi2)
    words* D = read_dict("texts/scott-tweet.txt");
    int hi1 = sekret_obfuscate_mergesort(D->w, 0, D->l/2);
    merge(D->w, 0, hi1, D->l/2, D->l);
    return false;
  }
  if (string_equal(arg, "merge-prec5")) { // no_dupes(A, lo2, hi2)
    words* D = read_dict("texts/1000a.txt");
    merge(D->w, 0, 1, 1, 3);
    return false;
  }

// Checking for correctness on small/medium examples

  if (string_equal(arg, "merge-small")) {
    if (   !cmp_merge_to_ours("texts/scott-tweet-thrice.txt", -1, -1, -1, -1)
        || !cmp_merge_to_ours("texts/scott-tweet-thrice.txt", 0, 1, 2, -1)
        || !cmp_merge_to_ours("texts/scott-tweet-thrice.txt", 0, 4, 4, -1)
        || !cmp_merge_to_ours("texts/scott-tweet.txt", -1, -1, -1, -1)  // no dups
        || !cmp_merge_to_ours("texts/scott-dict.txt", -1, -1, -1, -1)   // sorted
        )
      return false;
  }
  if (string_equal(arg, "merge-medium")) {
    if (   !cmp_merge_to_ours("texts/sloth.txt", -1, -1, -1, -1)
        || !cmp_merge_to_ours("texts/100.txt", -1, -1, -1, -1)
        || !cmp_merge_to_ours("texts/letter.txt", -1, -1, -1, -1)
        || !cmp_merge_to_ours("texts/unsorted-dict.txt", -1, -1, -1, -1) // no dups
        || !cmp_merge_to_ours("texts/1000a.txt", -1, -1, -1, -1)         // sorted, dups
        || !cmp_merge_to_ours("texts/1000a.txt", 0, 122, 122, -1)        // sorted, dups
        || !cmp_merge_to_ours("texts/1000a.txt", 0, 100, 700, -1)        // sorted, dups
        || !cmp_merge_to_ours("texts/small-dict.txt", -1, -1, -1, -1)    // sorted
        )
      return false;
  }

// Stress test on large examples

  if (string_equal(arg, "merge-large")) {
    if (   !cmp_merge_to_ours("texts/sonnets.txt", -1, -1, -1, -1)
        || !cmp_merge_to_ours("texts/shakespeare.txt", -1, -1, -1, -1)
        || !cmp_merge_to_ours("texts/shakespeare.txt", -1, 3, 3, 5)
        || !cmp_merge_to_ours("texts/shakespeare.txt", -1, 3, 1000, 1010)
        || !cmp_merge_to_ours("texts/shakespeare.txt", -1, 100000, 500000, -1)
        || !cmp_merge_to_ours("texts/shakespeare-GutenburgCopyright.txt", -1, -1, -1, -1)
        || !cmp_merge_to_ours("texts/shakespeare-sorted.txt", -1, -1, -1, -1) // no dups
        || !cmp_merge_to_ours("texts/dict.txt", -1, -1, -1, -1)    // sorted
        )
      return false;
  }

// Checking corner cases

  if (string_equal(arg, "ms-singleton")) {   // singleton arrays
    if (   !cmp_merge_to_ours("texts/scott-dict.txt", 0, 1, 1, 6)
        || !cmp_merge_to_ours("texts/scott-dict.txt", 0, 1, 1, 3)
        || !cmp_merge_to_ours("texts/scott-dict.txt", 1, 2, 2, 3)
        || !cmp_merge_to_ours("texts/scott-dict.txt", 1, 2, 3, 4)
        || !cmp_merge_to_ours("texts/scott-dict.txt", 0, 5, 5, 6)
        || !cmp_merge_to_ours("texts/1000a.txt", 1, 2, 2, 3)
        || !cmp_merge_to_ours("texts/scott-tweet-thrice.txt", 0, 6, 6, -1)
       )
      return false;
  }

// Couldn't find anything wrong
  return true;
}

bool test_mergesort(string arg) {

// Checking if preconditions are met

  if (string_equal(arg, "ms-prec1")) { // 0 <= lo
    words* D = read_dict("texts/scott-dict.txt");
    mergesort(D->w, -5, D->l);
    return false;
  }
  if (string_equal(arg, "ms-prec2")) { // lo <= hi
    words* D = read_dict("texts/scott-dict.txt");
    mergesort(D->w, D->l, 0);
    return false;
  }
  if (string_equal(arg, "ms-prec3")) { // hi <= \length(A)
    words* D = read_dict("texts/scott-dict.txt");
    mergesort(D->w, 0, D->l + 5);
    return false;
  }

// Checking for correctness on small/medium examples

  if (string_equal(arg, "ms-small")) {
    if (   !cmp_msort_to_ours("texts/scott-tweet-thrice.txt", -1, -1)
        || !cmp_msort_to_ours("texts/scott-tweet.txt", -1, -1)  // no dups
        || !cmp_msort_to_ours("texts/scott-dict.txt", -1, -1)   // sorted
        )
      return false;
  }
  if (string_equal(arg, "ms-medium")) {
    if (   !cmp_msort_to_ours("texts/sloth.txt", -1, -1)
        || !cmp_msort_to_ours("texts/100.txt", -1, -1)
        || !cmp_msort_to_ours("texts/letter.txt", -1, -1)
        || !cmp_msort_to_ours("texts/unsorted-dict.txt", -1, -1) // no dups
        || !cmp_msort_to_ours("texts/1000a.txt", -1, -1)         // sorted, dups
        || !cmp_msort_to_ours("texts/small-dict.txt", -1, -1)    // sorted
        )
      return false;
  }

// Stress test on large examples

  if (string_equal(arg, "ms-large")) {
    if (   !cmp_msort_to_ours("texts/sonnets.txt", -1, -1)
        || !cmp_msort_to_ours("texts/shakespeare.txt", -1, -1)
        || !cmp_msort_to_ours("texts/shakespeare-GutenburgCopyright.txt", -1, -1)
        || !cmp_msort_to_ours("texts/shakespeare-sorted.txt", -1, -1) // no dups
        || !cmp_msort_to_ours("texts/dict.txt", -1, -1)    // sorted
        )
      return false;
  }

// Checking corner cases

  if (string_equal(arg, "ms-empty")) {   // empty array
    if (!cmp_msort_to_ours("texts/empty-dict.txt", -1, -1))
      return false;
  }
  if (string_equal(arg, "ms-singleton")) {   // singleton array
    if (!cmp_msort_to_ours("texts/1.txt", -1, -1))
      return false;
  }
  if (string_equal(arg, "ms-nowidth")) {   // empty slice of non-empty array
    if (   !cmp_msort_to_ours("texts/scott-dict.txt", 0, 0)
        || !cmp_msort_to_ours("texts/scott-dict.txt", 6, 6)
        || !cmp_msort_to_ours("texts/scott-dict.txt", 3, 3))
      return false;
  }

// Couldn't find anything wrong
  return true;
}

bool test_check_text_naive_or_better(string full_arg) {
  int naive  = 0;
  int better = 1;

  bool* fast = alloc(bool);
  string arg = dispatch_arg(full_arg, fast);

  int version = *fast ? better : naive;

// Checking if preconditions are met

  if (string_equal(arg, "spell-prec1")) { // \length(dict) == d
    words* D = read_dict("texts/small-dict.txt");
    words* T = read_text("texts/sloth.txt");
    test1text(D->w, D->l + 42, T->w, T->l, T->m, *fast);
    return false;
  }
  if (string_equal(arg, "spell-prec2")) { // \length(text) == t
    words* D = read_dict("texts/small-dict.txt");
    words* T = read_text("texts/scott-tweet.txt");
    words* T2 = read_text("texts/scott-tweet-thrice.txt");
    test1text(D->w, D->l, T->w, T2->l, T2->m, *fast);
    return false;
  }
  if (string_equal(arg, "spell-prec3")) { // \length(miss) >= t
    words* D = read_dict("texts/small-dict.txt");
    words* T = read_text("texts/scott-tweet-thrice.txt");
    words* T2 = read_text("texts/scott-tweet.txt");
    test1text(D->w, D->l, T->w, T->l, T2->m, *fast);
    return false;
  }
  if (string_equal(arg, "spell-prec4")) { // is_sorted(dict, 0, d)
    words* D = read_dict("texts/unsorted-dict.txt");
    words* T = read_text("texts/scott-tweet.txt");
    test1text(D->w, D->l, T->w, T->l, T->m, *fast);
    return false;
  }
  if (string_equal(arg, "spell-prec5")) { // no_dupes(dict, 0, d)
    words* D = read_dict("texts/dup-dict.txt");
    words* T = read_text("texts/scott-tweet.txt");
    test1text(D->w, D->l, T->w, T->l, T->m, *fast);
    return false;
  }

// Checking for correctness on small/medium examples

  if (string_equal(arg, "spell-small")) {
    if (   !cmp_spell_to_ours("texts/scott-dict.txt", "texts/scott-tweet.txt", version)
        || !cmp_spell_to_ours("texts/scott-dict.txt", "texts/scott-tweet-thrice.txt", version))
      return false;
  }
  if (string_equal(arg, "spell-medium")) {
    if (!cmp_spell_to_ours("texts/small-dict.txt", "texts/sloth.txt", version))
      return false;
  }

// Stress test on large texts/dictionaries

  if (string_equal(arg, "spell-large-dict")) {
    if (!cmp_spell_to_ours("texts/dict.txt", "texts/scott-tweet.txt", version))
      return false;
  }
  if (string_equal(arg, "spell-large-text")) {
    if (!cmp_spell_to_ours("texts/scott-dict.txt", "texts/shakespeare.txt", version))
      return false;
  }
  if (string_equal(arg, "spell-large")) {
    if (!cmp_spell_to_ours("texts/dict.txt", "texts/shakespeare.txt", version))
      return false;
  }

// Check for soundness (dictionary on itself)

  if (string_equal(arg, "spell-self-small")) {
    if (!cmp_spell_to_ours("texts/scott-dict.txt", "texts/scott-dict.txt", version))
      return false;
  }
  if (string_equal(arg, "spell-self-medium")) {
    if (!cmp_spell_to_ours("texts/small-dict.txt", "texts/small-dict.txt", version))
      return false;
  }
  if (string_equal(arg, "spell-self-large")) {
    if (!cmp_spell_to_ours("texts/dict.txt", "texts/dict.txt", version))
      return false;
  }

// Tests for corner cases
  if (string_equal(arg, "spell-dict0")) { // Empty dictionary
    if (!cmp_spell_to_ours("texts/empty-dict.txt", "texts/scott-tweet.txt", version))
      return false;
  }
  if (string_equal(arg, "spell-dict1")) { // Dictionary with 1 word
    if (!cmp_spell_to_ours("texts/1.txt", "texts/scott-tweet.txt", version))
      return false;
  }
  if (string_equal(arg, "spell-text0")) {  // Empty text
    if (!cmp_spell_to_ours("texts/small-dict.txt", "texts/empty.txt", version))
      return false;
  }
  if (string_equal(arg, "spell-text1")) { // Text with 1 word
    if (!cmp_spell_to_ours("texts/small-dict.txt", "texts/1.txt", version))
      return false;
  }

// Tests for speed
  if (string_equal(arg, "spell-speed")) {
    words* D = read_dict("texts/dict.txt");
//    words* T = read_text("texts/shakespeare.txt");
    words* T = read_text("texts/empty.txt");
    test1text(D->w, D->l, T->w, T->l, T->m, *fast);
    return true;
  }

  // Couldn't find anything wrong
  return true;
}

bool test_check_sorted_text(string arg) {
  int sorted = 2;

// Checking if preconditions are met

  if (string_equal(arg, "sorted-spell-prec1")) { // \length(dict) == d
    words* D = read_dict("texts/small-dict.txt");
    words* T = read_text("texts/sloth-sorted-nodupes.txt");
    check_sorted_text(D->w, D->l + 42, T->w, T->l, T->m);
    return false;
  }
  if (string_equal(arg, "sorted-spell-prec2")) { // \length(text) == t
    words* D = read_dict("texts/small-dict.txt");
    words* T = read_text("texts/scott-dict.txt");
    words* T2 = read_text("texts/scott-tweet-thrice.txt");
    check_sorted_text(D->w, D->l, T->w, T2->l, T2->m);
    return false;
  }
  if (string_equal(arg, "sorted-spell-prec3")) { // \length(miss) >= t
    words* D = read_dict("texts/small-dict.txt");
    words* T = read_text("texts/sloth-sorted-nodupes.txt");
    words* T2 = read_text("texts/scott-tweet.txt");
    check_sorted_text(D->w, D->l, T->w, T->l, T2->m);
    return false;
  }
  if (string_equal(arg, "sorted-spell-prec4")) { // is_sorted(dict, 0, d)
    words* D = read_dict("texts/unsorted-dict.txt");
    words* T = read_text("texts/scott-dict.txt");
    check_sorted_text(D->w, D->l, T->w, T->l, T->m);
    return false;
  }
  if (string_equal(arg, "sorted-spell-prec5")) { // no_dupes(dict, 0, d)
    words* D = read_dict("texts/dup-dict.txt");
    words* T = read_text("texts/scott-dict.txt");
    check_sorted_text(D->w, D->l, T->w, T->l, T->m);
    return false;
  }
  if (string_equal(arg, "sorted-spell-prec6")) { // is_sorted(text, 0, t)
    words* D = read_dict("texts/small-dict.txt");
    words* T = read_text("texts/scott-tweet.txt");
    check_sorted_text(D->w, D->l, T->w, T->l, T->m);
    return false;
  }
  if (string_equal(arg, "sorted-spell-prec7")) { // no_dupes(text, 0, t)
    words* D = read_dict("texts/small-dict.txt");
    words* T = read_text("texts/sloth-sorted.txt");
    check_sorted_text(D->w, D->l, T->w, T->l, T->m);
    return false;
  }

// Checking for correctness on small/medium examples

  if (string_equal(arg, "sorted-spell-small")) {
    if (   !cmp_spell_to_ours("texts/scott-dict.txt", "texts/1.txt", sorted)
        || !cmp_spell_to_ours("texts/scott-dict.txt", "texts/sloth-sorted-nodupes.txt", sorted))
      return false;
  }
  if (string_equal(arg, "sorted-spell-medium")) {
    if (!cmp_spell_to_ours("texts/small-dict.txt", "texts/sloth-sorted-nodupes.txt", sorted))
      return false;
  }

// Stress test on large texts/dictionaries

  if (string_equal(arg, "sorted-spell-large-dict")) {
    if (!cmp_spell_to_ours("texts/dict.txt", "texts/scott-dict.txt", sorted))
      return false;
  }
  if (string_equal(arg, "sorted-spell-large-text")) {
    if (!cmp_spell_to_ours("texts/scott-dict.txt", "texts/shakespeare-sorted-nodupes.txt", sorted))
      return false;
  }
  if (string_equal(arg, "sorted-spell-large")) {
    if (!cmp_spell_to_ours("texts/dict.txt", "texts/shakespeare-sorted-nodupes.txt", sorted))
      return false;
  }

// Check for soundness (dictionary on itself)

  if (string_equal(arg, "sorted-spell-self-small")) {
    if (!cmp_spell_to_ours("texts/scott-dict.txt", "texts/scott-dict.txt", sorted))
      return false;
  }
  if (string_equal(arg, "sorted-spell-self-medium")) {
    if (!cmp_spell_to_ours("texts/small-dict.txt", "texts/small-dict.txt", sorted))
      return false;
  }
  if (string_equal(arg, "sorted-spell-self-large")) {
    if (!cmp_spell_to_ours("texts/dict.txt", "texts/dict.txt", sorted))
      return false;
  }

// Tests for corner cases
  if (string_equal(arg, "sorted-spell-dict0")) { // Empty dictionary
    if (!cmp_spell_to_ours("texts/empty-dict.txt", "texts/scott-dict.txt", sorted))
      return false;
  }
  if (string_equal(arg, "sorted-spell-dict1")) { // Dictionary with 1 word
    if (!cmp_spell_to_ours("texts/1.txt", "texts/scott-dict.txt", sorted))
      return false;
  }
  if (string_equal(arg, "sorted-spell-text0")) {  // Empty text
    if (!cmp_spell_to_ours("texts/small-dict.txt", "texts/empty.txt", sorted))
      return false;
  }
  if (string_equal(arg, "sorted-spell-text1")) { // Text with 1 word
    if (!cmp_spell_to_ours("texts/small-dict.txt", "texts/1.txt", sorted))
      return false;
  }

  // Couldn't find anything wrong
  return true;
}

int main() {
  args_t args = args_parse();
  if (args->argc != 1) error("Wrong number of args");
  string arg = args->argv[0];

  if (!test_check_word(arg))                  return 1;
  if (!test_merge(arg))                       return 1;
  if (!test_mergesort(arg))                   return 1;
  if (!test_check_text_naive_or_better(arg))  return 1;
  if (!test_check_sorted_text(arg))           return 1;


  return 0;
}
