// check_text_better: checks only second half of the text

#use <conio>
#use <args>
#use <string>
#use "lib/arrayutil.c0"
#use "lib/readfile.c0"


// function that merges two sorted segments removing duplicates
// returns the number of array elements without duplicates
int merge(string[] A, int lo1, int hi1, int lo2, int hi2)
//@requires 0 <= lo1 && lo1 < hi1 && hi1 <= lo2 && lo2 < hi2 && hi2 <= \length(A);
//@requires is_sorted(A, lo1, hi1) && no_dupes(A, lo1, hi1);
//@requires is_sorted(A, lo2, hi2) && no_dupes(A, lo2, hi2);
//@ensures 0 <= \result && \result <= hi2 - lo1;
//@ensures is_sorted(A, lo1, lo1 + \result);
//@ensures no_dupes(A, lo1, lo1 + \result);
{
   // total interval of things we care about
   int interval = (hi1 - lo1) + (hi2 - lo2);

   // Allocate a temporary array
   string[] B = alloc_array(string, interval);

   int i = lo1;   // i ranges over the  first array interval [lo1,hi1)
   int j = lo2;   // j ranges over the second array interval [lo2,hi2)
   int k = 0;     // k ranges over [0, interval)

   while (i < hi1 && j < hi2)
     //@loop_invariant lo1 <= i && i <= hi1;
     //@loop_invariant lo2 <= j && j <= hi2;
     {
       int cmp = string_compare(A[i], A[j]);
       // if have duplicate words, we want to collapse them
       if (cmp == 0) {  // take one of them but increment both indices
         B[k] = A[i];
         i++;
         j++;
       }

       else if (cmp < 0) {   // usual mergesort code
         B[k] = A[i];
         i++;
       }
       else {
         B[k] = A[j];
         j++;
       }

       k++;
     }

   while (i < hi1)  // if j == hi2, copy rest of first interval
     //@loop_invariant lo1 <= i && i <= hi1;
     {
       B[k] = A[i];
       i++;
       k++;
     }

   while (j < hi2)  // if i == hi1, copy rest of second interval
     //@loop_invariant lo1 <= j && j <= hi2;
     {
       B[k] = A[j];
       j++;
       k++;
     }

   // copy the k nonduplicates back into A
   for (int m = 0; m < k; m++)
   //@loop_invariant lo1 <= lo1 + m && lo1 + m <= hi2;
   //@loop_invariant 0 <= m && m <= interval;
       A[lo1 + m] = B[m];

   return k;
}


// function that sorts an array of strings and removed duplicates
// returns the number of elements with the duplicates removed
int mergesort (string[] A, int lo, int hi)
//@requires 0 <= lo && lo <= hi && hi <= \length(A);
//@ensures 0 <= \result && \result <= hi - lo;
//@ensures is_sorted(A, lo, lo + \result);
//@ensures no_dupes(A, lo, lo + \result);
{
  // array of size <= 1, no duplicates to remove
  if (hi - lo <= 1)
    return (hi - lo);

  int mid = lo + (hi - lo)/2;

  // keep a running total of the array elements without duplicates
  int elts1 =  mergesort(A, lo, mid);
  int elts2 =  mergesort(A, mid, hi);

  // set the new upper bounds
  int hi1 = lo + elts1;
  int hi2 = mid + elts2;

  // call the merge with the new bounds
  int elts3 = merge(A, lo, hi1, mid, hi2);

  return elts3;
}



// this is clever spellcheck implementation that exploits that both of the arrays can be sorted
// does a linear scan and does not call binary search
// returns the number of mispelled words and populates the mispelled array
int check_text_better(string[] dict, int d, string[] text, int t, string[] miss)
//@requires \length(dict) == d;
//@requires \length(text) == t;
//@requires \length(miss) >= t;
//@requires is_sorted(dict,0,d) && no_dupes(dict,0,d);
//@ensures 0 <= \result && \result <= t;
{
  int t_nd = mergesort(text, t/2, t);  // Remove duplicates from text

  int i = 0;  // range over (sorted) dictionary -- [0, d)
  int j = 0;  // range over sorted text -- [0, t_nd)
  int m = 0;  // number of mispelled words -- range over [0, t_nd)

// don't search through the duplicates
  while (i < d && j < t_nd)
  //@loop_invariant 0 <= i && i <= d;
  //@loop_invariant 0 <= j && j <= t_nd;
  //@loop_invariant 0 <= m && m <= t_nd;
  {
    int cmp = string_compare(text[j + t/2], dict[i]);
    if (cmp > 0)         // need to look farther in the dictionary for this word
       i++;
    else if (cmp < 0) {  // we've passed this word
      miss[m] = text[j]; // add to misspelled words
      m++;               // word is misspelled
      j++;               // move to next text word
    }
    else {               // this means text[j] == dict[i]
      i++;               // move both indices forward
      j++;
    }
  }
  // ran out of dictionary words
  while (j < t_nd) {
    miss[m] = text[j]; // add to misspelled words
    m++;               // word is misspelled
    j++;               // move to next text word
  }

  return m;
}
