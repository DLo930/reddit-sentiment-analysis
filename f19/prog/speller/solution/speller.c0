/* This is the reference solution for the speller assignment */

#use <conio>
#use <args>
#use <string>
#use "lib/arrayutil.c0"
#use "lib/readfile.c0"


// function that performs a binary search on an array of strings
int binsearch(string[] A, int n, string e)
//@requires \length(A) == n;
//@requires is_sorted(A,0,n);
/*@ensures (-1 == \result && !is_in(e, A, 0, n))
        || (0 <= \result && \result < n && string_equal(A[\result], e));
@*/
{
  int lo = 0;
  int hi = n;
  while (lo < hi)
  //@loop_invariant 0 <= lo && hi <= n;
  //@loop_invariant lo == 0 || string_compare(A[lo-1], e) == -1;
  //@loop_invariant hi == n || string_compare(e, A[hi]) == -1;
  {
     int mid = lo + (hi - lo)/2;
     int comp = string_compare(A[mid], e);

     if (comp == 0)
         return mid;
     else if (comp < 0)
         lo = mid + 1;
     else
         hi = mid;
  }

  return -1;
}


// function that merges two sorted segments removing duplicates
// returns the number of array elements without duplicates
int merge(string[] A, int lo1, int hi1, int lo2, int hi2)
//@requires 0 <= lo1 && lo1 < hi1 && hi1 <= lo2 && lo2 < hi2 && hi2 <= \length(A);
//@requires is_sorted(A, lo1, hi1) && no_dupes(A, lo1, hi1);
//@requires is_sorted(A, lo2, hi2) && no_dupes(A, lo2, hi2);
//@ensures 0 <= \result && \result <= hi2 - lo1;
//@ensures is_sorted(A, lo1, lo1 + \result);
//@ensures no_dupes(A, lo1, lo1 + \result);
{
   // total interval of things we care about
   int interval = (hi1 - lo1) + (hi2 - lo2);

   // Allocate a temporary array
   string[] B = alloc_array(string, interval);

   int i = lo1;   // i ranges over the  first array interval [lo1,hi1)
   int j = lo2;   // j ranges over the second array interval [lo2,hi2)
   int k = 0;     // k ranges over [0, interval)

   while (i < hi1 && j < hi2)
     //@loop_invariant lo1 <= i && i <= hi1;
     //@loop_invariant lo2 <= j && j <= hi2;
     {
       int cmp = string_compare(A[i], A[j]);
       // if have duplicate words, we want to collapse them
       if (cmp == 0) {  // take one of them but increment both indices
         B[k] = A[i];
         i++;
         j++;
       }

       else if (cmp < 0) {   // usual mergesort code
         B[k] = A[i];
         i++;
       }
       else {
         B[k] = A[j];
         j++;
       }

       k++;
     }

   while (i < hi1)  // if j == hi2, copy rest of first interval
     //@loop_invariant lo1 <= i && i <= hi1;
     {
       B[k] = A[i];
       i++;
       k++;
     }

   while (j < hi2)  // if i == hi1, copy rest of second interval
     //@loop_invariant lo1 <= j && j <= hi2;
     {
       B[k] = A[j];
       j++;
       k++;
     }

   // copy the k nonduplicates back into A
   for (int m = 0; m < k; m++)
   //@loop_invariant lo1 <= lo1 + m && lo1 + m <= hi2;
   //@loop_invariant 0 <= m && m <= interval;
       A[lo1 + m] = B[m];

   return k;
}


// function that sorts an array of strings and removed duplicates
// returns the number of elements with the duplicates removed
int mergesort (string[] A, int lo, int hi)
//@requires 0 <= lo && lo <= hi && hi <= \length(A);
//@ensures 0 <= \result && \result <= hi - lo;
//@ensures is_sorted(A, lo, lo + \result);
//@ensures no_dupes(A, lo, lo + \result);
{
  // array of size <= 1, no duplicates to remove
  if (hi - lo <= 1)
    return (hi - lo);

  int mid = lo + (hi - lo)/2;

  // keep a running total of the array elements without duplicates
  int elts1 =  mergesort(A, lo, mid);
  int elts2 =  mergesort(A, mid, hi);

  // set the new upper bounds
  int hi1 = lo + elts1;
  int hi2 = mid + elts2;

  // call the merge with the new bounds
  int elts3 = merge(A, lo, hi1, mid, hi2);

  return elts3;
}


// just does a binary search for a given string in the dictionary
bool check_word(string[] dict, int d, string w)
//@requires \length(dict) == d;
//@requires is_sorted(dict,0,d);
//@requires no_dupes(dict,0,d);
//@ensures \result == true ? is_in(w,dict,0,d) : !is_in(w,dict,0,d);
{
  return binsearch(dict, d, w) >= 0;
}


// we give them a sorted dictionary and some text to spell check against it
// returns the number of mispelled words and populates the mispelled array
int check_text_naive(string[] dict, int d, string[] text, int t, string[] miss)
//@requires \length(dict) == d;
//@requires \length(text) == t;
//@requires \length(miss) >= t;
//@requires is_sorted(dict,0,d) && no_dupes(dict,0,d);
//@ensures 0 <= \result && \result <= t;
//@ensures no_dupes(miss, 0, \result);
{
  int m = 0;                         // Number of mispelled words

  // check every word in the (no duplicates) text array
  for (int j = 0; j < t; j++)
  //@loop_invariant 0 <= j && j <= t;
  //@loop_invariant 0 <= m && m <= t;
  {
    if (!check_word(dict, d, text[j])     // the word was NOT found
        && !is_in(text[j], miss, 0, m)) { // and it was not recorded before
      miss[m] = text[j];                  // add to misspelled words
      m++;                                // increment the mispelled counter
    }
  }

  return m;
}

int check_sorted_text(string[] dict, int d, string[] text, int t, string[] miss)
//@requires \length(dict) == d;
//@requires \length(text) >= t;
//@requires \length(miss) >= t;
//@requires is_sorted(dict, 0, d) && no_dupes(dict, 0, d);
//@requires is_sorted(text, 0, t) && no_dupes(text, 0, t);
//@ensures 0 <= \result && \result <= t;
//@ensures is_sorted(miss, 0, \result) && no_dupes(miss, 0, \result);
{
  int i = 0;  // range over (sorted) dictionary -- [0, d)
  int j = 0;  // range over sorted text -- [0, t)
  int m = 0;  // number of mispelled words -- range over [0, t)

// don't search through the duplicates
  while (i < d && j < t)
  //@loop_invariant 0 <= i && i <= d;
  //@loop_invariant 0 <= j && j <= t;
  //@loop_invariant 0 <= m && m <= t;
  {
    int cmp = string_compare(text[j], dict[i]);
    if (cmp > 0)         // need to look farther in the dictionary for this word
       i++;
    else if (cmp < 0) {  // we've passed this word
      miss[m] = text[j]; // add to misspelled words
      m++;               // word is misspelled
      j++;               // move to next text word
    }
    else {               // this means text[j] == dict[i]
      i++;               // move both indices forward
      j++;
    }
  }
  // ran out of dictionary words
  while (j < t) {
    miss[m] = text[j]; // add to misspelled words
    m++;               // word is misspelled
    j++;               // move to next text word
  }

  return m;
}


// we give them a sorted dictionary and some text to spell check against it
// returns the number of mispelled words and populates the mispelled array
int check_text_better(string[] dict, int d, string[] text, int t, string[] miss)
//@requires \length(dict) == d;
//@requires \length(text) == t;
//@requires \length(miss) >= t;
//@requires is_sorted(dict,0,d) && no_dupes(dict,0,d);
//@ensures 0 <= \result && \result <= t;
//ensures no_dupes(miss, 0, \result);
//@ensures is_sorted(miss, 0, \result) && no_dupes(miss, 0, \result);
{
  int t_nd = mergesort(text, 0, t);
  int m = check_sorted_text(dict, d, text, t_nd, miss);

  return m;
}

/*
int main() {
  args_t args = args_parse();
  if (args->argc != 2) {
    println("Synopys: speller <dictionary> <text>");
    return 0;
  }

  // read in the dictionary and the text
  bundle_t dict_stuff  = read_words(args->argv[0]);
  string[] dict = string_bundle_array(dict_stuff);
  int d = string_bundle_length(dict_stuff);

  bundle_t text_stuff =  read_words(args->argv[1]);
  string[] text = string_bundle_array(text_stuff);
  int t = string_bundle_length(text_stuff);

  // check if have only passed in one word -- then run check_word
  if (t == 1) {
      string word = text[0];
      if (check_word(dict, d, word))
        return 0;  // word Ok
      return 1;    // misspelled
  }

 //  if have more than one word run part 2 or part 3
  else {
     // allocate an array for the misspelled words
    string[] miss = alloc_array(string, t);

     // run check_text and check_better
    int res1 = check_text_naive(dict, d, text, t, miss);
    int res2 = check_text_better(dict, d, text, t, miss);

    return res1 + res2; // better not be odd!
  }
}
*/
