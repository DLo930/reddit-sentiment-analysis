/*
 * Peg solitaire solver
 *
 * 15-122 Principles of Imperative Computation */

#use <util>

typedef int* move;
typedef int index;

bool is_index(int i) {
  return 0 <= i && i < 8*8;
}

/* only approx - does not take board into account */
bool is_move(move m) {
  int i = *m >> 16 & 0xFF;
  int j = *m >>  8 & 0xFF;
  int k = *m >>  0 & 0xFF;
  if (!is_index(i)) return false;
  if (!is_index(j)) return false;
  if (!is_index(k)) return false;
  return
       (i % 8 < 6 && i+1 == j && i+2 == k)
    || (i % 8 > 1 && i-1 == j && i-2 == k)
    || (i / 8 < 6 && i+8 == j && i+16 == k)
    || (i / 8 > 1 && i-8 == j && i-16 == k);
}

bool valid_move(board B, move m) {
  if (!is_move(m)) return false;
  if (!(B[*m >> 16 & 0xFF] == 1)) return false;
  if (!(B[*m >>  8 & 0xFF] == 1)) return false;
  if (!(B[*m >>  0 & 0xFF] == 0)) return false;
  return true;
}

int row_start(move m)
//@requires is_move(m);
{
  return (*m >> 16 & 0xFF) / 8;
}

int col_start(move m)
//@requires is_move(m);
{
  return (*m >> 16 & 0xFF) % 8;
}

int row_end(move m)
//@requires is_move(m);
{
  return (*m & 0xFF) / 8;
}

int col_end(move m)
//@requires is_move(m);
{
  return (*m & 0xFF) % 8;
}

/* use 8 bits per address */
/* 6 bits would be sufficient for 2^6 = 64 squares */
move code_move(index i, index j, index k)
//@requires is_index(i) && is_index(j) && is_index(k);
//@ensures is_move(\result);
{
  move m = alloc(int);
  *m = (i<<16) | (j<<8) | (k<<0);
  return m;
}

// DEBUG
/*
void p_location(int row, int col) {
  printint(row); print(":"); printint(col);
}

void p_move(int fr, int fc, int tr, int tc) {
  p_location(fr, fc);
  print(" -> ");
  p_location(tr, tc);
  println("");
}

void p_move2(int i, int j, int k) {
  printint(i); print(","); printint(j); print(","); printint(k);
}
*/


move new_move(index from_row, index from_col, index to_row, index to_col)
//@requires 0 <= from_row && from_row < 8;
//@requires 0 <= from_col && from_col < 8;
//@requires 0 <= to_row   && to_row   < 8;
//@requires 0 <= to_col   && to_col   < 8;
/*@requires (from_row == to_row && abs(from_col - to_col) == 2)
         || (from_col == to_col && abs(from_row - to_row) == 2); @*/
//@ensures is_move(\result);
{
  int from_idx = from_row*8 + from_col;
  int mid_idx  = -1;
  int to_idx   = to_row*8   + to_col;

  if (from_row == to_row)
    mid_idx = from_idx +   (to_col - from_col)/2;
  else
    //@assert from_col == to_col;
    mid_idx = from_idx + 8*(to_row - from_row)/2;

  return code_move(from_idx, mid_idx, to_idx);
}


/* flipping does and undoes a move! */
void flip(board B, move m)
//@requires is_board(B) && is_move(m);
{
  int i = *m >> 16 & 0xFF;
  int j = *m >>  8 & 0xFF;
  int k = *m >>  0 & 0xFF;
  B[i] = 1-B[i];
  B[j] = 1-B[j];
  B[k] = 1-B[k];
}

void make_move(board B, move m)
//@requires is_board(B) && valid_move(B, m);
//@ensures is_board(B);
{
  flip(B, m);
}

void undo_move(board B, move m)
//@requires is_board(B) && is_move(m);
//@ensures is_board(B) && valid_move(B, m);
{
  flip(B, m);
}

void all_moves (board B, stack_t M)
//@requires is_board(B);
{
  for (int col = 0; col < 8; col++)
    //@loop_invariant 0 <= col && col <= 8;
    for (int row = 0; row < 8; row++)
      //@loop_invariant 0 <= row && row <= 8;
      {
        int i = 8*row+col;
        if (B[i] == 1) {
          if (col < 6 && B[i+1] == 1 && B[i+2] == 0)
            push(M, (void*)code_move(i, i+1, i+2));
          if (col > 1 && B[i-1] == 1 && B[i-2] == 0)
            push(M, (void*)code_move(i, i-1, i-2));
          if (row < 6 && B[i+8] == 1 && B[i+16] == 0)
            push(M, (void*)code_move(i, i+8, i+16));
          if (row > 1 && B[i-8] == 1 && B[i-16] == 0)
            push(M, (void*)code_move(i, i-8, i-16));
        }
      }
}
