/*
 * Peg solitaire solver
 *
 * 15-122 Principles of Imperative Computation */

#use <conio>


int solve_peg(board B, stack_t Sol, int pegs)
//@requires is_board(B) && num_pegs(B) == pegs;
//@ensures is_board(B) && num_pegs(B) == pegs;
//@ensures \result >= 1;
{
  //print_board(B);
  //println("===");
  if (pegs == 1) return pegs;
  int min_pegs = pegs;
  stack_t M = stack_new();
  all_moves(B, M);
  while (!stack_empty(M)) {
    move m = (move)pop(M);
    make_move(B, m);
    int num_pegs = solve_peg(B, Sol, pegs-1);
    if (num_pegs < min_pegs) min_pegs = num_pegs;

    if (min_pegs == 1) {
      /* found solution, return */
      push(Sol, (void*)m);
      undo_move(B, m); /* not strictly necessary */
      return 1;
    }

    //@assert 1 < min_pegs && min_pegs <= num_pegs && num_pegs < pegs;
    /* no solution: backtrack */
    undo_move(B, m);
  }
  return min_pegs;   /* tried all moves */
}

int solve(board B, stack_t Sol)
//@requires is_board(B);
//@requires stack_empty(Sol);
//@ensures is_board(B);
//@ensures \result >= 1;
{
  int n = num_pegs(B);
  printint(n); print(" pegs\n");
  return solve_peg(B, Sol, n);
}
