/*
 * Peg solitaire solver
 *
 * 15-122 Principles of Imperative Computation */

#use <util>

typedef int* our_sekret_move;
typedef int our_sekret_index;

bool our_sekret_is_index(int i) {
  return 0 <= i && i < 8*8;
}

/* only approx - does not take board into account */
bool our_sekret_is_move(our_sekret_move m) {
  int i = *m >> 16 & 0xFF;
  int j = *m >>  8 & 0xFF;
  int k = *m >>  0 & 0xFF;
  if (!our_sekret_is_index(i)) return false;
  if (!our_sekret_is_index(j)) return false;
  if (!our_sekret_is_index(k)) return false;
  return
       (i % 8 < 6 && i+1 == j && i+2 == k)
    || (i % 8 > 1 && i-1 == j && i-2 == k)
    || (i / 8 < 6 && i+8 == j && i+16 == k)
    || (i / 8 > 1 && i-8 == j && i-16 == k);
}

bool our_sekret_valid_move(board B, our_sekret_move m) {
  if (!our_sekret_is_move(m)) return false;
  if (!(B[*m >> 16 & 0xFF] == 1)) return false;
  if (!(B[*m >>  8 & 0xFF] == 1)) return false;
  if (!(B[*m >>  0 & 0xFF] == 0)) return false;
  return true;
}

int our_sekret_row_start(our_sekret_move m)
//@requires our_sekret_is_move(m);
{
  return (*m >> 16 & 0xFF) / 8;
}

int our_sekret_col_start(our_sekret_move m)
//@requires our_sekret_is_move(m);
{
  return (*m >> 16 & 0xFF) % 8;
}

int our_sekret_row_end(our_sekret_move m)
//@requires our_sekret_is_move(m);
{
  return (*m & 0xFF) / 8;
}

int our_sekret_col_end(our_sekret_move m)
//@requires our_sekret_is_move(m);
{
  return (*m & 0xFF) % 8;
}

/* use 8 bits per address */
/* 6 bits would be sufficient for 2^6 = 64 squares */
our_sekret_move our_sekret_code_move(our_sekret_index i, our_sekret_index j, our_sekret_index k)
//@requires our_sekret_is_index(i) && our_sekret_is_index(j) && our_sekret_is_index(k);
//@ensures our_sekret_is_move(\result);
{
  our_sekret_move m = alloc(int);
  *m = (i<<16) | (j<<8) | (k<<0);
  return m;
}

our_sekret_move our_sekret_new_move(our_sekret_index from_row, our_sekret_index from_col, our_sekret_index to_row, our_sekret_index to_col)
//@requires 0 <= from_row && from_row < 8;
//@requires 0 <= from_col && from_col < 8;
//@requires 0 <= to_row   && to_row   < 8;
//@requires 0 <= to_col   && to_col   < 8;
/*@requires (from_row == to_row && abs(from_col - to_col) == 2)
         || (from_col == to_col && abs(from_row - to_row) == 2); @*/
//@ensures our_sekret_is_move(\result);
{
  int from_idx = from_row*8 + from_col;
  int mid_idx  = -1;
  int to_idx   = to_row*8   + to_col;

  if (from_row == to_row)
    mid_idx = from_idx +   (to_col - from_col)/2;
  else
    //@assert from_col == to_col;
    mid_idx = from_idx + 8*(to_row - from_row)/2;

  return our_sekret_code_move(from_idx, mid_idx, to_idx);
}


/* flipping does and undoes a move! */
void our_sekret_flip(board B, our_sekret_move m)
//@requires is_board(B) && our_sekret_is_move(m);
{
  int i = *m >> 16 & 0xFF;
  int j = *m >>  8 & 0xFF;
  int k = *m >>  0 & 0xFF;
  B[i] = 1-B[i];
  B[j] = 1-B[j];
  B[k] = 1-B[k];
}

void our_sekret_make_move(board B, our_sekret_move m)
//@requires is_board(B) && our_sekret_valid_move(B, m);
//@ensures is_board(B);
{
  our_sekret_flip(B, m);
}

void our_sekret_undo_move(board B, our_sekret_move m)
//@requires is_board(B) && our_sekret_is_move(m);
//@ensures is_board(B) && our_sekret_valid_move(B, m);
{
  our_sekret_flip(B, m);
}

void our_sekret_all_moves (board B, stack_t M)
//@requires is_board(B);
{
  for (int col = 0; col < 8; col++)
    //@loop_invariant 0 <= col && col <= 8;
    for (int row = 0; row < 8; row++)
      //@loop_invariant 0 <= row && row <= 8;
      {
        int i = 8*row+col;
        if (B[i] == 1) {
          if (col < 6 && B[i+1] == 1 && B[i+2] == 0)
            push(M, (void*)our_sekret_code_move(i, i+1, i+2));
          if (col > 1 && B[i-1] == 1 && B[i-2] == 0)
            push(M, (void*)our_sekret_code_move(i, i-1, i-2));
          if (row < 6 && B[i+8] == 1 && B[i+16] == 0)
            push(M, (void*)our_sekret_code_move(i, i+8, i+16));
          if (row > 1 && B[i-8] == 1 && B[i-16] == 0)
            push(M, (void*)our_sekret_code_move(i, i-8, i-16));
        }
      }
}
