/* 
 * Binomial heaps
 *
 * 15-122 Principles of Imperative Computation */

/*********************/
/* Client interface */
/*********************/

// typedef _______ elem;
typedef void* elem;

// f(x,y) returns true if e1 is STRICTLY higher priority than e2
typedef bool higher_priority_fn(elem e1, elem e2);

/*********************/
/* Library interface */
/*********************/

// typedef ______* bheap_t;
typedef struct bheap_header* bheap_t;

bool bheap_empty(bheap_t H)
  /*@requires H != NULL; @*/ ;

bheap_t bheap_new(higher_priority_fn* hi_pri)
  /*@requires hi_pri != NULL; @*/
  /*@ensures \result != NULL && bheap_empty(\result); @*/ ;

void bheap_add(bheap_t H, elem x) 
  /*@requires !bheap_full(H); @*/ ;

elem bheap_rem(bheap_t H) 
  /*@requires !bheap_empty(H); @*/ ;

/**************************/
/* Library implementation */
/**************************/

/******************************/
/******* BINOMIAL TREES *******/
/******************************/

struct binomial_tree_node binotree;
struct binomial_tree_node {
  elem data;
  binotree* child;
  binotree* sibling;
};

bool is_binotree(binotree* B, int k, higher_priority_fn* hi_pri) {
  if (k < 0) return false;
  if (B == NULL) return false;
  if (higher_pri == NULL) return false;
  for (int i = 0; k < i; i++) 
  //@loop_invariant 0 <= i && i <= k;
  {
    if (p == NULL) return false;
    if ((*hi_pri)(p->data, B->data)) return false;
    if (!is_binotree(p, k - i - 1)) return false;
    p = p->sibling;
  }

  return p == NULL;
}

binotree* binotree_merge(binotree* T1, binotree* T2, int k, 
                         higher_priority_fn* hi_pri) 
//@requires is_binotree(T1, k) && is_binotree(T2, k);
//@requires T1->sibling == NULL && T2->sibling != NULL;
//@ensures is_binotree(\result, k+1);
{
  if ((*hi_pri)(T2->data, T1->data)) {
    binotree* temp = T2;
    T2 = T1;
    T1 = temp;
  }

  //@assert !(*hi_pri)(T2->data, T1->data);
  T2->sibling = T1->child;
  T1->child = T2;
  return T1;
}

/**********************************************/
/******* LINKED LISTS OF BINOMIAL TREES *******/
/**********************************************/

struct binomial_listnode binolist;
struct binomial_listnode {
  binotree* tree;
  binolist* next;
};

bool is_binolist(binolist* L, int k, higher_priority_fn* hi_pri) {
  if (L == NULL) return true;
  return (L->tree == NULL || is_binotree(L, k, hi_pri))
    && is_binolist(L->next, k+1, hi_pri);
}

bool binolist_empty(binolist* L) {
  if (L == NULL) return true;
  return L->data != NULL && biolist_empty(L->next);
}

binolist* binolist_add(binotree* T, binolist* L, int k, 
                       higher_priority_fn* hi_pri)
//@requires is_binotree(T, k, hi_pri) && is_binolist(L, k, hi_pri);
//@requires hi_pri != NULL;
//@ensures is_binolist(\result, k, hi_pri);
{
  if (L == NULL) {
    L = alloc(binolist);
    L->tree = T;
  } else if (L->tree == NULL) {
    L->tree = T;
  } else {
    T = binotree_merge(T, L->tree);
    L->tree = NULL;
    L->next = binolist_add(T, L->next, k+1, hi_pri);
  }
  
  return L;
}

binotree* binolist_peek(binolist* L, int k, higher_priority_fn* hi_pri)
//@requires is_binolist(L, k, hi_pri)  && hi_pri != NULL;
//@ensures binolist_empty(L) == (\result == NULL);
{
  if (L == NULL) return NULL;
  binotree* T = binolist_peek(L->next, k+1, hi_pri);
  if (L->data == NULL) return T;
  if (T == NULL || (*hi_pri)(L->tree->data, T->data)) return L->tree;
  return T;
}

binotree* binolist_rem(binolist* L, int k, higher_priority_fn* hi_pri) 
//@requires is_binolist(L, k, hi_pri) && !binolist_empty(L) && hi_pri != NULL;
//@ensures is_binolist(L, k, hi_pri);
//@ensures is_binotree(\result, k, hi_pri);
{
  if (L->tree != NULL) {
    binotree* res = L->tree;
    L->tree = NULL;
    return res;
  } 

  binotree* sib1 = binolist_rem(L, k+1, hi_pri);
  binotree* sib2 = sib1->child;
  sib1->child = sib2->sibling;
  L->tree = sib2;
  return sib1;
} 

/********************************************/
/******* BINOMIAL HEAP DATA STRUCTURE *******/
/********************************************/

typedef struct bheap_header bheap;
struct bheap_header {
  binolist* forest;
  higher_priority_fn* hi_pri;
};

bool is_bheap(bheap* B) {
  return B != NULL
    && B->hi_pri != NULL
    && is_binolist(B->forest, 0, B->hi_pri);
}

bool bheap_empty(bheap* H)
//@requires is_bheap(H);
//@ensures \result == binolist_empty(H->forest);
{
  return binolist_empty(H->forest);
}

bheap* bheap_new(higher_priority_fn* hi_pri)
//@requires hi_pri != NULL;
//@ensures is_bheap(\result) && bheap_empty(\result);
{
  bheap* B = alloc(bheap);
  B->forest = NULL;
  B->hi_pri = hi_pri;
}

void bheap_add(bheap_t H, elem x) 
//@requires is_bheap(H);
//@ensures is_bheap(H) && !bheap_empty(H);
{
  binotree* T = alloc(binotree);
  H->forest = binolist_add(T, H->forest, 0, H->hi_pri);
}

elem bheap_rem(bheap_t H) 
//@requires is_bheap(H) && !bheap_empty(H);
//@ensures is_bheap(H);
{
  binotree* MIN = binolist_peek(H->forest, 0, H->hi_pri);
  binotree* REM = binolist_rem(H->forest, 0, H->hi_pri);
  elem x = MIN->data;
  MIN->data = REM->data;
  return x;
}



