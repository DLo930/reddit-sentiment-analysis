queue_t inval() {
  queue_t Q = queue_new();
  Q->size = 42;
  return Q;
}


bool printerd(void* x) {
  printint(*(int*)x); print(", ");
  return true;
}

int main() {
  args_t args = args_parse();
  if (args->argc != 1) error("Wrong number of args");
  string arg = args->argv[0];

  int[] A = parse_ints("42 12 19 66 32 -1 55  0", 10);
  int[] B = parse_ints(" 0 55 -1 32 66 19 12 42", 10);

  if (string_equal(arg, "peek_precon1")) {
    queue_peek(NULL, 0);

  } else if (string_equal(arg, "peek_precon2")) {
    queue_peek(inval(), 0);

  } else if (string_equal(arg, "peek_precon3")) {
    queue_peek(queue_new(), 0);

  } else if (string_equal(arg, "peek_precon4")) {
    queue_peek(queue_new(), -1);

  } else if (string_equal(arg, "peek")) {
    for (int n = 1; n < 8; n++) {
      queue* Q = construct(A, 0, n);
      list*[] L = storage(Q);

      for (int i = 0; i < n; i++) {
        int ans = *(int*)queue_peek(Q, i);
        // printint(i); print(" - "); printint(A[i]); print(" - "); printint(ans); println("");
        if (ans != A[i]) return 1;

        // Check that nothing about the queue has changed as a result of peek
        if (!__sekret__is_inclusive_segment(Q->front, Q->back, n)) return 1;
        list* p = Q->front;
        for (int k = 0; k < n; k++) {
          if (p != L[k]) return 1;
          p = p->next;
        }
      }
    }

  } else if (string_equal(arg, "reverse_precon1")) {
    queue_reverse(NULL);

  } else if (string_equal(arg, "reverse_precon2")) {
    queue_reverse(inval());

  } else if (string_equal(arg, "reverse-empty")) {
    queue* Q = alloc(queue);
    queue_reverse(Q);
    if (!__sekret__is_queue(Q)) return 1;
    if (Q->size != 0) return 1;

    Q->back = alloc(list);
    queue_reverse(Q);
    if (!__sekret__is_queue(Q)) return 1;
    if (Q->size != 0) return 1;

  } else if (string_equal(arg, "reverse-correctly")) {
    for (int n = 1; n < 8; n++) {
      queue* Q = construct(A, 0, n);
      //queue_all(Q, &printerd); println("");
      queue_reverse(Q);
      //queue_all(Q, &printerd); println("");
      if (!confirm(Q, B, 8-n, 8)) return 1;
    }

  } else if (string_equal(arg, "reverse-without-new-allocation")) {
    for (int n = 1; n < 8; n++) {
      queue* Q = construct(A, 0, n);
      list*[] Ls = storage(Q);

      queue_reverse(Q);
      for (list* L = Q->front; L != NULL; L = L->next) {
        bool found = false;
        for (int i = 0; i < n; i++) {
          if (Ls[i] == L) found = true;
        }
        if (!found) return 1;
      }
    }

  } else if (string_equal(arg, "deq")) {
    for (int i = 0; i < 7; i++) {
      queue* Q = construct(A, i, 8);
      void* x = deq(Q);
      //@assert \hastag(int*, x);
      if (*(int*)x != A[i]) return 1;
      if (!confirm(Q, A, i+1, 8)) return 1;
    }

  } else {
    error(string_join("Bad arg: ", arg));
  }

  return 0;
}
