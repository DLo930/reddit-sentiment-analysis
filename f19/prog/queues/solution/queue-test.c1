queue* construct(int[] A, int len) 
//@requires len == \length(A);
//@ensures is_queue(\result);
{
  if (len == 0) return alloc(queue);

  queue* Q = alloc(queue);
  Q->front = alloc(list);
  Q->back = Q->front;
  int* p = alloc(int);
  *p = A[0];
  Q->front->data = (void*)p;
  Q->size = len;
  
  for (int i = 1; i < len; i++) 
  //@loop_invariant 1 <= i && i <= len;
  //@loop_invariant is_inclusive_segment(Q->front, Q->back, i);
  {
    Q->back->next = alloc(list);
    Q->back = Q->back->next;
    p = alloc(int);
    *p = A[i];
    Q->back->data = (void*)p;
  }

  return Q;
}

bool confirm(queue* Q, int[] A, int len) 
//@requires len == \length(A);
{
  if (!is_queue(Q)) return false;
  if (queue_size(Q) != len) return false;
  if (len == 0) return true;

  list* L = Q->front;
  for (int i = 0; i < len; i++) 
  //@loop_invariant 0 <= i && i <= len;
  //@loop_invariant is_inclusive_segment(L, Q->back, Q->size - i);
  {
    //@assert \hastag(int*, L->data);
    int* p = (int*)L->data;
    if (*p != A[i]) return false;
    L = L->next;
  }
  
  return true;
}

int main() {
  queue_t Q;
  int[] A;
  int n;
  string s;

  s = ""; n = 0;
  print("Test: "); println(s); A = parse_ints(s, 10);
  Q = construct(A, n); queue_reverse(Q);
  assert(confirm(Q, A, n));

  s = "6"; n = 1;
  print("Test: "); println(s); A = parse_ints(s, 10);
  Q = construct(A, n); queue_reverse(Q);  
  assert(confirm(Q, A, n));

  s = "2 9"; n = 2;
  print("Test: "); println(s); A = parse_ints(s, 10);
  Q = construct(A, n); queue_reverse(Q);  
  assert(confirm(Q, parse_ints("9 2", 10), n));

  s = "1 2 5 6 7 4 4 4 4"; n = 9;
  print("Test: "); println(s); A = parse_ints(s, 10);
  Q = construct(A, n); queue_reverse(Q);  
  assert(confirm(Q, parse_ints("4 4 4 4 7 6 5 2 1", 10), n));

  return 0;
}