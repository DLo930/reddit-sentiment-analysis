/* Gapbuf mimic code
 * 
 * Contains no contracts, so that contract failures can only arise
 * from student code. 
 * 
 * These mimic functions will never raise an assertion violation: if
 * they are called in a situation where they *should* raise an
 * assertion violation, they will segfault or call error().
 *
 * Therefore, the autograder should never call mimic code on a sequence
 * of operations that might raise an assertion violation. */

bool is_gapbuf_(gapbuf* G)
{
  if (G == NULL) return false;
  if (!(G->limit > 0)) return false;
  if (!(0 <= G->gap_start && 
        /**/ G->gap_start <= G->gap_end &&
        /**/                 G->gap_end <= G->limit)) return false;
  //@assert \length(G->buffer) == G->limit;
  return true;
}

bool gapbuf_empty_mimic(gapbuf* G)
{
  return G->gap_start == 0 && G->gap_end == G->limit;
}

bool gapbuf_full_mimic(gapbuf* G)
{
  return G->gap_start == G->gap_end;
}

gapbuf* gapbuf_new_mimic(int limit)
{
  gapbuf* G = alloc(struct gapbuf_header);
  G->limit = limit;
  G->buffer = alloc_array(char, limit);
  G->gap_start = 0;
  G->gap_end = limit;
  return G;
}

bool gapbuf_at_left_mimic(gapbuf* G)
{
  return G->gap_start == 0;
}

bool gapbuf_at_right_mimic(gapbuf* G)
{
  return G->gap_end == G->limit;
}

void gapbuf_backward_mimic(gapbuf* G)
{
  if (!gapbuf_at_left_mimic(G)) {
    G->gap_start--;
    G->gap_end--;
    G->buffer[G->gap_end] = G->buffer[G->gap_start];
  } else { error(""); }
}

void gapbuf_forward_mimic(gapbuf* G)
{
  if (!gapbuf_at_right_mimic(G)) {
    G->buffer[G->gap_start] = G->buffer[G->gap_end];
    G->gap_start++;
    G->gap_end++;
  } else { error(""); }
}

void gapbuf_delete_mimic(gapbuf* G)
{
  if (!gapbuf_at_left_mimic(G)) {
    G->gap_start--;
  } else { error(""); }
}

void gapbuf_insert_mimic(gapbuf* G, char c)
{
  if (!gapbuf_full_mimic(G)) {
    G->buffer[G->gap_start] = c;
    G->gap_start++;
  } else { error(""); }
}

bool gapbuf_equal(gapbuf* G, gapbuf* H) 
{
  if (G == NULL 
      || H == NULL
      || G->limit != H->limit
      || G->gap_start != H->gap_start
      || G->gap_end != H->gap_end)
    return false;

  //@assert G->limit == \length(G->buffer);
  //@assert H->limit == \length(H->buffer);
    
  for (int i = 0; i < G->gap_start; i++) {
    if (G->buffer[i] != H->buffer[i]) return false;
  }
  
  for (int i = G->gap_end; i < G->gap_end; i++) {
    if (G->buffer[i] != H->buffer[i]) return false;
  }
  
  return true;
}