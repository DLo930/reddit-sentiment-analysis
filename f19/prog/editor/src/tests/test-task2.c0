/* Tests the gap buffer's interface functions exhaustively on a size
 * 10 gap buffer, by manually moving around the gap to every valid
 * start and end location in a size-10 array.  */

int main()
{
  bool passed = true;
  gapbuf G = alloc(struct gap_buffer);

  G->limit = 10; 
  G->buffer = alloc_array(char, 10);

  for (G->gap_start = 0; G->gap_start <= 10; G->gap_start++) {
    for (G->gap_end = G->gap_start; G->gap_end <= 10; G->gap_end++) {
      // gapbuf_empty
      if (G->gap_start == 0 && G->gap_end == 10) 
        { if (!gapbuf_empty(G)) return 1; }
      else
        { if (gapbuf_empty(G)) return 1; }

      // gapbuf_full
      if (G->gap_start == G->gap_end) 
        { if (!gapbuf_full(G)) return 1; }
      else
        { if (gapbuf_full(G)) return 1; }

      // gapbuf_at_left
      if (G->gap_start == 0) 
        { if (!gapbuf_at_left(G)) return 1; }
      else
        { if (gapbuf_at_left(G)) return 1; }

      // gapbuf_at_right
      if (G->gap_end == 10) 
        { if (!gapbuf_at_right(G)) return 1; }
      else
        { if (gapbuf_at_right(G)) return 1; }
    }
  }

  return 0;
}
