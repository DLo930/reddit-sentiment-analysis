/* Gapbuf mimic code
 * 
 * Contains no contracts, so that contract failures can only arise
 * from student code. 
 * 
 * These mimic functions have oddball semantics in edge cases -- they
 * will do something bizarre (raise an integer division error) when
 * the specification says to raise an assertion violation. If this
 * happens, it should be considered a bug in the autograder, as this
 * solution shouldn't be run on assertion-failing gap buffers. */

bool gapbuf_empty_(gapbuf G)
{
    return G->gap_start == 0 && G->gap_end == G->limit;
}

bool gapbuf_full_(gapbuf G)
{
    return G->gap_start == G->gap_end;
}

gapbuf gapbuf_new_(int limit)
{
    gapbuf G = alloc(struct gap_buffer);
    G->limit = limit;
    G->buffer = alloc_array(char, limit);
    G->gap_start = 0;
    G->gap_end = limit;
    return G;
}

bool gapbuf_at_left_(gapbuf G)
{
    return G->gap_start == 0;
}

bool gapbuf_at_right_(gapbuf G)
{
    return G->gap_end == G->limit;
}

void gapbuf_backward_(gapbuf G)
{
    if (!gapbuf_at_left_(G)) {
        G->gap_start--;
        G->gap_end--;
        G->buffer[G->gap_end] = G->buffer[G->gap_start];
    } else { 4/0; }
}

void gapbuf_forward_(gapbuf G)
{
    if (!gapbuf_at_right_(G)) {
        G->buffer[G->gap_start] = G->buffer[G->gap_end];
        G->gap_start++;
        G->gap_end++;
    } else { 4/0; }
}

void gapbuf_delete_(gapbuf G)
{
    if (!gapbuf_at_left_(G)) {
        G->gap_start--;
    } else { 4/0; }
}

void gapbuf_insert_(gapbuf G, char c)
{
    if (!gapbuf_full_(G)) {
        G->buffer[G->gap_start] = c;
        G->gap_start++;
    } else { 4/0; }
}

bool gapbuf_eq_(gapbuf G, gapbuf H) 
{
  if (G->limit != H->limit
      || G->gap_start != H->gap_start
      || G->gap_end != H->gap_end)
    return false;
    
  for (int i = 0; i < G->gap_start; i++) {
    if (G->buffer[i] != H->buffer[i]) return false;
  }

  for (int i = G->gap_end; i < G->gap_end; i++) {
    if (G->buffer[i] != H->buffer[i]) return false;
  }

  return true;
}