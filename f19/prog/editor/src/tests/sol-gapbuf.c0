/* Gapbuf solution code
 * Assumes types are already declared in gap-buffer.c0 */

bool is_gapbuf_(gapbuf G)
//@requires G != NULL && \length(G->buffer) == G->limit;
{
    return G != NULL
        && G->limit > 0
        && 0 <= G->gap_start
        &&      G->gap_start <= G->gap_end
        &&                      G->gap_end <= G->limit;
}

bool gapbuf_empty_(gapbuf G)
//@requires is_gapbuf_(G);
//@ensures is_gapbuf_(G);
{
    return G->gap_start == 0 && G->gap_end == G->limit;
}

bool gapbuf_full_(gapbuf G)
//@requires is_gapbuf_(G);
//@ensures is_gapbuf_(G);
{
    return G->gap_start == G->gap_end;
}

gapbuf gapbuf_new_(int limit)
//@requires limit > 0;
//@ensures is_gapbuf_(\result);
//@ensures gapbuf_empty_(\result);
{
    gapbuf G = alloc(struct gap_buffer);
    G->limit = limit;
    G->buffer = alloc_array(char, limit);
    G->gap_start = 0;
    G->gap_end = limit;
    return G;
}

bool gapbuf_at_left_(gapbuf G)
//@requires is_gapbuf_(G);
//@ensures is_gapbuf_(G);
{
    return G->gap_start == 0;
}

bool gapbuf_at_right_(gapbuf G)
//@requires is_gapbuf_(G);
//@ensures is_gapbuf_(G);
{
    return G->gap_end == G->limit;
}

void gapbuf_backward_(gapbuf G)
//@requires is_gapbuf_(G);
//@ensures is_gapbuf_(G);
{
    if (!gapbuf_at_left_(G)) {
        G->gap_start--;
        G->gap_end--;
        G->buffer[G->gap_end] = G->buffer[G->gap_start];
    }
}

void gapbuf_forward_(gapbuf G)
//@requires is_gapbuf_(G);
//@ensures is_gapbuf_(G);
{
    if (!gapbuf_at_right_(G)) {
        G->buffer[G->gap_start] = G->buffer[G->gap_end];
        G->gap_start++;
        G->gap_end++;
    }
}

void gapbuf_delete_(gapbuf G)
//@requires is_gapbuf_(G);
//@ensures is_gapbuf_(G);
{
    if (!gapbuf_at_left_(G)) {
        G->gap_start--;
    }
}

void gapbuf_insert_(gapbuf G, char c)
//@requires is_gapbuf_(G);
//@ensures is_gapbuf_(G);
{
    if (!gapbuf_full_(G)) {
        G->buffer[G->gap_start] = c;
        G->gap_start++;
    }
}