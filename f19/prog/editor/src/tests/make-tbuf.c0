#use "sol-gapbuf.c0"
#use "sol-tbuf.c0"
#use "make-gapbuf.c0"
#use <string>

/* returns true if s can turn into a tbuf:

  abc-de|fgh-i ~~>
  ** <-> abc[.............] <-> de[...........]fgh <-> [...............]i <-> **

   i.e., there must be no more than 16 characters before each dash, and
   somewhere there has to be a | to indicate the cursor point.  no empty
   gapbufs allowed, either: no "--", e.g.
*/
bool can_be_tbuf(string s) {
    // empty string always okay
    if (string_compare(s, "|") == 0) return true;
    // otherwise need to scan and interpret
    int len = string_length(s);
    bool found_point = false;
    int current_len = 0;
    for (int i = 0; i < len; i++) {
        char c = string_charat(s, i);
        if (c == '-') {
            // can't have a gapbuf end if the gapbuf is empty
            if (current_len == 0) return false;
            // reset current gapbuf length
            current_len = 0;
        } else if (c == '|') {
            // not allowed to find the point twice
            if (found_point) return false;
            // record finding the point, without incrementing gapbuf length
            found_point = true;
        } else {
            // regular character -- consume and increment gapbuf length if poss
            if (current_len == 16) return false;
            // increment gapbuf length and move on
            current_len++;
        }
    }
    // last gapbuf can't be empty either
    if (current_len == 0) return false;
    return found_point;

}

void link_in(dll before, dll after) {
    before->next->prev = after;
    after->next = before->next;
    before->next = after;
    after->prev = before;
}

tbuf make_tbuf(string s)
//@requires can_be_tbuf(s);
//@ensures is_tbuf_(\result);
{
    if (string_compare(s, "|") == 0) return tbuf_new_();

    tbuf B = alloc(struct text_buffer);
    B->start = alloc(struct list_node);
    B->end = alloc(struct list_node);
    /* start <--> end */
    B->start->next = B->end;
    B->end->prev = B->start;

    int len = string_length(s);
    bool found_point = false;
    int start = 0;
    dll L = B->start;
    while (start < len)
    /* not quite a loop invariant: B is not a tbuf until the loop executes once,
     * due to the weird corner-case-ness of the empty tbuf.  so i've moved the
     * check down to the end of the loop body.  by the precondition of the
     * function, the loop will run at least once, and we've already taken care
     * of the case where the result is the empty tbuf.
     */
    // //@loop_invariant is_tbuf_(B);
    {
        dll new = alloc(struct list_node);
        new->data = gapbuf_new_(16);

        /* continually update the point along the way to maintain the loop
         * invariant that the tbuf is well-formed, but stop updating once
         * we've found its final resting place.
         */
        int end = index(s, '-', start);
        if (end == -1) end = len;

        // start by copying in all the data, not including the potential cursor
        for (int i = start; i < end; i++) {
            if (string_charat(s, i) != '|')
                gapbuf_insert_(new->data, string_charat(s, i));
        }

        if (contains(s, '|', start, end)) {
            // this cell is the point
            //@assert !found_point;
            found_point = true;
            B->point = new;
            // back up the gap to be at the cursor
            int cursor = index(s, '|', start);
            //@assert start <= cursor && cursor < end;
            for (int i = cursor+1; i < end; i++) gapbuf_backward_(new->data);
        } else if (!found_point) {
            // this cell is before the point
            // gap already aligned to be at right side
            // reassign point to maintain loop invariant
            B->point = new;
        } else {
            // this cell is after the point
            // align gap to be at left side
            for (int i = start; i < end; i++) gapbuf_backward_(new->data);
        }

        link_in(L, new);
        //@assert is_tbuf_(B);
        L = new;
        start = end + 1;
    }

    return B;
}

/* turns [...........]abcde and abcde[...........] into "abcde" */
string gapbuf_to_string(gapbuf G)
//@requires is_gapbuf_(G) && (gapbuf_at_left_(G) || gapbuf_at_right_(G));
//@ensures string_length(\result) == G->limit - (G->gap_end - G->gap_start);
{
    char[] buf = alloc_array(char, G->limit + 1);
    for (int i = 0; i < G->limit + 1; i++) buf[i] = '\0';

    if (gapbuf_at_right_(G)) {
        for (int i = 0; i < G->gap_start; i++)
            buf[i] = G->buffer[i];
    } else /*@assert gapbuf_at_left_(G); @*/ {
        for (int i = G->gap_end; i < G->limit; i++)
        /*@loop_invariant 0 <= i - G->gap_end
                            && i - G->gap_end <= G->limit - G->gap_end + 1; @*/
        /*@loop_invariant 0 <= i && i <= G->limit; @*/
            buf[i - G->gap_end] = G->buffer[i];
    }

    return string_from_chararray(buf);
}

/* turns abc[...........]de into "abc|de" */
string gapbuf_to_pointed_string(gapbuf G)
//@requires is_gapbuf_(G);
//@ensures string_length(\result) == G->limit - (G->gap_end - G->gap_start) + 1;
{
    char[] buf = alloc_array(char, G->limit + 2);
    for (int i = 0; i < G->limit + 1; i++) buf[i] = '\0';

    int i = 0;
    int j = 0;
    while (i < G->gap_start)
    //@loop_invariant 0 <= i && i <= G->gap_start;
    //@loop_invariant i == j;
    {
        buf[j] = G->buffer[i];
        i++;
        j++;
    }
    //@assert i == G->gap_start;
    buf[j] = '|';
    i = G->gap_end;
    j++;
    while (i < G->limit)
    //@loop_invariant G->gap_end <= i && i <= G->limit;
    //@loop_invariant j == i - (G->gap_end - G->gap_start) + 1;
    {
        buf[j] = G->buffer[i];
        i++;
        j++;
    }

    return string_from_chararray(buf);
}

/* secret backend version -- actual one verifies the result (see below) */
string tbuf_to_string_(tbuf B)
//@requires is_tbuf_(B);
//@ensures can_be_tbuf(\result);
{
    string res = "";

    for (dll L = B->start->next; L != B->point; L = L->next)
        res = string_join(res, string_join(gapbuf_to_string(L->data), "-"));

    res = string_join(res, gapbuf_to_pointed_string(B->point->data));

    for (dll L = B->point->next; L != B->end; L = L->next)
        res = string_join(res, string_join("-", gapbuf_to_string(L->data)));

    return res;
}

string tbuf_to_string(tbuf B)
//@requires is_tbuf_(B);
//@ensures can_be_tbuf(\result);
//@ensures string_equal(\result, tbuf_to_string_(make_tbuf(\result)));
{
    return tbuf_to_string_(B);
}


// there is a list segment from p to q following at most n next pointers.
bool dll_segmentn_next(int n, dll p, dll q)
{
  dll p0 = p;
  for (int i = 0; i < n && p0 != NULL; i++)
  //@loop_invariant 0 <= i;
  {
    if (p0 == q) return true;
    p0 = p0->next;
  }
  return p0 == q;
}

// There is a list segment from s to e following next pointers. This algorithm always terminates.
// Brent's cycle detection algorithm.
bool is_dll_segment_next_(dll s, dll e)
//@requires true;
//@ensures true;
{
  if (s == e) return true;
  int power = 0;
  dll hare = s->next;
  dll tortoise = s;
  for (int i = 1; tortoise != hare; i++)
  //@loop_invariant dll_segmentn_next(1 << power, tortoise, hare);
  //@loop_invariant tortoise != NULL;
  {
    if (hare == e) return true;
    if (hare == NULL) return e == NULL;
    if (i == 1 << power)
    {
      power++;
      tortoise = hare;
      i = 0;
    }
    hare = hare->next;
  }
  // Found cycle
  return false;
}


// there is a list segment from p to q following at most n prev pointers.
bool dll_segmentn_prev(int n, dll p, dll q)
{
  dll p0 = p;
  for (int i = 0; i < n && p0 != NULL; i++)
  //@loop_invariant 0 <= i;
  {
    if (p0 == q) return true;
    p0 = p0->prev;
  }
  return p0 == q;
}

// There is a list segment from s to e following prev pointers. This algorithm always terminates.
// Brent's cycle detection algorithm.
bool is_dll_segment_prev_(dll s, dll e)
//@requires true;
//@ensures true;
{
  if (s == e) return true;
  int power = 0;
  dll hare = s->prev;
  dll tortoise = s;
  for (int i = 1; tortoise != hare; i++)
  //@loop_invariant dll_segmentn_prev(1 << power, tortoise, hare);
  //@loop_invariant tortoise != NULL;
  {
    if (hare == e) return true;
    if (hare == NULL) return e == NULL;
    if (i == 1 << power)
    {
      power++;
      tortoise = hare;
      i = 0;
    }
    hare = hare->prev;
  }
  // Found cycle
  return false;
}

bool no_cycle(tbuf B)
//@requires B != NULL;
{
  return is_dll_segment_prev_(B->end, B->point) && 
         is_dll_segment_prev_(B->point, B->start) &&
         is_dll_segment_next_(B->start, B->point) &&
         is_dll_segment_next_(B->point, B->end);
}

