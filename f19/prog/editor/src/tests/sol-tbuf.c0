//SOLUTION CODE
//all solution functions marked with a following _
//include after student code in test main function

#use "sol-gapbuf.c0"
#use <string>

//==============================================================================
//tbuf.c0
//==============================================================================

/*
//implied
#use "gapbuf.c0"
*/

/*
//this will also be declared previously in student code
//if they did not use the same gapbuf size, there may be conflicts

//this tbuf implementation uses fixed-size gapbufs of 16 bytes 
typedef gapbuf elem;
*/

/*
//declared in student code
typedef structlist_node * dll;
struct dll {
    elem data; // this is a gap buffer (fixed-size of 16 bytes)
    dll next;
    dll prev;
};
typedef struct text_buffer * tbuf;
struct tbuf {
    dll start; // the fist node of the list
    dll point; // the current node
    dll end;   // the last node
};
*/

/*** tbuf specification functions ***/

/* a valid tbuf is
    + linked:
      - start, point, and end are all non-NULL
      - the point is neither the start nor the end
      - the start leads to the point leads to the end,
        with all the links consistent in both directions
    + aligned:
      - every gap buffer left of the point has its non-trivial gap at the right
      - every gap buffer right of the point has its non-trivial gap at the left
    + and either:
        - the point is the only gap buffer and it is empty
      or else:
        - the point is neither empty nor full
*/

bool is_linked_(tbuf B) {
    if (B == NULL) return false;
    if (B->start == NULL || B->point == NULL || B->end == NULL) return false;
    if (B->start == B->point || B->point == B->end) return false;

    bool found_point = false;
    for (dll L = B->start; L != B->end; L = L->next)
    //@loop_invariant L != NULL;
    {
        if (L->next == NULL) return false;
        if (L->next->prev != L) return false;
        if (L == B->point) found_point = true;
    }

    return found_point;
}


bool is_aligned_(tbuf B)
//@requires is_linked_(B);
//@ensures is_linked_(B);
{
    bool seen_point = false;

    for (dll L = B->start->next; L != B->end; L = L->next)
    //@loop_invariant L != NULL;
    {
        if (!is_gapbuf_(L->data) || L->data->limit != 16) return false;
        if (L == B->point) {
            seen_point = true;
        } else if (!seen_point) {
            if (gapbuf_empty_(L->data) || !gapbuf_at_right_(L->data)) return false;
        } else /*@assert seen_point; @*/ {
            if (gapbuf_empty_(L->data) || !gapbuf_at_left_(L->data)) return false;
        }
    }

    return true;
}

/*
// alternate implementation:
bool is_aligned_(tbuf B)
//@requires is_linked_(B);
//@ensures is_linked_(B);
{
    for (dll L = B->start->next; L != B->point; L = L->next) {
        if (!is_gapbuf_(L->data) || L->data->limit != 16) return false;
        if (gapbuf_empty_(L->data) || !gapbuf_at_right_(L->data)) return false;
    }

    if (!is_gapbuf_(B->point->data) || B->point->data->limit != 16) return false;

    for (dll L = B->point->next; L != B->end; L = L->next) {
        if (!is_gapbuf_(L->data) || L->data->limit != 16) return false;
        if (gapbuf_empty_(L->data) || !gapbuf_at_left_(L->data)) return false;
    }

    return true;
}
*/

bool tbuf_empty_(tbuf B)
//@requires is_linked_(B);
//@ensures is_linked_(B);
{
    return B->point->prev == B->start
        && B->point->next == B->end
        && gapbuf_empty_(B->point->data);
}

bool is_tbuf_(tbuf B) {
    if (!is_linked_(B) || !is_aligned_(B)) return false;
    return tbuf_empty_(B) || !gapbuf_empty_(B->point->data);
}

tbuf tbuf_new_()
//@ensures is_tbuf_(\result);
//@ensures tbuf_empty_(\result);
{
    tbuf B = alloc(struct text_buffer);
    /* contents of start and end don't matter */
    B->start = alloc(struct list_node);
    B->end = alloc(struct list_node);
    /* point should be a fresh, empty gapbuf */
    B->point = alloc(struct list_node);
    B->point->data = gapbuf_new_(16);
    /* start <--> point <--> end */
    B->start->next = B->point;
    B->point->prev = B->start;
    B->point->next = B->end;
    B->end->prev = B->point;

    return B;
}

bool tbuf_at_right_(tbuf B)
//@requires is_linked_(B);
//@ensures is_linked_(B);
{
    return B->point->next == B->end;
}

bool tbuf_at_left_(tbuf B)
//@requires is_linked_(B);
//@ensures is_linked_(B);
{
    return B->point->prev == B->start;
}


/*** doubly-linked list operations ***/

void tbuf_forward_(tbuf B)
//@requires is_linked_(B);
//@ensures is_linked_(B);
{
    if (!tbuf_at_right_(B))
        B->point = B->point->next;
}

void tbuf_backward_(tbuf B)
//@requires is_linked_(B);
//@ensures is_linked_(B);
{
    if (!tbuf_at_left_(B))
        B->point = B->point->prev;
}

void tbuf_delete_point_(tbuf B)
//@requires is_linked_(B) && is_aligned_(B);
//@ensures is_tbuf_(B);
{
    bool at_left = tbuf_at_left_(B);
    bool at_right = tbuf_at_right_(B);
    /* don't delete the last remaining cell */
    if (!(at_left && at_right)) {
        B->point->prev->next = B->point->next;
        B->point->next->prev = B->point->prev;
        if (!at_left)
            B->point = B->point->prev;
        else /*@assert !at_right; @*/
            B->point = B->point->next;
    }
}

void tbuf_split_point_(tbuf B)
//@requires is_tbuf_(B);
//@requires gapbuf_full_(B->point->data);
//@ensures is_tbuf_(B);
//@ensures !gapbuf_full_(B->point->data);
{
    dll L = B->point;
    char[] oldbuf = L->data->buffer;
    int p = L->data->gap_start; //@assert p == L->data->gap_end;
    L->data = gapbuf_new_(16);

    dll R = alloc(struct list_node);
    R->data = gapbuf_new_(16);
    R->prev = L;
    R->next = L->next;
    L->next->prev = R;
    L->next = R;

    if (p < 8) {
        /* the point is in the left half of the current buffer */
        for (int i = 0; i < p; i++) L->data->buffer[i] = oldbuf[i];
        for (int i = p; i < 8; i++) L->data->buffer[i+8] = oldbuf[i];
        L->data->gap_start = p;
        L->data->gap_end = p+8;

        for (int i = 8; i < 16; i++) R->data->buffer[i] = oldbuf[i];
        R->data->gap_start = 0;
        R->data->gap_end = 8;
        // //@assert gapbuf_at_left_(R->data);
    } else /*@assert 8 <= p && p <= 16; @*/ {
        /* the point is in the right half of the current buffer */
        for (int i = 0; i < 8; i++) L->data->buffer[i] = oldbuf[i];
        L->data->gap_start = 8;
        L->data->gap_end = 16;
        //@assert gapbuf_at_right_(L->data);

        for (int i = 8; i < p; i++) R->data->buffer[i-8] = oldbuf[i];
        for (int i = p; i < 16; i++) R->data->buffer[i] = oldbuf[i];
        R->data->gap_start = p-8;
        R->data->gap_end = p;

        /* point is now in the new, right buffer */
        B->point = R;
    }
}


/*** text buffer operations ***/

void forward_char_(tbuf B)
//@requires is_tbuf_(B);
//@ensures is_tbuf_(B);
{
    if (gapbuf_at_right_(B->point->data)) {
        tbuf_forward_(B);
    }
    gapbuf_forward_(B->point->data);
}

void backward_char_(tbuf B)
//@requires is_tbuf_(B);
//@ensures is_tbuf_(B);
{
    if (gapbuf_at_left_(B->point->data)) {
        tbuf_backward_(B);
    }
    gapbuf_backward_(B->point->data);
}

void delete_char_(tbuf B)
//@requires is_tbuf_(B);
//@ensures is_tbuf_(B);
{
    if (gapbuf_at_left_(B->point->data)) {
        tbuf_backward_(B);
    }
    gapbuf_delete_(B->point->data);
    if (gapbuf_empty_(B->point->data)) {
        tbuf_delete_point_(B);
    }
}

void insert_char_(tbuf B, char c)
//@requires is_tbuf_(B);
//@ensures is_tbuf_(B);
{
    if (gapbuf_full_(B->point->data)) {
        tbuf_split_point_(B);
    }
    gapbuf_insert_(B->point->data, c);
}

typedef struct contents *contents;
struct contents {
    string str;
    int cursor;
};

bool is_contents(contents C) {
    return C != NULL && 0 <= C->cursor && C->cursor <= string_length(C->str);
}

string gapbuf_contents(gapbuf G)
//@requires is_gapbuf_(G);
//@ensures is_gapbuf_(G);
//@ensures 0 <= string_length(\result) && string_length(\result) <= G->limit;
{
    int gaplen = G->gap_end - G->gap_start;
    int buflen = G->limit - gaplen + 1; // + 1 for terminating NUL
    char[] res = alloc_array(char, buflen);
    for (int i = 0; i < G->gap_start; i++) res[i] = G->buffer[i];
    for (int i = G->gap_end; i < G->limit; i++) res[i - gaplen] = G->buffer[i];
    res[buflen-1] = '\0';
    return string_from_chararray(res);
}

contents tbuf_contents(tbuf B)
//@requires is_tbuf_(B);
//@ensures is_tbuf_(B);
//@ensures is_contents(\result);
{
    string str = "";
    dll L;
    for (L = B->start->next; L != B->point; L = L->next)
        str = string_join(str, gapbuf_contents(L->data));
    //@assert L == B->point;
    int cursor = string_length(str) + L->data->gap_start;
    str = string_join(str, gapbuf_contents(L->data));
    for (L = B->point->next; L != B->end; L = L->next)
        str = string_join(str, gapbuf_contents(L->data));

    contents C = alloc(struct contents);
    C->str = str;
    C->cursor = cursor;

    return C;
}
