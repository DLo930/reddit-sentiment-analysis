#use <args>
#use <conio>
#use <file>
#use <string>

#use "gapbuf-mimic.c0"

void visualize_gapbuf(gapbuf* G)
{
    for (int i = 0; i < G->gap_start; i++) printchar(G->buffer[i]);
    printchar('[');
    for (int i = G->gap_start; i < G->gap_end; i++) printchar('.');
    printchar(']');
    for (int i = G->gap_end; i < G->limit; i++) printchar(G->buffer[i]);
}

void process_char(gapbuf* G, gapbuf* H, char c, bool mimic)
{
  if (c == '<') {
    gapbuf_backward(G);
    if (mimic) gapbuf_backward_mimic(H);
  }
  else if (c == '>') {
    gapbuf_forward(G);
    if (mimic) gapbuf_forward_mimic(H);
  }
  else if (c == '^') {
    gapbuf_delete(G);
    if (mimic) gapbuf_delete_mimic(H);
  }
  else {
    gapbuf_insert(G,c);
    if (mimic) gapbuf_insert_mimic(H,c);
  }

  // visualize_gapbuf(G); print("\n");
}

int process_string(int bufsize, string s, bool mimic) {
  gapbuf* G = gapbuf_new(bufsize);
  gapbuf* H = gapbuf_new_mimic(bufsize);

  int limit = string_length(s);
  for (int i = 0; i < limit; i++) {
    process_char(G, H, string_charat(s, i), mimic);
    if (mimic && !gapbuf_equal(G, H)) return 1;
  }

  return 0;
}

int main() {
  bool* mimic = alloc(bool);
  args_flag("-mimic", mimic);

  int* bufsize = alloc(int);
  *bufsize = 16;
  args_int("-bufsize", bufsize);

  args_t args = args_parse();
  if (args->argc < 1) error("Too few args");
  string arg = args->argv[0];
  if (string_equal(arg, "run")) {
    if (args->argc != 2) error("Wrong number of args");
  }
  else if (args->argc != 1) error("Too many args");

  // Not actually a valid gap buffer: used to check preconditions
  // of gapbuf functions
  gapbuf* G0 = alloc(struct gapbuf_header);

  // Gap buffer G1 is set up with slightly invalid contents: it will be
  // used to check for the preconditions of gapbuf functions.
  gapbuf* G1 = alloc(struct gapbuf_header);
  G1->limit = 1;
  G1->buffer = alloc_array(char, 1);
  G1->gap_start = 1;
  G1->gap_end = 0;

  gapbuf* G4 = alloc(struct gapbuf_header);
  G4->limit = 4;
  G4->buffer = alloc_array(char, 4);

  gapbuf* G10 = alloc(struct gapbuf_header);
  G10->limit = 10;
  G10->buffer = alloc_array(char, 10);

  gapbuf* G16 = alloc(struct gapbuf_header);
  G16->limit = 16;
  G16->buffer = alloc_array(char, 16);

  if (string_equal(arg, "is_gapbuf-size1-empty")) {
    // First, test an empty, size-1 gap-buffer
    //G1->buffer[0] = 'a';
    G1->gap_start = 0;
    G1->gap_end = 1;
    if (!is_gapbuf(G1)) return 1;

  } else if (string_equal(arg, "is_gapbuf-size1-full")) {
    // Second, test a full, size-1 gap buffer
    G1->buffer[0] = 'a';
    G1->gap_start = 1;   // Gap at the end
    G1->gap_end = 1;
    if (!is_gapbuf(G1)) return 1;

    G1->gap_start = 0;   // Gap at the beginning
    G1->gap_end = 0;
    if (!is_gapbuf(G1)) return 1;

  } else if (string_equal(arg, "is_gapbuf-size1-badstartend")) {
    // Third, test gap buffers with slightly invalid start and end
    // (this are the values that G1 was initialized to above)

    // IMPORTANT: must work in order to be able to reliably test
    // preconditions
    if (is_gapbuf(G1)) return 1;

  } else if (string_equal(arg, "is_gapbuf-NULL")) {
    // Segfaults for everyone!

    // IMPORTANT: must work in order to be able to reliably test
    // preconditions
    if (is_gapbuf(NULL)) return 1;

  } else if (string_equal(arg, "is_gapbuf-size0")) {
    // Size must be strictly positive

    // IMPORTANT: must work in order to be able to reliably test
    // preconditions
    if (is_gapbuf(G0)) return 1;

  } else if (string_equal(arg, "is_gapbuf-invalidlength")) {
    // Alas, annotation failures must happen to check length

    gapbuf* G = alloc(struct gapbuf_header);
    G->limit = 3;
    G->buffer = alloc_array(char, 2);
    G->gap_start = 0;
    G->gap_end = 1;
    assert(is_gapbuf(G));

  } else if (string_equal(arg, "is_gapbuf-size1-stuff")) {
    // Fourth, test that any contents of valid length-1 gap buffers
    // are valid - this catches a specific bug with student code that
    // will give bad results for the is-gapbuf-size16 test
    G1->limit = 1;
    G1->buffer = alloc_array(char, 1);

    for(int i = 0; i < 128; i++) {
      G1->buffer[0] = char_chr(i);

      G1->gap_start = 0;
      G1->gap_end = 1;
      if (!is_gapbuf(G1)) return 1;

      G1->gap_start = 1;
      G1->gap_end = 1;
      if (!is_gapbuf(G1)) return 1;

      G1->gap_start = 0;
      G1->gap_end = 0;
      if (!is_gapbuf(G1)) return 1;
    }

  } else if (string_equal(arg, "is_gapbuf-size16")) {
    // All valid size 16 gap buffers
    for(G16->gap_start = 0; G16->gap_start <= 16; G16->gap_start++)
      for(G16->gap_end = G16->gap_start; G16->gap_end <= 16; G16->gap_end++)
        if(!is_gapbuf(G16)) return 1;

  } else if (string_equal(arg, "is_gapbuf-size10-spotchecks")) {
    //good 10-element gap buffer
    G10->gap_start = 0;
    G10->gap_end = 10;
    if(!is_gapbuf(G10)) return 1;

    //bad start
    G10->gap_start = -3;
    G10->gap_end = 7;
    if(is_gapbuf(G10)) return 1;

    //bad end
    G10->gap_start = 3;
    G10->gap_end = 245;
    if(is_gapbuf(G10)) return 1;

    //gap overlap
    G10->gap_start = 7;
    G10->gap_end = 3;
    if(is_gapbuf(G10)) return 1;

    //reasonable gap
    G10->gap_start = 3;
    G10->gap_end = 7;
    if(!is_gapbuf(G10)) return 1;

    //gap at front
    G10->gap_start = 0;
    G10->gap_end = 0;
    if(!is_gapbuf(G10)) return 1;

    //gap at back
    G10->gap_start = 10;
    G10->gap_end = 10;
    if(!is_gapbuf(G10)) return 1;

  } else if (string_equal(arg, "empty-NULL")) { gapbuf_empty(NULL);
  } else if (string_equal(arg, "empty-size0")) { gapbuf_empty(G0);
  } else if (string_equal(arg, "full-NULL")) { gapbuf_full(NULL);
  } else if (string_equal(arg, "full-size0")) { gapbuf_full(G0);
  } else if (string_equal(arg, "at_left-NULL")) { gapbuf_at_left(NULL);
  } else if (string_equal(arg, "at_left-size0")) { gapbuf_at_left(G0);
  } else if (string_equal(arg, "at_right-NULL")) { gapbuf_at_right(NULL);
  } else if (string_equal(arg, "at_right-size0")) { gapbuf_at_right(G0);
  } else if (string_equal(arg, "new-0")) { gapbuf_new(0);
  } else if (string_equal(arg, "new-negative")) { gapbuf_new(-1);
  } else if (string_equal(arg, "forward-NULL")) { gapbuf_forward(NULL);
  } else if (string_equal(arg, "forward-size0")) { gapbuf_forward(G0);
  } else if (string_equal(arg, "backward-NULL")) { gapbuf_backward(NULL);
  } else if (string_equal(arg, "backward-size0")) { gapbuf_backward(G0);
  } else if (string_equal(arg, "insert-NULL")) { gapbuf_insert(NULL, 'f');
  } else if (string_equal(arg, "insert-size0")) { gapbuf_insert(G0, 'f');
  } else if (string_equal(arg, "delete-NULL")) { gapbuf_delete(NULL);
  } else if (string_equal(arg, "delete-size0")) { gapbuf_delete(G0);
  } else if (string_equal(arg, "delete-left")) {
    G10->gap_start = 0;
    G10->gap_end = 5;
    gapbuf_delete(G10);

  } else if (string_equal(arg, "empty")) {
    for (G10->gap_start = 0; G10->gap_start <= 10; G10->gap_start++) {
      for (G10->gap_end = G10->gap_start; G10->gap_end <= 10; G10->gap_end++) {
        if (G10->gap_start == 0 && G10->gap_end == 10)
          { if (!gapbuf_empty(G10)) return 1; }
        else
          { if (gapbuf_empty(G10)) return 1; }
      }
    }

  } else if (string_equal(arg, "full")) {
    for (G10->gap_start = 0; G10->gap_start <= 10; G10->gap_start++) {
      for (G10->gap_end = G10->gap_start; G10->gap_end <= 10; G10->gap_end++) {
        if (G10->gap_start == G10->gap_end)
          { if (!gapbuf_full(G10)) return 1; }
        else
          { if (gapbuf_full(G10)) return 1; }
      }
    }

  } else if (string_equal(arg, "at_left")) {
    for (G10->gap_start = 0; G10->gap_start <= 10; G10->gap_start++) {
      for (G10->gap_end = G10->gap_start; G10->gap_end <= 10; G10->gap_end++) {
        if (G10->gap_start == 0)
          { if (!gapbuf_at_left(G10)) return 1; }
        else
          { if (gapbuf_at_left(G10)) return 1; }
      }
    }

  } else if (string_equal(arg, "at_right")) {
    for (G10->gap_start = 0; G10->gap_start <= 10; G10->gap_start++) {
      for (G10->gap_end = G10->gap_start; G10->gap_end <= 10; G10->gap_end++) {
        if (G10->gap_end == 10)
          { if (!gapbuf_at_right(G10)) return 1; }
        else
          { if (gapbuf_at_right(G10)) return 1; }
      }
    }

  } else if (string_equal(arg, "run")) {
    file_t F = file_read(args->argv[1]);

    // Argument is a command
    if (F == NULL) return process_string(*bufsize, args->argv[1], *mimic);

    // Argument is a filename
    while (!file_eof(F))
      if (1 == process_string(*bufsize, file_readline(F), *mimic))
        return 1;

  } else {
    error("Bad argument");
  }

  return 0;
}
