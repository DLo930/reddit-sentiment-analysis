#use <conio>
#use <string>

// Create a gap buffer with some sequential contents
gapbuf* mastergap(int c)
//@requires 33 <= c && c < 127-16;
{
  gapbuf* G = gapbuf_new(16);
  for (int i = 0; i < 16; i++)
    //@loop_invariant 0 <= i;
    gapbuf_insert_mimic(G, char_chr(i+c));
  return G;
}

// One element gap buffer
dll_pt* master_one(int lower, int upper)
//@requires 0 <= lower && lower <= upper && upper <= 16;
{
  tbuf* B = alloc(struct dll_pt_header);

  B->start = alloc(dll);
  B->start->next = alloc(dll);

  B->point = B->start->next;
  B->point->prev = B->start;
  B->point->data = mastergap(65);
  B->point->data->gap_start = lower;
  B->point->data->gap_end = upper;
  B->point->next = alloc(dll);

  B->end = B->point->next;
  B->end->prev = B->point;

  return B;
}

int[] decode(int n, int code)
//@requires 1 <= n && n <= 8;
//@requires n == 8 || (0 <= code && code < (1 << (4 * n)));
//@ensures \length(\result) == n;
// Ensures le_seg(0, \result, 0, n);
// Ensures gt_seg(16, \result, 0, n);
{
  int[] A = alloc_array(int, n);
  for (int i = 0; i < n; i++)
    //@loop_invariant 0 <= i;
    {
      A[i] = code & 0xF;
      code = code >> 4;
    }
  return A;
}

// Creates a valid non-empty n-element-gap buffer.
// Takes in: the size of the gaps, the gap buffer containing the
// cursor, and the number of items that exist to the left of the gap
// in the gap buffer containing the cursor (cursor_depth).
dll_pt* master(int[] A, int n, int cursor_loc, int cursor_depth)
// Requires: le_seg(0, A, 0, \length(A))
// Requires: gt_seg(16, A, 0, \length(A))
//@requires \length(A) == n;
//@requires 0 <= cursor_loc && cursor_loc < n;
//@requires 0 <= cursor_depth && cursor_depth <= 16 - A[cursor_loc];
{
  tbuf* B = alloc(struct dll_pt_header);
  B->start = alloc(dll);
  dll* l = B->start;

  for (int i = 0; i < n; i++)
    //@loop_invariant 0 <= i;
    {
      //@assert 0 <= A[i] && A[i] < 16; // Informal precondition
      l->next = alloc(dll);
      l->next->prev = l;
      l->next->data = mastergap(42 + (i % 5)*16);
      l = l->next;
      if (i < cursor_loc) {
        l->data->gap_start = 16-A[i];
        l->data->gap_end = 16;
      } else if (i > cursor_loc) {
        l->data->gap_start = 0;
        l->data->gap_end = A[i];
      } else {
        l->data->gap_start = cursor_depth;
        l->data->gap_end = cursor_depth + A[i];
        B->point = l;
      }
    }

  l->next = alloc(dll);
  l->next->prev = l;
  B->end = l->next;
  return B;
}


/* Checking well-formedness of segments */

bool is_dll_segment__(dll* start, dll* end) {
  for (dll* l = start; l != NULL; l = l->next) {
    if (l == end) return true;
    if (l->next == NULL) return false;
    if (l->next->prev != l) return false; // Mirroring
    if (l->next == start) return false; // Circularity!
  }

  // Reached NULL instead of the (must-be-non-NULL) end
  return false;
}

bool is_dll_pt__(struct dll_pt_header* B) {
  if (B == NULL) return false;
  if (!is_dll_segment__(B->start, B->point)) { println("A"); return false; }
  if (!is_dll_segment__(B->point, B->end)) { println("A"); return false; }
  if (B->start->next == B->end) { println("A"); return false; }
  for (dll* l = B->start->next; l != B->end; l = l->next)
    //@loop_invariant is_dll_segment__(l, B->end);
    if (l == B->point) return true;
  return false;
}

bool is_gapbufs___(dll* l, dll* end) {
  for (dll* start; l != end; l = l->next)
    //@loop_invariant is_dll_segment__(l, end);
    if (!is_gapbuf_(l->data)) return false;
  return true;
}

/* Somewhat complicated, checks alignment and returns -1 if the tbuf
 * is invalid. */
int size_tbuf__(tbuf* B) {
  if (!is_dll_pt__(B)) return -1;
  if (!is_gapbufs___(B->start->next, B->end)) return -1;
  if (B->start->next == B->point
      && B->end->prev == B->point
      && gapbuf_empty_mimic(B->point->data)) return 0;

  int i = 0;

  for (dll* l = B->start->next; l != B->point; l = l->next) {
    if (l->data->gap_end != 16) return -1;
    if (l->data->gap_start == 0) return -1;
    i += l->data->gap_start;
  }

  i += B->point->data->gap_start;
  i += 16 - B->point->data->gap_end;
  if (gapbuf_empty_mimic(B->point->data)) return -1;

  for (dll* l = B->point->next; l != B->end; l = l->next) {
    if (l->data->gap_start != 0) return -1;
    if (l->data->gap_end == 16) return -1;
    i += 16 - l->data->gap_end;
  }

  return i;
}

/* Build a gap buffer from a text buffer
 *
 * Will fail (with call to error) if the DLL is too big - if the total
 * size is larger than 160. This is defensively a little large to try
 * and cope with bad implementations of split_point */
gapbuf* replay_tbuf(tbuf* B)
//@requires size_tbuf__(B) != -1 && size_tbuf__(B) < 160;
{
  gapbuf* G = gapbuf_new_mimic(160);
  for (dll* l = B->start->next; l != B->point->next; l = l->next) {
    for (int i = 0; i < l->data->gap_start; i++)
      //@loop_invariant 0 <= i;
      {
        gapbuf_insert_mimic(G, l->data->buffer[i]);
      }
  }
  for (dll* l = B->end->prev; l != B->point->prev; l = l->prev) {
    for (int i = 15; i >= l->data->gap_end; i--)
      //@loop_invariant i < 16;
      {
        gapbuf_insert_mimic(G, l->data->buffer[i]);
        gapbuf_backward_mimic(G);
      }
  }
  return G;
}

void print_gapbuf__(gapbuf* G) {
  for (int i = 0; i < G->gap_start; i++)
    printchar(G->buffer[i]);
  print(" - ");
  for (int i = G->gap_end; i < G->limit; i++)
    printchar(G->buffer[i]);
  println("");
}
