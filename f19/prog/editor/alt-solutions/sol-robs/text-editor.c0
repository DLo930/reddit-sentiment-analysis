/**
 *****************************************************************************
 *                              HOMEWORK  15-122
 *****************************************************************************
 *      This is a back-end for a one character text editor.
 *
 *      Run William Lovas' front-end "locas-E0.c0" for a full demo.
 *
 * @author:
 *****************************************************************************/

#use "gap-buffer.c0"
#use "text-buffer.c0"
#use <conio>

/* INTERFACE */

bool is_tbuf(tbuf B);     /* Checks if a text buffer satisfies invariants */

bool tbuf_empty(tbuf B);  /* Checks if the text buffer is empty  */
tbuf tbuf_new();          /* Creates an empty text buffer, with  */
                          /*   with gap buffers of size 16       */

void split_point(tbuf B); /* Splits a full point into two nodes, */
                          /*   so that the new point is not full */

void forward_char(tbuf B);  /* Move the cursor forward 1 char, to the right  */
void backward_char(tbuf B); /* Move the cursor backward 1 char, to the left  */
void insert_char(tbuf B, char c); /* Insert the char c before the cursor     */
void delete_char(tbuf B);         /* Delete the character before the cursor, */
                                  /*   also deletes the point if it is empty */

/* IMPLEMENTATION */

bool is_empty(tbuf B) 
//@requires is_linked(B);
{
  return is_gapbuf(B->point->data)
    && gapbuf_empty(B->point->data)
    && B->start->next == B->point
    && B->end->prev == B->point;
}

bool is_good_tbuf(tbuf B) 
{
  if (!is_linked(B)) return false;
  if (is_empty(B) && B->point->data->limit == 16) return true;
  for(dll node = B->start->next; node != B->end; node = node->next) {
    if (!is_gapbuf(node->data)) return false;
    println("foo");
    if (gapbuf_empty(node->data)) return false;
    println("bar");
    if (node->data->limit != 16) return false;
    println("baz");
  }
  return true;
}

bool is_tbuf(tbuf B)
{
  dll node;
  println("Wha???");
  if (!is_good_tbuf(B)) return false; 
  println("Yahhh.");

  for(node = B->start->next; node != B->point; node = node->next) {
    if(!gapbuf_at_right(node->data)) {
      return false;
    }
  }

  //@assert(node == B->point);
  for(node = node->next; node != B->end; node = node->next) {
    if(!gapbuf_at_left(node->data)) {
      return false;
    }
  }

  return true;
}


bool tbuf_empty(tbuf B) 
//@requires is_tbuf(B);
{
  return gapbuf_empty(B->point->data);
}

tbuf tbuf_new() 
//@ensures is_tbuf(\result);
//@ensures tbuf_empty(\result);
{
  tbuf B = alloc(struct text_buffer);
  B->start = alloc(struct list_node);
  B->point = alloc(struct list_node);
  B->end = alloc(struct list_node);

  B->start->next = B->point;
  B->point->prev = B->start;
  B->point->data = gapbuf_new(16);
  B->point->next = B->end;
  B->end->prev = B->point;

  return B;
}

void split_point(tbuf B) 
//@requires is_tbuf(B);
//@requires gapbuf_full(B->point->data);
//@ensures is_tbuf(B);
//@ensures !gapbuf_full(B->point->data);
{
  dll very_left = B->point->prev;
  dll left = alloc(struct list_node);
  dll right = B->point;

  very_left->next = left;
  left->prev = very_left;
  left->data = gapbuf_new(16);
  left->next = right;
  right->prev = left;
  //@assert is_linked(B);

  // First, split the buffers at the point
  int elems_in_left = right->data->gap_start;
  for(int i = 0; i < elems_in_left; i++) {
    left->data->buffer[i] = right->data->buffer[i];
  }
  left->data->gap_start = elems_in_left;
  right->data->gap_start = 0;
  right->data->gap_end = elems_in_left;
  //@assert is_gapbuf(left->data);
  //@assert is_gapbuf(right->data);

  // Then, balance them out
  if (elems_in_left <= 8) {
    // Point moves to the left
    B->point = left;
    for(int i = elems_in_left; i < 8; i++) 
      {
	left->data->buffer[i+8] = right->data->buffer[i];
      }
    left->data->gap_end = 8 + elems_in_left;
    right->data->gap_start = 0;
    right->data->gap_end = 8;
  } else {
    // Point remains on the right
    for(int i = elems_in_left-1; i >= 8; i--) {
      right->data->buffer[i-8] = left->data->buffer[i];
    }
    left->data->gap_start = 8;
    left->data->gap_end = 16;
    right->data->gap_start = elems_in_left - 8;
  }
}



void forward_char(tbuf B) 
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  if(gapbuf_at_right(B->point->data)) {
    if(!tbuf_at_right(B)) {
      tbuf_forward(B);
      gapbuf_forward(B->point->data);
    }
  } else {
    gapbuf_forward(B->point->data);
  }
}


void backward_char(tbuf B)
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  if(gapbuf_at_left(B->point->data)) {
    if(!tbuf_at_left(B)) {
      tbuf_backward(B);
      gapbuf_backward(B->point->data);
    }
  } else {
    gapbuf_backward(B->point->data);
  }
}

void insert_char(tbuf B, char c) 
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  if(gapbuf_full(B->point->data)) 
    split_point(B);
  gapbuf_insert(B->point->data, c);
}

void delete_char(tbuf B) 
//@requires is_tbuf(B);
//@ensures is_tbuf(B);
{
  if(gapbuf_empty(B->point->data)) return;
  if(tbuf_at_left(B) && gapbuf_at_left(B->point->data)) return;
  if(gapbuf_at_left(B->point->data))
    B->point = B->point->prev;

  //@assert !gapbuf_at_left(B->point->data);
  gapbuf_delete(B->point->data);
  if(gapbuf_empty(B->point->data))
    if(!tbuf_at_left(B) || !tbuf_at_right(B))
      tbuf_delete_point(B);
}
