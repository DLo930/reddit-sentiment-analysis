/**
 *****************************************************************************
 *                              HOMEWORK  15-122
 *****************************************************************************
 *      A text buffer is a doubly linked list (dll) of gap buffers.
 *      The list is terminated with dummy nodes whose contents are
 *      never inspected.
 *
 * @author:
 *****************************************************************************/

typedef struct list_node * dll;
struct list_node
{
  elem data; /* this is a gap buffer (fixed-size of 16 bytes) */
  dll next;
  dll prev;
};

typedef struct text_buffer * tbuf;
struct text_buffer
{
  dll start; /* the fist node of the list (on the left)  */
  dll point; /* the current node (where the cursor is)   */
  dll end;   /* the last node of the list (on the right) */
};

/* INTERFACE */

bool is_linked(tbuf B);     /* Checks if the list is a well-formed dll */

bool tbuf_at_left(tbuf B);  /* Returns true if the point is the        */
                            /*   first (non-terminal) node of the list */
bool tbuf_at_right(tbuf B); /* Returns true if the point is the        */
                            /*   last (non-terminal) node of the list  */

void tbuf_forward(tbuf B);      /* Moves the point forward, to the right  */
void tbuf_backward(tbuf B);     /* Moves the point backward, to the left  */
void tbuf_delete_point(tbuf B); /* Remove the point node from the list    */

/* IMPLEMENTATION */

bool is_linked(tbuf B) 
{
  if (B == NULL) return false;
  if (B->start == NULL || B->point == NULL || B->end == NULL)
    return false;
  if (B->start == B->point || B->start == B->end || B->end == B->point)
    return false;

  bool seen_the_point = false;
  dll last = B->start;
  dll current = B->start->next;
  while(current != B->end) 
    //@loop_invariant last != NULL;
    {
      if (current == NULL) return false;
      if (current->prev != last) return false;
      if (current == B->point) seen_the_point = true;
      last = current;
      current = current->next;
    }

  //@assert current == B->end;
  return seen_the_point && current->prev == last;
}

bool tbuf_at_left(tbuf B) 
//@requires is_linked(B);
{
  return B->start->next == B->point;
}

bool tbuf_at_right(tbuf B)
//@requires is_linked(B);
{
  return B->end->prev == B->point;
}

void tbuf_forward(tbuf B) 
//@requires is_linked(B);
//@requires !tbuf_at_right(B);
//@ensures is_linked(B);
{
  B->point = B->point->next;
  return;
}

void tbuf_backward(tbuf B)
//@requires is_linked(B);
//@requires !tbuf_at_left(B);
//@ensures is_linked(B);
{
  B->point = B->point->prev;
  return;
}

void tbuf_delete_point(tbuf B)
//@requires is_linked(B);
//@requires !tbuf_at_left(B) || !tbuf_at_right(B);
//@ensures is_linked(B);
{
  dll old_point = B->point;

  if(!tbuf_at_left(B)) {
    B->point = B->point->prev;
  } else {
    //@assert !tbuf_at_right(B);
    B->point = B->point->next;
  }

  old_point->prev->next = old_point->next;
  old_point->next->prev = old_point->prev;

}