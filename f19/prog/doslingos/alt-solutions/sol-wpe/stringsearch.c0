#use <string>

/* some convenience functions wrapping string_compare */
bool string_le(string s, string t) {
  return string_compare(s, t) <= 0;
}

bool string_lt(string s, string t) {
  return string_compare(s, t) < 0;
}

bool string_ge(string s, string t) {
  return string_compare(s, t) >= 0;
}

bool string_gt(string s, string t) {
  return string_compare(s, t) > 0;
}

bool le_seg(string x, string[] A, int lower, int upper)
//@requires 0 <= lower && lower <= upper && upper <= \length(A);
{
  for (int i = lower; i < upper; i++)
    //@loop_invariant 0 <= i;
    if (!(string_le(x, A[i]))) return false;
  return true;
}

/* code from lecture, ported to string arrays */
bool is_in(string x, string[] A, int n)
//@requires 0 <= n && n <= \length(A);
{
  for (int i = 0; i < n; i++)
    //@loop_invariant 0 <= i && i <= n;
    if (string_equal(A[i], x)) return true;
  return false;
}

bool is_sorted(string[] A, int lower, int upper)
//@requires 0 <= lower && lower <= upper && upper <= \length(A);
{ 
  for (int i = lower; i < upper-1; i++)
    //@loop_invariant i == lower || (lower <= i && i <= upper-1);
    {
      if (!string_le(A[i], A[i+1])) return false;
    }
  return true;
}

// a linear search
int linsearch(string x, string[] A, int n)
//@requires 0 <= n && n <= \length(A);
//@requires is_sorted(A, 0, n);
/*@ensures (-1 == \result && !is_in(x, A, n)) 
  || ((0 <= \result && \result < n)
      && string_equal(A[\result], x)); @*/
{ 
  for (int i = 0; i < n; i++)
    //@loop_invariant 0 <= i && i <= n;
    //@loop_invariant i == 0 || string_lt(A[i-1], x);
    {
      int cmp = string_compare(A[i], x);
      if (cmp == 0) return i;
      else if (cmp > 0)
        //@assert string_gt(A[i], x);
        return -1;
      //@assert string_lt(A[i], x);
      {}
    }
  return -1;
}

// a binary search
int binsearch(string x, string[] A, int n)
//@requires 0 <= n && n <= \length(A);
//@requires is_sorted(A, 0, n);
/*@ensures (-1 == \result && !is_in(x, A, n)) 
  || ((0 <= \result && \result < n)
      && string_equal(A[\result], x)); @*/
{
  int lower = 0;
  int upper = n;
  while (lower < upper)
    //@loop_invariant 0 <= lower && lower <= upper && upper <= n;
    //@loop_invariant (lower == 0 || string_lt(A[lower-1], x));
    //@loop_invariant (upper == n || string_gt(A[upper], x));
    { 
      int mid = lower + (upper-lower)/2; // (lower + upper)/2 could overflow
      int cmp = string_compare(A[mid], x);
      if (cmp == 0) {
        //@assert string_equal(A[mid], x);
        return mid;
      } else if (cmp > 0) { 
        //@assert string_gt(A[mid], x);
        upper = mid;
      } else {
        //@assert string_lt(A[mid], x); 
	lower = mid+1;
      }
    }
  return -1;
}
