OVERALL - In general, it's nice if you can write a summary note
when entering the style grade that gives students the main style concept
they need to work on along with "see code for comments" so that
they know when you marked up their code.


UNIT TESTS (already graded) - The autograder already checked that
students submitted files for unit tests. We did not check if those
tests do anything terribly useful.


README SUBMISSION (1 point) - Students should have the right running
times - O(v*n) for linear search and O(nlogv) for binary search.

Students should also have the following 3 numbers. Anything in the right
ballpark (say, a factor of 10) is acceptable since hardware differences,
competing processes, or even throttling could skew numbers. If their binary
search was slower than linear search, then something was done very wrong
and the student should not receive credit.
 * linear search timing on 1k (roughly 2 seconds)
 * binary search timing on 1k (under a second)
 * binary search timing on 200k (roughly 4-5 seconds)

Half point for runtimes, half point for timing.


STYLE POINTS - The idea is that you can gain 5 style points but then
lose one. However, no negative style points! See below for an itemized
list of attributes to grade for.

You don't have to give students the score breakdown, one or two quick
comments in code ("why not use is_unique() here?") would be awesome.

DEDUCTIONS
 - 1 point for if the student wildly violated traditional "style"
   things like whitespace conventions. There was one student that
   declared *all* their variables at the beginning of a function, for
   instance, including for the internal variable of all their for loops.
   They would lose this point. This also includes consistent use of
   one-letter variable names to the point that it's difficult to
   determine what the code is doing.

ANNOTATIONS (3 points)
 + 3 points: no ridiculous preconditions, @ensures postconditions on
is_unique, is_sorted, and @ensuring that the size of arrays returned from
the core functions is appropriate. Always reasonable loop invariants.
 + 2 points: Some @ensures missing or incomplete, almost all or all of
the loop invariants included, small number of overcomplicated
assertions.
 + 1 point: Some @ensures but basically no loop invariants, some loop
invariants but no ensures, or wildly overcomplicated and unnecessary
@ensures or @requires.
 + 0 points: No @ensures, no loop invariants.

COMMENTS (1 point)
 + 1 point: Students made a reasonable attempt to add comments explaining
   how their functions accomplish their goals or why certain conditionals
   are necessary. Students are still probably too inexperienced to expertly
   write comments, so even minimal attempts are acceptable. Do give some short
   feedback if students need help figuring out how to comment. The handout
   clearly asks for comments, but very few students seem to have made even
   a minimal effort to comment their code.
   * 1 point code: https://autolab.cs.cmu.edu/15122-s13/submission/view/222827?header_position=0
     uses comments, though could use some guidance in refining style.
   * 0 point code: https://autolab.cs.cmu.edu/15122-s13/submission/view/230452?header_position=0
     Zero comments (Other than annotations and Big O).
 + 0 points: Students used virtually no comments throughout the assignment.

CODE REUSE (1 point):
 + 1 point if they reused code well in their count_unique function (only have ~1 line in
   their if / else cases)
 + 0 points if they didn't reuse code in their count_unique function.
   (Some people essentially wrote the function twice, but called binary
   search in one version and linear search in the other.)
   0-point code: https://autolab.cs.cmu.edu/15122-s13/submission/view/230925?header_position=2048

