/* File: duplicates.c0
   Author : Karl Naden (kbn@cs)
   Last Revision : 1/23/2011
   Purpose :
   This is a test implementation of
   the second homework assignment for
   course 15-122 Spring 2011 on
   sorting and manipulating strings.
*/

#use <string>
#use "sortutil.c0"

struct test {
  int i;
};

bool all_distinct(string[] A, int n)
//@requires 0 <= n && n <= \length(A);
//@requires is_sorted(A,0,n);
{
  //Empty and one-word lists are unique by default
  if (n <= 1) return true;

  //Since the array is sorted, we only have to check
  //adjacent words in the list
  //Starting with the first and second words, compare each
  //pair of adjacent words until we have walked through
  //the whole list.
  string last = A[0];
  int i = 1;

  while (i < n)
    //@loop_invariant 1 <= i && i <= n;
    {
      string next = A[i];
      if (string_equal(last,next)) {
        return false;
      } else {
        i++;
        last = next;
      }
    }

  //no equal pairs found, thus the list is unique
  return true;

}

int count_distinct(string[] A, int n)
//@requires 0 <= n && n <= \length(A);
//@requires is_sorted(A,0,n);
{

  //if nothing in the array, no unique elements
  if (n == 0) return 0;

  //if at least one element in the array, there
  // is at least one unique string.  increase
  // the count when we encounter a new string
  int count = 1;
  string last = A[0];
  int i = 1;
  while (i < n)
    //@loop_invariant 1 <= i && i <= n;
    {

      string next = A[i];
      if (!string_equal(last,next)) count++;
      last = next;
      i++;
    }

  return count;
}

string[] remove_duplicates(string[] A, int n)
//@requires 0 <= n && n <= \length(A);
//@requires is_sorted(A, 0, n);
//@ensures \length(\result) == count_distinct(A, n);
//@ensures is_sorted(\result, 0, \length(\result));
//@ensures all_distinct(\result, \length(\result));
{
  string[] ret = alloc_array(string,count_distinct(A,n));

  if (n == 0) return ret;

  string last = A[0];
  ret[0] = last;
  int i = 1;
  int dest = 1;
  while ( i < n )
    //@loop_invariant 1 <= i && i <= n;
    {
      string next = A[i];
      if (!string_equal(last,next)) {
        ret[dest] = next;
        dest++;
      }
      i++;
      last = next;
    }

  return ret;

}
