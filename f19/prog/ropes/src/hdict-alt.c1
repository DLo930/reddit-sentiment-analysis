/*
 * Resizing hash sets, implemented with separate chaining
 *
 * 15-122 Principles of Imperative Computation
 */

#use <util>
#use <conio>

/************************/
/*** Client interface ***/
/************************/

// typedef _______ key;
typedef void* key;
// typedef ______* value;
typedef void* value;

typedef bool key_equiv_fn(key x, key y);
typedef int key_hash_fn(key x);

/**********************/
/*** Implementation ***/
/**********************/

typedef struct chain_node chain;
struct chain_node {
  key k;
  value v;
  chain* next;
};

struct sekret_hdict_header {
  int size;
  int capacity;               /* 0 < capacity */
  chain*[] table;             /* \length(table) == capacity */
  key_equiv_fn* equiv;        /* non-NULL */
  key_hash_fn* hash;          /* non-NULL */
};

bool keyequiv(struct sekret_hdict_header[]* H, key x, key y)
//@requires H != NULL && (*H)[0].equiv != NULL;
{
  return (*(*H)[0].equiv)(x, y);
}

int keyhash(struct sekret_hdict_header[]* H, key x)
//@requires H != NULL && (*H)[0].capacity > 0 && (*H)[0].hash != NULL;
//@ensures 0 <= \result && \result < (*H)[0].capacity;
{
  return abs((*(*H)[0].hash)(x) % (*H)[0].capacity);
}

// All hash values are correct for the current index
bool isa_chain(struct sekret_hdict_header[]* H, chain* p, int i)
//@requires H != NULL && (*H)[0].capacity > 0 && (*H)[0].hash != NULL;
{
  if (p == NULL) return true;
  return p->v != NULL
    && keyhash(H, p->k) == i
    && isa_chain(H, p->next, i);
}

bool isa_chains(struct sekret_hdict_header[]* H, int lo, int hi)
//@requires H != NULL && (*H)[0].capacity > 0 && (*H)[0].hash != NULL;
//@requires \length((*H)[0].table) == (*H)[0].capacity;
//@requires 0 <= lo && lo <= hi && hi <= (*H)[0].capacity;
{
  for (int i = lo; i < hi; i++)
    if (!isa_chain(H, (*H)[0].table[i], i)) return false;
  return true;
}

bool isa_table_expected_length(chain*[] table, int length) {
  //@assert \length(table) == length;
  return true;
}

bool isa_hdict(struct sekret_hdict_header[]* H) {
  if (H == NULL) return false;
  //@assert \length(*H) == 1;
  return (*H)[0].capacity > 0
    && (*H)[0].size >= 0
    && (*H)[0].equiv != NULL
    && (*H)[0].hash != NULL
    && isa_table_expected_length((*H)[0].table, (*H)[0].capacity)
    && isa_chains(H, 0, (*H)[0].capacity);
}

struct sekret_hdict_header[]* hdict_new(int capacity,
                                        key_equiv_fn* equiv,
                                        key_hash_fn* hash)
//@requires capacity > 0 && equiv != NULL && hash != NULL;
//@ensures isa_hdict(\result);
{
  struct sekret_hdict_header[]* H = alloc(struct sekret_hdict_header[]);
  *H = alloc_array(struct sekret_hdict_header, 1);
  (*H)[0].size = 0;
  (*H)[0].capacity = capacity;
  (*H)[0].table = alloc_array(chain*, capacity);
  (*H)[0].equiv = equiv;
  (*H)[0].hash = hash;
  return H;
}

value hdict_lookup(struct sekret_hdict_header[]* H, key k)
//@requires isa_hdict(H);
{
  int i = keyhash(H, k);
  for (chain* p = (*H)[0].table[i]; p != NULL; p = p->next)
  //@loop_invariant isa_chain(H, p, i);
  {
    if (keyequiv(H, p->k, k)) {
      return p->v;
    }
  }

  return NULL;
}

void _hdict_resize_(struct sekret_hdict_header[]* H)
//@requires isa_hdict(H);
//@requires (*H)[0].size >= (*H)[0].capacity;
//@ensures isa_hdict(H);
{
  int old_capacity = (*H)[0].capacity;
  int new_capacity = (*H)[0].size * 2;
  assert(new_capacity > (*H)[0].capacity);
  chain*[] old_table = (*H)[0].table;
  chain*[] new_table = alloc_array(chain*, new_capacity);

  print("(hdict resizing to "); printint(new_capacity); println(")");
  (*H)[0].capacity = new_capacity; // isa_hdict now violated!
  (*H)[0].table = new_table; // isa_hdict restored *only* because we don't check size

  for (int i = 0; i < old_capacity; i++)
  //@loop_invariant 0 <= i && i <= old_capacity;
  //@loop_invariant isa_hdict(H); // only because we don't check size
  {
    chain* p = old_table[i];
    while (p != NULL)
    //@loop_invariant isa_hdict(H); // only because we don't check size
    {
      //@assert p->v != NULL;
      chain* q = p->next; // Save the rest of the chain
      int h = keyhash(H, p->k);
      p->next = (*H)[0].table[h];
      (*H)[0].table[h] = p;
      p = q;
    }
  }
}

void hdict_insert(struct sekret_hdict_header[]* H, key k, value v)
//@requires isa_hdict(H);
//@requires v != NULL;
//@ensures isa_hdict(H);
//@ensures v == hdict_lookup(H, k);
{
  int i = keyhash(H, k);
  for (chain* p = (*H)[0].table[i]; p != NULL; p = p->next)
  //@loop_invariant isa_chain(H, p, i);
  {
    if (keyequiv(H, p->k, k)) {
      p->v = v;
      return;
    }
  }

  // prepend new element
  chain* p = alloc(chain);
  p->k = k;
  p->v = v;
  p->next = (*H)[0].table[i];
  (*H)[0].table[i] = p;
  ((*H)[0].size)++;
  assert((*H)[0].size > 0);

  if ((*H)[0].size >= (*H)[0].capacity) _hdict_resize_(H);
}

// Client interface
typedef struct sekret_hdict_header[]* hdict_t;


/*************************/
/*** Library interface ***/
/*************************/

// typedef ______* hdict_t;

hdict_t hdict_new(int capacity, key_equiv_fn* equiv, key_hash_fn* hash)
  /*@requires capacity > 0 && equiv != NULL && hash != NULL; @*/
  /*@ensures \result != NULL; @*/ ;

value hdict_lookup(hdict_t H, key k)
  /*@requires H != NULL; @*/ ;

void hdict_insert(hdict_t H, key k, value v)
  /*@requires H != NULL && v != NULL; @*/
  /*@ensures hdict_lookup(H, k) == v; @*/ ;
