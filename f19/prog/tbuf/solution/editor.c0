/*
 * Augment doubly linked lists with row and column information
 *
 * 15-122 Principles of Imperative Computation */

/*** Interface ***/

typedef struct editor_header editor;
struct editor_header {
  tbuf* buffer;
  int row;
  int col;
};

bool is_editor(editor* E);

editor* editor_new();                    /* Creates a new, empty text buffer */
void editor_forward(editor* E);          /* Moves the cursor forward (right) */
void editor_backward(editor* E);         /* Moves the cursor backward (left) */
void editor_insert(editor* E, char c);   /* Insert a character before cursor */
void editor_delete(editor* E);           /* Remove character before cursor   */
void editor_up(editor* E);               /* Moves the cursor up              */
void editor_down(editor* E);             /* Moves the cursor down            */


/*** Implementation ***/

bool is_editor(editor* E) {
  return E != NULL
    && is_tbuf(E->buffer)
    && E->row == tbuf_row(E->buffer)
    && E->col == tbuf_col(E->buffer);
}

editor* editor_new()
//@ensures is_editor(\result);
{
  editor* E = alloc(editor);
  E->buffer = tbuf_new();
  E->row = 1;
  E->col = 0;
  return E;
}

void editor_forward(editor* E)
//@requires is_editor(E);
//@ensures is_editor(E);
{
  if (tbuf_at_right(E->buffer)) return;

  if ('\n' == E->buffer->cursor->data) {
    E->row += 1;
    E->col = 0;
  } else {
    E->col += 1;
  }

  tbuf_forward(E->buffer);
}

void editor_backward(editor* E)
//@requires is_editor(E);
//@ensures is_editor(E);
{
  if (tbuf_at_left(E->buffer)) return;
  tbuf_backward(E->buffer);

  if ('\n' == E->buffer->cursor->data) {
    E->row -= 1;
    E->col = tbuf_col(E->buffer);
  } else {
    //@assert E->col > 0;
    E->col -= 1;
  }
}

void editor_insert(editor* E, char c)
//@requires is_editor(E);
//@ensures is_editor(E);
{
  tbuf_insert(E->buffer, c);

  if (c == '\n') {
    E->row += 1;
    E->col = 0;
  } else {
    E->col += 1;
  }
}

void editor_delete(editor* E)
//@requires is_editor(E);
//@ensures is_editor(E);
{
  if (tbuf_at_left(E->buffer)) return;

  if (tbuf_delete(E->buffer) == '\n') {
    E->row -= 1;
    E->col = tbuf_col(E->buffer);
  } else {
    //@assert E->col > 0;
    E->col -= 1;
  }
}

void editor_up(editor* E)
//@requires is_editor(E);
//@ensures is_editor(E);
{
  if (E->row == 1) return;

  int col = E->col;      // Remember current column

  editor_backward(E);    // Go back at least one character
  // Go to previous line
  while (E->buffer->cursor->data != '\n')
    editor_backward(E);

  // Go to original column, if possible
  while (E->col > col)
    editor_backward(E);
}

void editor_down(editor* E)
//@requires is_editor(E);
//@ensures is_editor(E);
{
  int col = E->col;                 // Remember current column
  dll* cursor = E->buffer->cursor;  // Rememeber current cursor

  // Go to next line or end of buffer
  bool newline = false;
  while (!tbuf_at_right(E->buffer) && !newline) {
    newline = E->buffer->cursor->data == '\n';
    editor_forward(E);
  }

  // If there was no next line, restore editor
  if (!newline) {
    E->col = col;
    E->buffer->cursor = cursor;
    return;
  }
  //@assert E->buffer->cursor->prev->data == '\n';
  // Go to original column, if possible
  while (   !tbuf_at_right(E->buffer)        // Not at end of buffer
         && E->col < col                     // not past col
         && E->buffer->cursor->data != '\n') // Stop at new line
    editor_forward(E);
}
