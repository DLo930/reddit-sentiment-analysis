\section*{Linked list segments%
\TAGS{ds-invariant, linked-list}}
\begin{lstlisting}[numbers=left]
struct list_node {
    int data;
    struct list_node* next;
};
typedef struct list_node list;

bool is_segment(list* start, list* end) {
    if (start == NULL) return false;
    if (start == end) return true;
    return is_segment(start->next, end);
}

struct linkedlist_header {
     list* start;
     list* end;
};
typedef struct linkedlist_header linkedlist;

bool is_linkedlist(linkedlist* L) {
    if (L == NULL) return false;
    return is_segment(L->start, L->end);
}
\end{lstlisting}

In lecture, we talked about the \lstinline'is_segment(start, end)'
function that tells us we can start at \lstinline'start', follow
\lstinline'next' pointers, and get to \lstinline'end' without ever
encountering a \lstinline'NULL'. (We won't worry about the problems
with getting \lstinline'is_segment' to terminate in this recitation.)
A \lstinline'linkedlist' is a non-\lstinline'NULL' pointer that
captures a reference to both the start and end of a linked list.

Here's an example of a specification function that uses
\lstinline'is_segment' as a precondition.

\begin{lstlisting}[numbers=left]
bool eq(list* start1, list* end1, list* start2, list* end2)
//@requires is_segment(start1, end1);
//@requires is_segment(start2, end2);
{
   if (start1 == end1 && start2 == end2) return true;
   if (start1 == end1 || start2 == end2) return false;
   return start1->data == start2->data
       && eq(start1->next, end1, start2->next, end2);
}
\end{lstlisting}
Why are the pointer dereferences on line 7 and 8 safe?

\answerline{Because \lstinline'is_segment' ensures that the pointers
  are not \lstinline'NULL'.}
