\section*{Basic syntax for C0 programs%
\TAGS{syntax}}

\paragraph{Semicolons:}
Statements are terminated by semicolons.  At the end of most lines,
you'll need a semicolon.  (Exceptions are \lstinline'if' statements,
function definitions, \lstinline'#use' statements, and loops.)

\paragraph{Types:}
Some of the types in C0 are:
\begin{itemize}
\item\lstinline'int': %
  Integers $x$, where $-2^{31} \leq x < 2^{31}$.
\item\lstinline'bool': %
  Either \lstinline'true' or \lstinline'false'. Useful for
  conditionals, loops, and more.
  \begin{itemize}
  \item%
    \lstinline'a || b' is true if either \lstinline'a' or
    \lstinline'b' are true
  \item%
    \lstinline'a && b' is true if both \lstinline'a' and
    \lstinline'b' are true
  \item%
    \lstinline'!a' is true if \lstinline'a' is false
  \item%
    \lstinline'x < y', \lstinline'x <= y', \lstinline'x > y',
    \lstinline'x >= y' all compare two integers \lstinline'x' and
    \lstinline'y' and return a \lstinline'bool'
  \item%
    \lstinline'x == y' and \lstinline'x != y' compare most C0 types
    and return a \lstinline'bool'. You can't compare strings this way,
    though, and it's usually bad style if you're writing code like
    \lstinline'e == true'.
  \end{itemize}
\item\lstinline'string': %
  An ordered sequence of characters encloded in double quotes like \lstinline|"Hello!"|
\item\lstinline'char': %
  A single character enclosed in single quotes, like \charconst{c}, \charconst{z},
  \charconst{F}, or \charconst{?}.
\end{itemize}

\textbf{Boolean operators:} Both \lstinline'&&' and \lstinline'||' are
\emph{short-circuiting infix operators}.

They are \emph{infix} (like other operators \lstinline'+',
\lstinline'-',
\lstinline'%', etc.) because they take two arguments and the operator
is placed between the two arguments. The compiler mentions the word
"infix operator" if you make a mistake with them, so it's good to be
aware of this name for them.

They are \emph{short-circuiting} because, if the expression to the
left of \lstinline'&&' evaluates to \lstinline'false' or if the
expression to the left of \lstinline'||' evaluates to
\lstinline'true', then the expression to the right will never get
executed. This means that, even though evaluating the expression
\lstinline'y/x == 0' will cause an error if \lstinline'x' is zero,
evaluating the expression \lstinline'x == 0 || y/x == 0' can never
cause an error.

\paragraph{Locals:}
locals (also called ``local variables,'' ``assignable
variables,'' ``assignables,'' or ``variables'') are explicitly
declared along with their type.  Locals can never change type after
they are declared.
\begin{quote}\vspace*{-1ex}
\begin{lstlisting}[numbers=left]
int x = 5;                    // x is initialized to 5
int y;                        // We can't use y until we assign to it!
string str = "hello";
y = x + 4;                    // y is now equal to 9
x = x + 1;                    // x is now equal to 6
x = "world";                  // ERROR! string and int are different types!
\end{lstlisting}
\end{quote}

\paragraph{Conditionals:}
These are one way we use \lstinline'bool' values. Here's an example of
\lstinline'if' statements in C0:
\begin{lstlisting}
if (condition) {
    //do something if condition == true
}
else if (condition2) {
    //do something if condition2 == true and condition == false
}
else {
    //do something if condition == false and condition2 == false
}
\end{lstlisting}


\paragraph{Loops:}
There are two kinds of loops in C0 --- \lstinline'while' loops and
\lstinline'for' loops.
\begin{itemize}
\item \lstinline'while' loop: %
  It takes a condition (something that evaluates to a Boolean). The
  loop executes until the condition is false.
\item \lstinline'for' loop: %
  It takes three statements separated by semicolons. Execute the first
  statement once at the beginning of the loop, loop until the second
  statement (a condition) is false, and execute the third statement at
  the end of each iteration.
\end{itemize}
\begin{center}
\smalllistings
\begin{tabular}{p{120px} p{180px}}
  \lstinline'while' loop & \lstinline'for' loop
\\\hline
\begin{lstlisting}[aboveskip=0pt, belowskip=-4ex]
int x = 0;
while (x < 5) {
    printint(x);
    print("\n");
    x++;
}
\end{lstlisting}
 &
\begin{lstlisting}[aboveskip=0pt, belowskip=-4ex]
for (int x = 0; x < 5; x++) {
    printint(x);
    print("\n");
}
\end{lstlisting}
\end{tabular}
\end{center}

These two examples do the same thing.  Here, the \lstinline'for' loop is
preferred but there are cases (like binary search in an array, which
we'll discuss later this semester) where \lstinline'while' loops are
cleaner.

\paragraph{Function definition:}
This example defines a function called \lstinline'add' that takes two
\lstinline'int's as arguments and returns an \lstinline'int'.
\begin{lstlisting}
int add (int x, int y) {
    return x + y;
}
\end{lstlisting}

\paragraph{Comments:}
Use \lstinline'//' to start a single line comment and %
\lstinline'/*  ... */' for multi-line comments.
% It's good style to have a \lstinline'*' at the beginning of each line
% in a multi-line comment.


\paragraph{Indentation and braces:}
Your code will still work if it's not indented well, but it's really
bad style to indent poorly.  Python's indentation rules are good and
you should generally follow them in C0 too.  C0 uses curly braces
(i.e., \lstinline'{' and \lstinline'}') to denote the starts and ends
of blocks, as seen above. For single-line blocks it's possible to omit
the curly braces, but that can make debugging very difficult if you
later add in another line to the block of code.  For that reason, you
may want to use braces, even for single-line statements.

\begin{center}
\smalllistings
\begin{tabular}{p{140px}p{140px}p{140px}}
   Very Bad & Okay & Good
\\\hline
\begin{lstlisting}[aboveskip=0pt, belowskip=-4ex]
if (x == 4)
println("x is 4");
\end{lstlisting}
 &
\begin{lstlisting}[aboveskip=0pt, belowskip=-4ex]
if (x == 4)
    println("x is 4");
\end{lstlisting}
 &
\begin{lstlisting}[aboveskip=0pt, belowskip=-4ex]
if(x == 4) {
    println("x is 4");
}
\end{lstlisting}
\end{tabular}
\end{center}
