\checkpoint*{\TAGS{c-memory}}

Rewrite \lstinline[language=C]'bst_new' (which should take in a
pointer to a ``freeing function'') and
\lstinline[language=C]'bst_insert' into C, and write the function
\lstinline[language=C]'bst_free', which frees all the memory that the
BST is responsible for.

\bgroup
\smalllistings
\begin{lstlisting}[numbers=left, language=C]
typedef int compare_fn(void* e1, void* e2);

typedef struct tree_node tree;
struct tree_node {
  void* data;
  tree* left;
  tree* right;
};

typedef struct bst_header bst;
struct bst_header {
  tree* root;
  compare_fn* compare;
};

bst* bst_new(compare_fn* compare)
//@requires compare != NULL;
//@ensures is_bst(\result);
{
  bst* B = alloc(struct bst_header);
  B->root = NULL;
  B->compare = compare;
  return B;
}

tree* tree_insert(tree* T, void* e, compare_fn* compare)
//@requires e != NULL && compare != NULL && is_tree(T, compare);
//@ensures is_tree(\result, compare);
{
  if (T == NULL) {  /* create new node and return it */
    T = alloc(struct tree_node);
    T->data = e;
    T->left = NULL; T->right = NULL;
    return T;
  }
  int r = (*compare)(e, T->data);
  if (r == 0) {
    T->data = e;               /* modify in place */
  } else if (r < 0) {
    T->left = tree_insert(T->left, e, compare);
  } else {
    //@assert r > 0;
    T->right = tree_insert(T->right, e, compare);
  }
  return T;
}

void bst_insert(bst* B, void* e)
//@requires is_bst(B);
//@requires e != NULL;
//@ensures is_bst(B);
{
  B->root = tree_insert(B->root, e, B->compare);
  return;
}
\end{lstlisting}

\begin{solution}
\begin{lstlisting}[numbers=left, language=C]
#include "bst.h"
#include "xalloc.h"
#include "contracts.h"

typedef int compare_fn(void *e1, void *e2);
typedef void free_fn(void *e);

typedef struct tree_node tree;
struct tree_node {
  void *data;
  tree *left;
  tree *right;
};

typedef struct bst_header bst;
struct bst_header {
  tree *root;
  compare_fn *compare;
  free_fn *elemfree;
};

bst *bst_new(compare_fn *compare, free_fn *elemfree) {
  REQUIRES(compare != NULL);
  bst *B = xmalloc(sizeof(struct bst_header));
  B->root = NULL;
  B->compare = compare;
  B->elemfree = elemfree;
  ENSURES(is_bst(B));
  return B;
}

tree *tree_insert(tree *T, void *e, compare_fn *compare) {
  REQUIRES(e != NULL && compare != NULL && is_tree(T, compare));
  if (T == NULL) {  /* create new node and return it */
    T = xmalloc(sizeof(struct tree_node));
    T->data = e;
    T->left = NULL; T->right = NULL;
    ENSURES(is_tree(T, compare));
    return T;
  }
  int r = (*compare)(e, T->data);
  if (r == 0) {
    T->data = e;               /* modify in place */
  } else if (r < 0) {
    T->left = tree_insert(T->left, e, compare);
  } else {
    ASSERT(r > 0);
    T->right = tree_insert(T->right, e, compare);
  }
  ENSURES(is_tree(T, compare));
  return T;
}

void bst_insert(bst *B, void *e) {
  REQUIRES(is_bst(B));
  REQUIRES(e != NULL);
  B->root = tree_insert(B->root, e, B->compare);
  ENSURES(is_bst(B));
  return;
}
\end{lstlisting}
\end{solution}

Write \lstinline[language=C]'bst_free' here:
\begin{solution}
\begin{lstlisting}[numbers=left]
void tree_free(tree *T, free_fn *elemfree) {
  if (T != NULL) {
    if (elemfree != NULL) {
      (*elemfree)(T->data);
    }
    tree_free(T->left, elemfree);
    tree_free(T->right, elemfree);
    free(T);
  }
  return;
}

void bst_free(bst B) {
  REQUIRES(is_bst(B));
  tree_free(B->root, B->elemfree);
  free(B);
  return;
}
\end{lstlisting}
\end{solution}
\egroup
