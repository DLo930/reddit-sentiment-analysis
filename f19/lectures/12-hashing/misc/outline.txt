LAST-2: using stacks
LAST-1: implementing stacks
LAST: amortized analysis, unbounded arrays
TODAY:
- genericity I
  . void*
- hashing
  . dictionaries
  . hash tables
  . randomness
NEXT: implementing hash tables

Important concepts (5 = highest, 1 = lowest)
============================================
[4] semi-generic DS (via elem type)
[3] compiling semi-generic DS
[5] void*, cast, \hastag
[5] genericity with void*

[5] dictionaries as key/entry pair (also key/value pairs)
[5] operations on dictionaries (insert, lookup)
[4] cost of various dictionary implementations
[1] dictionaries in other programming languages
[3] sets as dictionaries where key=entry
[5] hash tables (high level)
[5] collisions
[4] open addressing (linear probing) HT
[5] separate chaining HT
[5] cost analysis of separate chaining HT
[5] unpredictability via prng
[2] linear congruential generator
[4] non-numerical keys
[5] hash functions


PART I [keep this whole part to 30 minutes]
######

Genericity I
============
[organization: use 2 different frames split in various views
 1. c0 frame:
    - stack.c0 (left)
    - stack-client.c0 (top right, introduced later)
    - main.c0 (top bottom)
 2. c1 frame:
    - stack.c1 (left)
    - main.c1 (right)]
- original interface for stacks
  . element was a string
- but a stack works the same whatever elements are in it
  . operations do not USE elements, just shuttle them around
  . stacks are conceptually GENERIC DATA STRUCTURES, but interface specialized to a specific element type
    . they work the same way no matter the type of the data in them
- can we make stacks generics?  first idea
  . define customizable type elem for elements and have operations work on elem
  . client must define element to type he/she needs
      typedef int elem;               // ADDED
  . must occur before stack library
  . client split into 2 parts
    . stack-client.c0 -- containing just typedef
    . client-main.c0  -- use of stack with elem as element
        typedef struct list_node list;
        struct list_node {
          elem data;                       // CHANGED
          list* next;
        };
  . compilation pattern:
      # cc0 stack-client.c0 stack.c0 stack-main.c0
- does it solve problem?
  . yes: same library can be used for any type of elements
  . no: client cannot use 2 stacks with different element types in program
- no way to do better than this in C0

Generic pointers
================
- language C1 extends C0 with mechanism to solve this problem: GENERIC POINTERS
  . type void*
    . name borrowed from C (nothing to do with void)
    . any pointer can be turned into a void*, and later back to its original type
  . GENERICITY LIMITED TO POINTER TYPES
- fully generic stacks (as long as element are pointers)
      typedef void* elem;
  . goes in stack implementation
  . nothing else changes in stack library
- on client side, CAST is an operation to convert a pointer to void* and vice versa
- cast is the only operation that can be performed on values of type void*
  . in particular, we cannot dereference a void*
- defining a stack of strings in the same program
      stack_t S = stack_new();
      string* s = alloc(string); // must put each string into a cell in allocated memory
      *s = "hello";
      push(S, (void*)s);         // s cast to void* before being pushed onto stack
      print(*(string*)pop(S));   // result of pop cast to string* before accessing int
- defining a stack of integers
      stack_t I = stack_new();
      int* x = alloc(int);
      *x = 42;
      push(I, (void*)x);
      int* y = (int*)pop(I);
      printint(*y);
- syntax is annoying (blame C), but gets us generic stack!
  . other languages do much better!
- no need for client-stack.c1 file
- compilation pattern
      # cc0 stack.c1 stack-main.c1
- coin does not support c1 features (only cc0)

\hastag
=======
- pointer cast to void* can only be used sensibly if cast back to the original type
  [draw local/allocated memory]
     int* x = alloc(int);
     *x = 42;                 // x is an int*
     void* p = (void*)x;      // p secretly points to an int
     string* s = (string*)p;  // turning an int* into a string*??
     print(*s);               // makes no sense!
  . casting back to wrong type is a MEMORY ERROR
    . (string*)(void*)x is a SAFETY VIOLATION
- pointers of type void* secretly carry a TAG recording their real type
- \hastag(tp, ptr) can be used in contracts to check that ptr has type tp
     //@assert \hastag(int*, p);    // succeeds
     //@assert \hastag(char*, p);   // fails
     //@assert !\hastag(char*, p);  // succeeds
  . used in contract to ascertain void* has right underlying type
- exception: NULL
  . NULL has any pointer type
  . a NULL pointer of type void* can be cast to any other pointer type
      void* q = NULL;
      void* r = (void*)(int*)(void*)(string*)q;  // weird but legal
- implicit preconditions of cast
  . (void*)x, where x has type tp*:
    //@ensures \hastag(tp*, \result);
  . (tp*)y, where y has type void*
    //@requires \hastag(tp*, y);
- only operations allowed on value p of type void*:
  . cast to other pointer type -- (int*)p
  . compare to another void* value -- p == q
    . compare to NULL -- p == NULL


<break>

PART II [make sure to finish: hw depends on it]
#######

Reflecting on arrays
====================
- so far, we used arrays in one of 2 ways
  1) as a way to keep a collection of elements of the same type in 1 place
     . e.g., the words of the Collected Works of William Shakespeare (CWoWS)
     . works like a SET
     . main operations
       . add an element
       . tell whether an element is there (using search)
       . (go through all elements -- e.g., to print them)
     . where an element is in the array isn't important (search returns index)
  2) as a MAPPING from indices to VALUES
     . e.g., the array that for each i tells you the first word with frequency i in the CWoWS
     . works like a DICTIONARY
     . main operations
       . add an element (INSERT)
       . return the data (value) associated with an index (LOOKUP)
     . [dictionaries (self-implemented) are being used in clac/exp]
- next 3 lectures: make operations of 1) and 2) very efficient for large collection

Dictionaries (aka maps aka associative arrays)
============
- array A is a mapping i |-> e where e = A[i]
- e is called the VALUE or ENTRY at i
  . in a C0 array, can be anything we want (as long as all entries have the same type)
- i is called the KEY
  . in a C0 array, key is an integer from 0 to a pre-specified maximum (length of array)
  . there is exactly one entry for each valid key
- dictionary: mapping k |-> e where key can be any kind of information
  . key drawn from non-contiguous interval of numbers: e.g., zip codes in use
    . 5 digits, so from 00000 to 99999 -- array-like, but
    . only 43,000 of the 100,000 possible zip codes are in use
      . wasteful to allocate 100,000-element array to tabulate where students come from
    . 00000 is not a valid zip code
    . keys are sparse
    . at most 1 entry for each valid key
  . key may not be a number at all
    . e.g., student id
  . e in k |-> e is an ENTRY when k is part of e, and a VALUE otherwise

Implementing dictionaries
=========================
- how would we do it based on what we know so far?
  [students are writing one for clac/exp -- poll how they did it]
- cost of various operations for n-entry dictionaries:
--------------------------------------------------------------------------
          (unsorted) array with    (key,value) array      linked list with
          (key,value) content      sorted by key          (key,value) data

lookup    O(n)                     O(log n) [binsearch]   O(n)

insert    O(1)  amortized          O(n)                   O(1)
--------------------------------------------------------------------------
- lookup/insert are fast when we KNOW WHERE TO LOOK FOR SOMETHING
- this lecture: get both ABOUT O(1)

Dictionaries in the wild
========================
- dictionaries are primitive data structures in many programming languages
  (e.g., Python, PHP, Javascript)
- PHP demo [do only if time -- generally not]
      # php -a
      php > $A[0] = 3;
      php > echo $A[0];
      3
      php > $A[1] = 7;
      php > $A[15122] = 11;
      php > echo $A[15122];
      11
      php > echo $A[3];
      PHP Notice:  Undefined offset: 3 in php shell code on line 1
      php > $A["hello world"] = 13;
- dictionaries are not primitive in lower-level languages like C (and C0)

Sparse dictionaries as hash tables
==================================
- example: we want to know the neighborhood name of the zip code of each student in this class
  . key = zip code
  . value = neigborhood name [later extended with zip code itself --> entry]
  . about 200 people, many shared zip codes
    . allocating a 100,000 element array would be wasteful!
- idea: allocate a much smaller m-element array (m=5 element for simplicity)
  . reduce 5-digit zip code to a valid index in range 0-4
  . e.g., zip code % 5
  . in general: numerical key % m
  . this is the first step towards a HASH TABLE
  [draw 5-element array vertically on board; enter just values initially, then keys too and
   finally focus just on keys]
[what follows should be a review from 15-112]
- insert (15213, "CMU") -- spoil joke about 15-213 being the course that gives CMU its zip
  . O(1)
- insert (15122, "Kennywood") -- happiest place in Pittsburgh
  . O(1)
- lookup 15213
  . returns "CMU", O(1)
- lookup 15122
  . returns "Kennywood", O(1)
- lookup 15217 (Squirrel Hill)
  . returns "Kennywood", O(1) -- but it should say it's NOT THERE
  . we need to STORE THE KEY to be able to answer (also previous operations)
  . except for native arrays, key need to be recorded as part of entry
    [and we need a way to compare recorded key with lookup key -- next time]
    [technicality: we can make keys only with quantities that can be checked for equality]
- insert (15217, "Squirrel Hill")
  . position already occupied
  . element in there has a different key
  . COLLISION
- collisions are inevitable in practice
  . if # entries > m: pigeonhole principle
  . in general: birthday paradox

[other fun zip codes:
  90210 Beverly Hills
  10101 New York NY
  89412 Black Rock City, NV (Burningman)
  20500 White House
  15206 Bakery Square
  44444 Newton Falls, OH
  12345 GE World Hqtrs
  94043 Googleplex]

Dealing with collisions
=======================
- OPEN ADDRESSING
  . look for an empty slot somewhere predictable
    . LINEAR PROBING: next position, then next-next, etc.
      . like when your seat is taken by somebody else
    . how to lookup a key?
      . same as insert until we find key or end up on an empty slot (or visited all m elements)
    [will be discussed much more in lab]
  . this is how predefined dictionaries in other programming languages tends to be implemented
  [draw example]
- SEPARATE CHAINING
  . array does not contain entries but a BUCKET with all entries that go in this position
    . like filing emails in folders
  . bucket is typically a CHAIN -- a NULL-terminated linked list (other options are possible)

Maximum number of entries
=========================
- open addressing
  . m (size of array)
  . but we know how to grow arrays efficiently!
- separate chaining
  . unlimited: chains can grow arbitrarily large

Cost analysis of separate chaining
==================================
- we have an array of size m and a total of n entries in the hash table
- how long does it take to lookup an entry?
  . same for insert since we need to check that entry with same key is not there already
- worst case [ask audience]
  . O(n) all but 1 bucket are empty and we are looking there
    [draw picture]
  . this is the worst possible layout -- hash table from hell
- what is the best possible layout? [ask audience]
  . all indices contain buckets with the same number of elements -- ideal hash table
    [draw picture]
    . n/m entries per bucket
    . this is the LOAD FACTOR
    . lookup is O(n/m)
- can we arrange so that n/m be CONSTANT?
  . keep track of n/m and resize table whenever it gets bigger than predefined threshold (e.g. 1)
  . cost becomes O(1) AMORTIZED
- when will we be in this ideal case?
  . when the indices associated with the keys in the table are UNIFORMLY DISTRIBUTED
    . this happens when the keys are chosen at random
  . if we insert entries with randomly chosen keys,
    . O(m/n) is the the AVERAGE COST of lookup
    . this is O(1) if n/m is kept below a constant through resizing
- can we arrange so that we are always in the ideal case?
  . in general, entries do not come with randomly chosen keys
    . e.g., if we were to base zip code indexing on first digit
      . many people from Pgh area (1xxxx), many from West Coast (9xxxx)
  . but yes ... if we can turn arbitrary keys to uniformly distributed numbers
- so far, index calculated as
      numerical key =[%m]=> array index
  . need also to make sure index is non-negative [hw]
- we want to map numerical key to number uniformly distributed over C0 integers
  . run it through a PSEUDO-RANDOM NUMBER GENERATOR
    . "random number generator": result is uniformly distributed
    . "pseudo": result is reproducible (deterministic)
      . otherwise key gets a different index each time!
- index calculated as
      numerical key =[prng]=> uniformly distributed number =[%m]=> array index
  . uniformly distributed number is called HASH VALUE
  . transformation from key to hash value is called HASH FUNCTION
      numerical key =[hash function]=> hash value =[%m]=> hash index
- with this, average cost is O(n/m), average amortized cost is O(1)
  . we can be unlucky, but it is extremely unlikely

Pseudo-random number generators
===============================
- in C0, rand library implements a LINEAR CONGRUENTIAL GENERATOR
      y = a * x + c mod d
  . in C0, d = 2^32 to get full range of 32-bit int's (and piggyback on modular arithmetic)
  . c != 0 and c,d relatively prime for best results (uniform distribution)
- good for hashing, but not cryptographic strength

Non-numerical keys
==================
- need a function that maps the key (e.g., andrew id, date, ...) to number
- then do as for numerical keys
      key =[transformation]=> number =[prng]=> hash value =[%m]=> array index
  . overall transformation from key to hash value is called HASH FUNCTION
      key =[hash function]=> hash value =[%m]=> hash index
- [example in recitation]

Dictionaries summary
====================
------------------------------------------------------------------------------------------------
          (unsorted) array with    (key,value) array      linked list with   hash table
          (key,value) content      sorted by key          (key,value) data

lookup    O(n)                     O(log n) [binsearch]   O(n)               O(n/m) average
                                                                             O(1) avg amortized

insert    O(1) [amortized]         O(n)                   O(1)               O(n/m) average
                                                                             O(1) avg amortized
------------------------------------------------------------------------------------------------

Sets
====
- a dictionary where the entry is the key
- lookup just needs to return true or false (called "contains")
