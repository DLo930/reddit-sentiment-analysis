/******** Client Interface ******/
typedef void* elem;      // Element type

// f(e1,e2) returns true if e1 is STRICTLY higher priority than e2
typedef bool has_higher_priority_fn(elem e1, elem e2);


/**** Library Implementation ****/

typedef struct heap_header heap;
struct heap_header {
  int limit;                      // limit = capacity+1
  elem[] data;                    // \length(data) == limit
  int next;                       // 1 <= next && next <= limit
  has_higher_priority_fn* prior;  // != NULL
};

// ...


typedef heap* pq_t;

/****** Library Interface *******/

// typedef ______* pq_t;

bool pq_empty(pq_t Q)
/*@requires Q != NULL; @*/ ;

bool pq_full(pq_t Q)
/*@requires Q != NULL; @*/ ;

pq_t pq_new(int capacity, has_higher_priority_fn* prio)
/*@requires capacity > 0 && prio != NULL; @*/
/*@ensures \result != NULL && pq_empty(\result); @*/ ;

void pq_add(pq_t Q, elem x)
/*@requires Q != NULL && !pq_full(Q) && x != NULL; @*/
/*@ensures  !pq_empty(Q); @*/ ;

elem pq_rem(pq_t Q)
/*@requires Q != NULL && !pq_empty(Q); @*/
/*@ensures  \result != NULL && !pq_full(Q); @*/ ;

elem pq_peek(pq_t Q)
/*@requires Q != NULL && !pq_empty(Q); @*/
/*@ensures  \result != NULL; @*/ ;
