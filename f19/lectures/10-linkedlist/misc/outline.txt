LAST: Stacks, queues
TODAY:
- linked lists
- implementing stacks and queues
NEXT: Better arrays

Important concepts (5 = highest, 1 = lowest)
============================================
[3] limitation of arrays
[5] concept/definition of linked list
[5] type declaration for linked list
[4] options for end-of-list/empty list
[5] list segments, validation
[4] navigating a linked list using a for loop
[5] problem with cyclic lists
[2] cycle detection algorithm
[5] inserting/deleting element at the beginning/end of a list segment
[5] implementing queues with list segments
[3] implementing stacks as list segments
[1] functional stack interface
[2] sharing

Review
======
- stacks, queues
- client/interface/implementation
- pointers and structs
- today: implementation of queues (and stacks)
- historical note about today's lecture:
  . if you understand it, things will be rather easy from now on
  . if not, you will have a hard time

How to implement queues?
========================
- a bunch of elements of the same type
- do we know a data structure like that?  arrays
- can we use an array?  [ask for answers]  typical answers
  . yes? follow-up: where would the front and the back be? (and then into circular buffers)
  . no: no way to add/remove elements [discuss]
  . no: arrays have fixed length, but queues don't
    [somebody always brings up resizable arrays -- next lecture]
- we would like something like an array but where
  . we can add/remove an element at the beginning/end
  . grow as much as we need
- what about a disembodied array?
         -------------
  A -->  | 3 | 7 | 2 |
         -------------
  becomes
         -----  -----  -----
  A -->  | 3 |  | 7 |  | 2 |
         -----  -----  -----
- how do we reach the elements after the first?
  . idea, use a pointer to keep track of their address
         -------  -------  -------
  A -->  | 3 |*|->| 7 |*|->| 2 | |
         -------  -------  -------

Linked lists
============
- this is called a LINKED LIST
- let's capture this in type definition
    struct list_node {
      int data;
      struct list_node* next;
    };
    typedef struct list_node list;   <-- because we always do this
- this is an example of a RECURSIVE DATA STRUCTURE
  . the definition of struct list_node has a field of type struct list_node
- what happens if we omit the *? (beside not matching the picture)
  . requires an infinite amount of memory
  . C0 disallows it
- we can even make it easier to read by writing
    typedef struct list_node list;
    struct list_node {
      int data;
      list* next;
    };
- in-class activity
  [seats are numbered in lecture halls,
   ahead of class give a few students coordinates of 'next' seat]
  . ask student to say his/her name (data) and next seat
  . have them point there
  . purpose: have them realize that nodes are scattered in memory
    . even though we draw them neatly on the board
  . have a variant with NULL as next field
  . contrast with arrays: a row of students next to each other
- does this help us implement queues?
  . linked list can grow to arbitrary length
  . easy to insert an element at the beginning
  . in fact, easy to insert an element between any two nodes
  . what about inserting an element at the end?
- how do we indicate the end of a linked list? [audience participation]
  . NULL -- we will use that later in the semester
  . node points to itself -- a bit weird but why not
  . keep track of end-node -- this will be convenient today
  --> in all cases, have the end of list be a special pointer

List segments
=============
- keeping track of end-node [only approach considered today]
     start             end
     v                 v
     -------  -------  -------
     | 3 |*|->| 7 |*|->| 2 |*|-> ...
     -------  -------  -------
  . start and end are just list* pointers
  . we call this a LIST SEGMENT and consider the start node inclusive and the end node exclusive:
    [start, end)
    . just like array segments: A[lo,hi)
    . this segment contains elements 3 and 7 (not 2)
    . note that we don't care what's in the field of node end
      . called a DUMMY NODE (indicated with X)
    . do a couple of examples of segments, including empty segment
- let's write a specification function that checks that two pointers bracket a list segment
      bool is_segment(list* start, list* end) {
        list* l = start;
        while (l != NULL) {
          if (l == end) return true;
          l = l->next;
        }
        return false;
      }
  [if desired, start with a version without the NULL check -- loop guard is (l != end)]
  . we can also write this using a for loop -- convenient idiom when traversing lists
      bool is_segment(list* start, list* end) {
        for (list* p = start; p != NULL; p = p->next) {
          if (p == end) return true;
        }
        return false;
      }
  . we can also write it recursively
      bool is_segment(list* start, list* end) {
        if (start == NULL) return false;
        return start == end || is_segment(start->next, end);
      }
  . recursive version parallels the recursive definition of a list:
    . base case when the list is NULL (i.e., it does not point to a struct)
    . recursive case the list is not NULL

Cycles
======
- will is_segment(start,end) always return true when [start, end) is a valid list segment?
  . yes
- will it always return false when it is not valid?
  . only if start is NULL-terminated
  . loops forever if it contains a CYCLE
     start                           end
     v                               v
     -------   -------   -------     -------
     | 3 |*|-->| 7 |*|<->| 2 |*|     | 9 |*|--> ...
     -------   -------   -------     -------
  . how to detect there is a cycle? [audience participation] typical answers
    . keep a counter and return false if it overflows
      . may take a really long time even for short lists
      . C0 addresses are 64 bits while int's are 32
        . a linked list can have more elements than there are int's!
          (computer may run out of memory before that)
    . add number of elements as an argument to is_segment
      . int's are not big enough
    . put visited pointers somewhere
      . where? another list?
    . add a visited field to list_node
      . need to know it's acyclic to set it to false initially
    . tortoise and hare algo [there's always somebody who has read the lecture notes]
      . sketch idea on board, refer to lecture notes [good exam prep]
        [there is typically not enough time to write/look at code]
      bool is_acyclic(list* start) {
        if (start == NULL) return true;
        list* h = start->next;         // hare
        list* t = start;               // tortoise
        while (h != t) {
          if (h == NULL || h->next == NULL) return true;
          h = h->next->next;
          //@assert t != NULL; // hare is faster and hits NULL quicker
          t = t->next;
        }
        //@assert h == t;
        return false;
      }
      . Trying to prove this algorithm correct (t != NULL will never evaluate to false)
        . usually ends up deep in the weeds
- call is_acyclic(start) before calling is_segment(start, end)

Implementing queues with list segments I
========================================
- define a queue as a list segment Q = [front, back) -- or vice-versa for now
  . dequeue from front
  . enqueue into back
- in code
      typedef struct queue_header queue;
      struct queue_header {
        list* front;
        list* back;
      };
- we can write the representation invariant right away
      bool is_queue(queue* Q) {
        return Q != NULL
            && is_acyclic(Q->front)
            && is_segment(Q->front, Q->back);    // or vice-versa for now
      }
  . is_segment implies that Q->front and Q->back are not NULL
- we can also write is_empty
      bool queue_empty(queue* Q)
      //@requires is_queue(Q);
      {
        return Q->front == Q->back;
      }
  . cost: O(1)
- and queue_new
      queue* queue_new()
      //@ensures is_queue(\result);
      //@ensures queue_empty(\result);
      {
        queue* Q = alloc(queue);
        list* dummy = alloc(list);
        Q->front = dummy;
        Q->back = dummy;
        return Q;
      }
  . cost: O(1)

Deletion from a list segment
============================
[start by using queues as case studies and then focus more on list segments]
- how do we REMOVE a value x from the BEGINNING of a non-empty list segment [start, end)
  [draw before/after pictures on the board and show how to go from one to the other]
  . code
    string x = start->data;
    start = start->next;
    return x;
  . cost: O(1)
- how do we REMOVE a value x from the END of a non-empty queue/list segment [start, end)
  [draw before/after pictures on the board and show how to go from one to the other]
  . show that we need to start at front and stop just before back
  . cost O(n)

Insertion into a list segment
=============================
- how do we INSERT a value x at the BEGINNING of a list segment [start, end)
  [draw before/after pictures on the board and show how to go from one to the other]
  . code
      list* l = alloc(list);
      l->data = x;
      l->next = start;
      start = l;
  . cost: O(1)
- how do we INSERT a value x at the END of a list segment [start, end)
  [draw before/after pictures on the board and show how to go from one to the other]
  . code
      list* new_dummy = alloc(list);
      end->data = x;
      end->next = new_dummy;
      end = new_dummy;
    [students will generally want to write x to new_dummy at first -- great opportunity
    to point out that pointing the last node to new_dummy would cost O(n)]
  . cost: O(1)
  . if time, talk about is_segment being preserved

Summary
=======
                  | beginning |    end    |
        -----------------------------------
        Insertion |   O(1)    |   O(1)    |
        -----------------------------------
        Deletion  |   O(1)    |   O(n)    |
        -----------------------------------
- guideline to implement queues (and stack) to achieve complexity goals

Implementing queues as list segments II
=======================================
- insert in back and remove from front
  . enq = insertion in back
    . replace 'end' with 'Q->back'
  . deq = removal from front
    . replace 'start' with 'Q->front'
- update code to include contracts


Implementing stacks as list segments I
======================================
- we need to insert and remove from same end: must be the beginning to ensure O(1)
- code
      typedef struct stack_header stack;
      struct stack_header {
        list* top;
        list* floor;
      };
  . push = insertion in top
  . pop  = removal from top
    . replace 'start' with S->top
  . other operations are the same as for queues


Implementing stacks as list segments II
=======================================
- we never use floor except to check empty stack
- suggests alternative implementation
  . get rid of floor field
  . have linked list be NULL-terminated
  [generally no time to show code updates]


Sharing
=======
- why not getting rid of top and defining
      typedef list* stack;
- breaks interface: NULL is the empty stack
- push and pop are now incorrect: they add/remove node but client pointer S remains the same
  . (aliasing)
- bad idea?  Not necessarily: we can make it work if we change our interface
  . push needs to RETURN (a pointer to) the updated stack
  . pop needs to return both the element and (a pointer to) the updated stack
- this a FUNCTIONAL IMPLEMENTATION of stacks
- because we return a new stack each time, all the old ones are still available
- what happens in memory?
  [draw stack S containing 3, 2, 1]
  . stack_t S1 = push(S, 4);
  . stack_t S2 = push(S, 5);
  [draw memory updates all along]
  . do pop(S) resulting in S3
- although we have now 4 stacks, they share the majority of their nodes
- this is called SHARING
- this DOES NOT WORK with queues
  . why? exercise


Linked lists vs. arrays [use in next lecture]
=======================
        (UNSORTED) ARRAYS       LINKED LISTS

PROS    O(1) access             self-resizing
        built-in                O(1) insertion (given right pointers)
                                O(1) deletion (given right pointers)

CONS   fixed size               no built-in support
       O(n) insertion           O(n) access
