LAST: end of part I
TODAY:
- pointers
- structs
- abstract data types
  . client/interface/library
  . data structure invariants
NEXT: using libraries

Important concepts (5 = highest, 1 = lowest)
============================================
[4] review of C0 memory model
[3] returning multiple values
[5] pointers
[5] NULL
[5] structs
[5] libraries, interface vs. implementation
[5] SSA interface development
[4] SSA implementation
[5] representation invariants
[1] testing

Review
======
- C0 language: contracts, ints, arrays
- deliberate programming (with arrays mainly)

Setting the scene for pointers
==============================
- recall C0 memory model (local/allocated memory)
- thought problem: how to have a function return 2 results?
  [from prog/struct-template.c0]
      // Return both the sum of all numbers in A and whether 42 occurs
      ??? sum_and_42(int[] A, int n)
      //@requires n == \length(A);
      {
        int sum = 0;
        bool has_42 = false;
        for (int i = 0; i < n; i++) {
          sum += A[i];
          if (A[i] == 42) has_42 = true;
        }
      }

      int main() {
        int[] A = alloc_array(int, 10);
        for (int i = 0; i < 10; i++) A[i] = i - 5;

        ??? = sum_and_42(A, 10);

        return 0;
      }
- C0 can return a single value; what about the other one?
- if we are able to have a box in allocated memory,
  . main can pass the address to sum_and_42
  . sum_and_42 puts one of the results there
  . main retrieves it from the box
  (exploit aliasing)
- we can use a 1-element array, but C0 provides a simpler way to do so

Pointers
========
- create a cell in allocated memory containing a single int [coin session]
    --> int* p = alloc(int);
    p is 0x1634010 (int*)
- p is a POINTER to this cell
  . access its value as *p [returns 0]
    . C0 always initializes allocated memory to default values
  . change its value with *p = 3;
- pointers live in allocated memory
  . subject to aliasing (int* q = p)
  . that's what allows us to solve the problem above [do quickly]
    [from prog/struct.c0] return both sum and has_42 through allocated memory:
      void sum_and_42(int[] A, int n, int* sum, bool* has_42)  // CHANGED
      //@requires n == \length(A);
      {
        *sum = 0;                                              // CHANGED
        *has_42 = false;                                       // CHANGED
        for (int i = 0; i < n; i++) {
          *sum += A[i];                                        // CHANGED
          if (A[i] == 42) *has_42 = true;                      // CHANGED
        }
      }

      int main() {
        int[] A = alloc_array(int, 10);
        for (int i = 0; i < 10; i++) A[i] = i - 5;
        int*  sum  = alloc(int);                               // ADDED
        bool* fourtytwo = alloc(bool);                         // ADDED
        sum_and_42(A, 10, sum, fourtytwo);                     // CHANGED

        return 0;
      }

NULL
====
- back to coin
      int** w = alloc(int*);
  . what does this do? create a cell that can hold a pointer to an int
  . what's in it?  (allocated memory created with default values)
      *w;
      --> NULL
  . what's NULL?
      **w;
      Error: null pointer was accessed
  . definitely not an address!
- pointer variables can take a special value, NULL, no matter their type
  . p = NULL  (drawn as ground symbol)
  why? we'll see next week
- NULL cannot be dereferenced: safety violation [coin demo]
  . *p has implicit precondition p != NULL
  . alloc has the implicity postcondition \result != NULL
  . we need to have a good reason to believe that a pointer is not NULL before dereferencing it
- very error-prone!
  . Tony Hoare, who came up with NULL, calls it the Billion Dollar Mistake
    http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
    (begins at 27:40)
    "All those problems, in the end, I didn't want to deal with, and that let me to suggest that
     the NULL pointer was a possible value of every reference variable; a possible mistake
     on every use of that reference variable. And perhaps it was a billion dollar mistake.

     Well, the world is gradually recovering from this variable, I'm glad to say."
- how to do so? contracts!  Extend sum_and_42 with
      //@requires sum != NULL && has_42 != NULL;
- other languages have better mechanisms (see 15-150)

Structs
=======
- in the last programming hw, an image was an array + a width + a height
  . every function that manipulated images took those 3 parameters
    . annoying
    . error-prone (e.g., swapping width and height)
    . conceptually wrong: we think of an image as ONE thing
      -> this morning you didn't put in your pocket a screen, a battery, an enclosure and
         some buttons; you put your phone in your pocket
- all modern languages provide a way to view a bunch of parts as a single entity
  . basis for an EXTRAORDINARY form of ABSTRACTION: modularity
    . manipulate the whole (image, phone, ...) through well-defined/abstract operations
    . no need to know about the details
    . that's the concept of a data structure: part II (and III) is all about that
- in C0 (and C): struct -- new way to create types
    struct image_header {
      int width;
      int height;
      pixel_t[] data;
    };
  . width, height and data are the FIELDS
- local memory can only hold small values (that fit in a word)
  . structs must live in allocated memory
  . accessed through pointers
      struct image_header* IMG = alloc(struct image_header);
  . names get very long: use typedef to provide abbreviated nicknames
      typedef struct image_header image;
    now
      image* IMG = alloc(image);
  . draw picture of memory and update throughout
  . how to access the fields of a struct?  2 ways:
    1. [SEE and FORGET]
         (*IMG).width = 3;
       "*IMG" follows the pointer to the struct, ".width" selects the width field
       needed sometimes in C, but not in C0
    2. [WHAT WE WILL BE USING EXCLUSIVELY]
         IMG->width = 3;
       simpler and completely equivalent
       Then,
         IMG->height = 2;
         IMG->data = alloc_array(int, 6);
       . safety condition: p->field has the pre-condition that p != NULL
- Now that we know about structs, can you think of another way to implement sum_and_42 ?


<< Break? >>


Libraries
=========
- one form of modularity we use a lot in C0 (and C, and ...)
  . other languages support more powerful forms
- library provides a type and operations to manipulate it
- client (= user) declares values of this type and uses these operations
- what the type and operations are is specified in the INTERFACE
- separation of concerns
  . library chooses concrete type and implementation of operations
  . client does not need to know how library is implemented
  . library can be replaced with a better one as long as the interface remains the same

  --------------------------
  | library implementation | implements types and operations      HOW
  --------------------------
  | library interface      | describes operations and contracts   WHAT
  --------------------------
  --------------------------
  | client application     | uses operations and values
  --------------------------

  . library = implementation + interface
  . client view: interface + client code
    . NOT implementation!

- this is a simple example of abstract data type


Example: self-sorting arrays (SSA)
==================================
- like arrays, but guarantee that elements are always sorted
  (we can then use binary search for example)
- SSAs contain strings (since we need to commit to something)

Interface
=========
[work on board or big gap in ssa-template between "Interface" comment and actual interface]
- we need to name the type of SSA's:
    // typedef _____ ssa_t;
  . CONVENTION: exported types end with "_t"
  . note that it's a comment
    . informs the client that the name of this type is ssa_t
    . actual typedef in implementation (only it knows the real underlying type)
- operations: just like arrays
  . ssa_t ssa_new(int size)                   // corresponds to alloc_array
  . string ssa_get(ssa_t A, int i)            // corresponds to ... A[i]
  . void ssa_set(ssa_t A, int i, string x)    // corresponds to A[i] = x
    . we are kicking out the i-th element
- what about their contracts?
    string ssa_get(ssa_t A, int i)            // corresponds to ... A[i]
    //@requires 0 <= i && i < \length(A);
  . but \length(A) is only allowed for C0 arrays, which are not sorted!
- we need a new operation:
  . int ssa_len(ssa_t A)
    //@ensures \result >= 0
  . update ssa_get to
    string ssa_get(ssa_t A, int i)
    /*@requires 0 <= i && i < ssa_len(A); @*/;
- because we must be able to define ssa_len, ssa_t cannot be a C0 array
  . what else?  pointer is only option!
  . update pseudo typedef to reflect this
    // typedef _____* ssa_t;
  . add NULL-checks everywhere (recall billion dollar mistake)
    string ssa_get(ssa_t A, int i)
    /*@requires A != NULL; @*/
    /*@requires 0 <= i && i < ssa_len(A); @*/;
  . any operation that takes an ssa_t has a NULL check as a precondition
  . any operation that returns an ssa_t has NULL check as a postcondition
[bring up full interface from down below]


Implementation I: types
=======================
[do this in the 'implementation' segment of ssa-template.c0: lots is pre-filled]
- library needs to pick a type
    struct ssa_header {
      string[] data;  // sorted
      int length;     // = \length(data)
    };
    typedef struct ssa_header ssa;
  . CONVENTIONS: inside implementation
    . we use type name that does not end in "_t"
    . this is not a pointer type (makes for simpler alloc)
- and connect it to the client type in the interface
    typedef ssa* ssa_t;
  . CONVENTION: we put it at the end of the implementation so we are not tempted to use it


Implementation II: operations
=============================
- write ssa_get with same contracts as in interface
    string ssa_get(ssa* A, int i)
    //@requires A != NULL;
    //@requires 0 <= i && i < ssa_len(A);
    {
      return A->data[i];
    }
- is it safe?
  . pointer dereference?  A != NULL by precondition
  . array access?
    . 0 <= i by precondition
    . i < \length(A->data) ... not supported
      . we can't point anywhere that say that ssa_len(A) == \length(A->data)
- write ssa_len
    int ssa_len(ssa* A)
    //@requires A != NULL;
    {
      return A->length;
    }
  . no postconditions to support safety of ssa_get.  Add
    //@ensures \result == \length(A->data);
  . is it correct?  No relation between A->length and \length(A->data)
    ["innocent" mistake: A->data = alloc_array(int, 1000)].  Add
    //@requires A->length == \length(A->data);
- back to ssa_get, call to ssa_len needs to be safe.  Add
    //@requires A->length == \length(A->data);


Representation invariants
=========================
- every function that takes an SSA as a parameter needs preconditions
    //@requires A != NULL;
    //@requires A->length == \length(A->data);
  and also
    //@requires is_sorted(A->data, 0, A->length);
  which we didn't consider yet
- every function that returns or modifies an SSA needs the same as //@ensures
- these are fundamental properties describing what it means to be the representation
  of a valid SSA (coherence)
  . they should always hold of an SSA: they are invariants, not loop invariants, but
  . REPRESENTATION INVARIANTS, or DATA STRUCTURE INVARIANTS
- gather them into a single function, is_ssa
- attempt #1
    bool is_ssa(ssa* A) {
      return A != NULL
          && \length(A->data) == A->length
          && is_sorted(A->data, 0, A->length);
    }
  Illegal to use \length in code
- attempt #2
    bool is_ssa(ssa* A)
    //@requires \length(A->data) == A->length;
    {
      return A != NULL
          && is_sorted(A->data, 0, A->length);
    }
  . will fail if A == NULL (safety), or if \length(A->data) != A->length
  . we want functions used in contracts to return true or false, not fail
- final attempt
     bool is_array_expected_length(string[] A, int length) {
       //@assert \length(A) == length;
       return true;
     }

     bool is_ssa(ssa* A) {
       return A != NULL
           && is_array_expected_length(A->data, A->length)
           && is_sorted(A);
     }
  . //@assert may fail, but failure is circumscribed
- alternative
    bool is_ssa(ssa* A) {
      if (A == NULL) return false;
      //@assert \length(A->data) == A->length;
      return is_sorted(A->data, 0, A->length);
    }
  . not as nicely packaged but it works
- representation invariants are NOT part of the interface
  . if implementation is correct, will always return true (if not, client has bigger problems)
  . opens the doors to client bypassing interface
    . hacking around implementation and testing if successful


Implementation II: functions (final)
====================================
- every function that takes an SSA as input must have
    //@requires is_ssa(A);
- every function that modifies an input SSA must have
    //@ensures is_ssa(A);
- every function that returns an SSA must have
    //@ensures is_ssa(\result);
- update/display implementation


Testing (from Dennis J Frailey via SIGSCE mailing list) -- OPTIONAL
=======
Ask students the following questions:
1. how many of you know whether the software on your smartphone or computer was
   written in a good programming style or using a clever algorithm or in a manner
   that programmers would consider good examples of how to program?
[Usual answer: none of them have any idea whether the software was well written or
not, although some seem to think along the lines of "if Apple (or Google or whatever)
did it, it is probably pretty good."]

2. how many of you care?
[Usual answer: most do not, so long as it works properly, and those who do care admit
they have no realistic way to find out how well it was written unless it is open
source software - which most don't know about yet.]

3. how many of you have software on your smart phone or computer that has failed to
   function properly?
[Usual answer: most know of at least one example of software failure and some give
a litany of problems with the software on their devices]

4. how many of you care?
[Usual answer: most care quite a bit.]

5. if you were in charge, what would you do to make sure the software has as few
   failures as possible?
[Usual answer: this generally results in a good discussion and eventually they get
down to well-stated requirements, good design techniques and practices, good coding
practices and thorough, well-conceived testing methods.  It's common at this point
for them to point out that if they, the end user, can find the failures in the
software, the programmers surely ought to have been able to find them by testing
them properly.  This leads to a discussion of the programmer being able to put him
or her self into the customer's shoes.]

This is the point where I justify focusing on requirements and testing before I get
into programming techniques or algorithms for various purposes, and I emphasize the
"test first" concept that was popularized by the "agile" community but has actually
been well known and frequently practiced in the professional programming community for
many decades. [In a nutshell, "test first" means you don't write any code until you
know how you will test it.]
