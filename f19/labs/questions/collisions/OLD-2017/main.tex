\section*{Finding collisions in hash functions}

\bgroup
\input{asciichart.tex}

Recall that a hash function $h(k)$ takes a key $k$ as its argument and
returns some integer, a \emph{hash value}; we can then calculate
$\textrm{abs}(h(k) \% m)$ to get an index into our hash table. In this
lab you will be examining various hash functions and exploiting their
inefficiencies to make them collide.

Let string $s$ of length $n$ ($n>0$) be denoted as
$s_0s_1s_2...s_{n-2}s_{n-1}$, where $s_i$ is the ASCII value of
character $i$ in string $s$. (A partial ASCII table is given to the
right.) We define five hash functions as follows:

\medskip
\lstinline'hash_len': $h(s) = n$

\medskip
\lstinline'hash_add':
$h(s) = s_0 + s_1 + s_2 + \dots + s_{n-2} + s_{n-1}$

\medskip
\lstinline'hash_mul32':

$h(s) = ( \dots ((s_0 \times 32 + s_1) \times 32 + s_2) \times 32 \dots + s_{n-2}) \times 32 + s_{n-1}$

\medskip
\lstinline'hash_mul31':

$h(s) = ( \dots ((s_0 \times 31 + s_1) \times 31 + s_2) \times 31 \dots + s_{n-2}) \times 31 + s_{n-1}$

\medskip
\lstinline'hash_lcg':

$h(s) = f(f( \dots f(f(f(s_0) + s_1) + s_2) \dots + s_{n-2}) + s_{n-1})$

where $f(x) = 1664525 \times x + 1013904223$

\medskip These five hash functions have been implemented for you and
can be run from the command line:

\begin{lstlisting}[language={[coin]C}]
% hash_len
Enter a string to hash: bar
   hash value = 3
   hashes to index 3 in a table of size 1024
Another? (empty line quits): snafu
   hash value = 5
   hashes to index 5 in a table of size 1024
Another? (empty line quits):
\end{lstlisting}


Note that the command line hashing tool also reports where the element with the
given key will hash given a table size of 1024. We care, however, about hash
functions that \emph{always} collide under a table of any size. Thus, you'll be
looking for hash functions that hash to the same value.
\egroup

\newpage
The first exercise requires you to mathematically reverse-engineer one of the
simpler hash functions:

\begin{part}
  Find three or more strings, each string containing three or more
  characters, that would always collide because they have the same
  hash value using \lstinline'hash_add'.
\end{part}

\begin{solution}
Example Solution: ADG, BDF, CDE\\
Strategy: add to one character while subtracting from the other.
\end{solution}

Now, you'll implement one of the hash functions and then use your
implementation to find collisions that always occur because the
strings hash to the same value.  The \lstinline'hash_mul31' function
is slightly more complicated --- it's actually the default string
hashing function used in Java! It's still possible to find hash value
collisions by doing some math with pen and paper, though.

\begin{part}
  Implement your own version of \lstinline'hash_mul31' as a function
  that takes a single non-empty string as its argument and returns an
  integer representing the hash value for that string using the
  formula given on the previous page.  Demonstrate that it works
  correctly by comparing the results of this function in
  \lstinline'coin' with the answers from the \lstinline'hash_mul31'
  binary. Your function does not need to compute the hash index for a
  table of size 1024.

It should be very easy to cut-and-paste-and-modify this function to create your
own implementation of \lstinline'hash_lcg' as well.
\end{part}

\begin{solution}
\begin{lstlisting}[language={C}]
int hash_mul31(string s) {
    int len = string_length(s);
    if (len == 0) {
        return 0;
    }
    char c = string_charat(s, len-1);
    return char_ord(c) + 31*hash_mul31(string_sub(s, 0, len-1));
}
\end{lstlisting}
\end{solution}

\begin{part}
  Using your implementation of \lstinline'hash_mul31', find three or
  more strings, each containing three or more characters, that do not
  have the same exact hash values but do collide in a hash table of
  size 1024.
\end{part}

\begin{solution}
Example Solution: 000, 121, 23Q
\end{solution}

The more complicated a hash function gets, the more you may need to
rely on ``brute force search'' --- trying a lot of words and seeing
which ones match.

\begin{part}
  Using \lstinline'hash_lcg', find three or more strings, each
  containing three or more characters, that do not have the same exact
  hash values but do collide in a hash table of size 1024.
\end{part}

\begin{solution}
Example Solution: 000, !!?h, !\#P9
\end{solution}

\begin{part}
  Only two words in the Scrabble dictionary have the same hash value
  under \lstinline'hash_lcg': ``charmeuse'' and ``historicizes''. (The
  hash value is 706668240.) Can you find two other strings with the
  same hash value?
\end{part}

\begin{part}
The empty string has the hash value 0 under \lstinline'hash_lcg', and the closest
any Scrabble dictionary word comes to this hash value is ``gristlier'' (the
hash value is -17760). Can you find a non-empty string with a hash value closer
to 0? If you find any that \emph{are} closer than ``gristlier'', submit it to
the course infrastructure (ask TA your about this) and you'll be added
to the scoreboard!
\end{part}

Our \lstinline'hash_lcg' produces a hash value that is a 32-bit C0
integer. More complex hash functions produce more bits: ``SHA256'' is
a hashing algorithm that produces a 256-bit hash value, and ``Skein
1024'' is a hash function that produces a 1024-bit hash value.

For a class of hash functions called \emph{cryptographic hash
  functions}, brute force search is thought to be the best known way
to create collisions. If you've ever heard of ``mining Bitcoins,'' it
largely involves using brute-force search to solve problems like (1.f)
for SHA256.
