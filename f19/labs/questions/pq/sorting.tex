\section*{Sorting using priority queues}

In this part, you'll use the priority queue interface to sort an
array.  Your solution should work with any implementation of priority
queues. If priority queues are implemented as heaps the way we did in
class, sorting the array should have worst-case complexity in $O(n
\log n)$.

\textbf{Hint:} \emph{Most of the work you have to do is in correctly
  instantiating the client interface.} Don't re-implement the heap
data structure, and don't re-implement a sort like mergesort or
quicksort. Do respect the interface of priority queues.

\begin{part}\TAGS{function-pointer, pq, sorting, void-star}
  In file \lstinline'pqsort.c1', use priority queues to finish the
  implementation of \lstinline'sort_by_word', which takes an array of
  frequency information structs and sorts them ASCII-betically by
  the words.

  \begin{solution}
    \begin{lstlisting}
bool word_higher_priority(void* e1, void* e2)
//@requires \hastag(freqinfo*, e1) && \hastag(freqinfo*, e2);
{
  return string_compare(((freqinfo*)e1)->word, ((freqinfo*)e2)->word) < 0;
}

void sort_by_word(freqinfo*[] A, int len)
//@requires \length(A) == len;
{
  pq_t P = pq_new(&word_higher_priority);
  for (int i = 0; i < len; i++) {
    pq_add(P, (void*)A[i]);
  }
  for (int i = 0; i < len; i++) {
    A[i] = (freqinfo*)pq_rem(P);
  }
}
    \end{lstlisting}
    \underline{Output}:
    \begin{lstlisting}
"a" has frequency 10144200
"and" has frequency 10741073
"be" has frequency 12545825
"for" has frequency 3281454
"have" has frequency 4303955
"i" has frequency 3978265
"in" has frequency 6996437
"it" has frequency 3872477
"of" has frequency 10343885
"that" has frequency 3430996
"the" has frequency 22038615
"to" has frequency 6332195
"with" has frequency 2683014
"you" has frequency 3081151
    \end{lstlisting}
  \end{solution}
\end{part}

\begin{part}\TAGS{function-pointer, pq, sorting, void-star}
  In file \lstinline'pqsort.c1', use priority queues to finish the
  implementation of \lstinline'sort_by_count', which takes an array of
  frequency information structs and sorts them by increasing frequency.

  \begin{solution}
\begin{lstlisting}
bool count_higher_priority(void* e1, void* e2)
//@requires \hastag(freqinfo*, e1) && \hastag(freqinfo*, e2);
{
  return ((freqinfo*)e1)->count < ((freqinfo*)e2)->count;
}

void sort_by_count(freqinfo*[] A, int len)
//@requires \length(A) == len;
{
  pq_t P = pq_new(&count_higher_priority);
  for (int i = 0; i < len; i++) {
    pq_add(P, (void*)A[i]);
  }
  for (int i = 0; i < len; i++) {
    A[i] = (freqinfo*)pq_rem(P);
  }
}
	\end{lstlisting}
	\underline{Output}:
	\begin{lstlisting}
"with" has frequency 2683014
"you" has frequency 3081151
"for" has frequency 3281454
"that" has frequency 3430996
"it" has frequency 3872477
"i" has frequency 3978265
"have" has frequency 4303955
"to" has frequency 6332195
"in" has frequency 6996437
"a" has frequency 10144200
"of" has frequency 10343885
"and" has frequency 10741073
"be" has frequency 12545825
"the" has frequency 22038615
	\end{lstlisting}
  \end{solution}
\end{part}

Compile and test your code by running this command:

\lstinline[language={[coin]C}]'% cc0 -d -x pq.c1 pqsort.c1'

The first set of outputs should be sorted by word, and the second set of
outputs should be sorted by frequency.

\twoPT