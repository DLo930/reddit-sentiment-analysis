\section*{Generic priority queues}

In this lab, we'll use an implementation of generic priority queues.
We implemented priority queues as heaps in class.

\begin{lstlisting}
  /************************/
  /*** Client interface ***/
  /************************/
  typedef void* elem;

  // f(x,y) returns true if e1 has STRICTLY higher priority than e2
  typedef bool has_higher_priority_fn(elem e1, elem e2);

  /*************************/
  /*** Library interface ***/
  /*************************/
  // typedef ______* pq_t;

  bool pq_empty(pq_t P)
    /*@requires P != NULL; @*/ ;

  pq_t pq_new(has_higher_priority_fn* prior)
    /*@requires prior != NULL; @*/
    /*@ensures \result != NULL && pq_empty(\result); @*/ ;

  void pq_add(pq_t P, elem e)
    /*@requires P != NULL; @*/ ;

  elem pq_rem(pq_t P)
    /*@requires P != NULL && !pq_empty(P); @*/ ;

  int pq_size(pq_t P)
    /*@requires P != NULL; @*/ ;

\end{lstlisting}

Unlike the priority queues from class, these priority queues are
unbounded (in particular, there is no \lstinline'pq_full' function).
Note that the interface provides the function \lstinline'pq_size(H)',
which returns the number of elements in priority queue \lstinline'H'.
The code you see here is from \lstinline'pq.c1', which you'll need to
compile along with your code for this assignment. While the priority
queue interface we give you is, in fact, implemented with the heap
data structure (with the unbounded array trick to be used so that they
don't get full), you should respect the interface and not rely on this
assumption for anything except efficiency.

\onePT