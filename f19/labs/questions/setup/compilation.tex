\subsection*{Running a C0 Program}

You can execute a C0 program by either compiling it into executable
code or loading it into an interpreter.  You invoke the C0 compiler
(\lstinline[language={[coin]C}]'cc0') and interpreter
(\lstinline[language={[coin]C}]'coin') from the command line.

The \emph{compiler} translates your program into a lower level
(machine) version of the code that can be executed by your computer.
It first checks for syntax errors and will abort with an error message
if it finds a syntax error.

\begin{part}\TAGS{compilation}
  Compile your code using the \lstinline[language={[coin]C}]'cc0'
  compiler:
\begin{lstlisting}[language={[coin]C}, belowskip=0ex]
   % cc0 -d factorial.c0
\end{lstlisting}
This runs the compiler with debug mode on
(\lstinline[language={[coin]C}]'-d').  During execution, the debug
mode checks all the code annotations starting with \lstinline'//@'.
You will learn about them in class.
\end{part}
\vspace{-2ex}

If there are no syntax errors, the \lstinline[language={[coin]C}]'cc0'
compiler returns to the command prompt without saying anything else.
Running \underline{\lstinline[language={[coin]C}]'ls'} will show you a
new file named \lstinline[language={[coin]C}]'a.out', which is the
executable version of your program. If you have syntax errors during
compilation, go back into the file with an editor and correct them.

\enlargethispage{5ex}
\begin{part}\TAGS{compilation, unix}
  Run the program:
\begin{lstlisting}[language={[coin]C}, belowskip=0ex]
  % ./a.out
\end{lstlisting}
The first dot says to look in the current directory and run the
\lstinline[language={[coin]C}]'a.out' executable file. This will cause
the \lstinline'main()' function in your program to launch, which
prints the values of $0!$ through $9!$ in the terminal window, one per
line.
\end{part}
\vspace{-2ex}

%This shows how to \emph{compile} and \emph{run} your programs.
Alternatively, you can use the C0 interpreter to execute your program.
An \emph{interpreter} checks a program for syntax errors
%, translates it into machine code, and runs the resulting code
and runs it step by step.  This is a good way to interact with your
program in real time to test it.

\begin{part}\TAGS{interpreter}
  Run your program in the \lstinline[language={[coin]C}]'coin'
  interpreter, starting it with %
  \lstinline[language={[coin]C}]'coin -d  factorial.c0' %
  and entering in the C0 statements as shown below.
\begin{lstlisting}[language={[coin]C}, belowskip=-2ex]
  % coin -d factorial.c0
  C0 interpreter (coin)
  Type `#help' for help or `#quit' to exit.
  --> factorial(2);
  --> factorial(3);
\end{lstlisting}
%  --> factorial(4);
%  --> factorial(10);
%  --> factorial(17);
\end{part}
Exit the interpreter by entering \lstinline[language={[coin]C}]'#quit'.

\begin{comment}
Some of the outputs \lstinline[language={[coin]C}]'coin' gives should
strike you as odd. We'll learn about what's going on in class.

\begin{part}\TAGS{intepreter}
  Factorial $n!$ is only defined on non-negative numbers. Try to
  compute a non-existent factorial:
\begin{lstlisting}[language={[coin]C}, belowskip=-1.5ex]
  --> factorial(-1);
\end{lstlisting}
\end{part}

You should see an annotation failure.  This is because our factorial
function starts with the requirement: \lstinline'//@requires n >= 0;'.
Since we called this function with a value for $n$ that does not
satisfy this requirement, we get an annotation failure since it
doesn't make sense to run this function with $n = -1$.

\begin{part}\TAGS{intepreter}
  Exit the interpreter by entering
  \lstinline[language={[coin]C}]'#quit'.  Start it again, this time without the
  \lstinline[language={[coin]C}]'-d' flag by typing
  \lstinline[language={[coin]C}]'coin factorial.c0' at the prompt.  Now, run
  \lstinline[language={[coin]C}]'factorial(-1);' again.  What do you observe?
\end{part}
\end{comment}
