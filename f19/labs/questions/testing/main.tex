\section*{Testing code}

The file \lstinline'testlib.c0' contains the following helper
functions, which may be useful while testing:
\begin{lstlisting}[belowskip=0pt]
bool contains_no_dupes(int[] A, int n)
  /*@requires 0 <= n && n <= \length(A); @*/ ;
bool is_sorted(int[] A, int n)
  /*@requires 0 <= n && n <= \length(A); @*/ ;
bool arr_eq(int[] A, int n, int[] B, int m)
/*@requires n <= \length(A) && m <= \length(B); @*/ ;
int[] int_array_from_string(string s);
\end{lstlisting}
%void test_completed(string description, bool success);


\begin{part}\TAGS{testing}
  When writing test cases it is often useful to write a function that
  executes a test and returns whether the test was successful or not.
  Write the following function in \lstinline'set-test.c0' where, when
  given two arrays and the expected result, it checks that the
  \lstinline'intersect' function provided the correct answer and then
  returns \lstinline'true' if the answer is correct and
  \lstinline'false' otherwise.
\begin{lstlisting}
  bool test_one(int[] A, int a, int[] B, int b, int[] solution, int s)
  /*@requires 0 <= a && a <= \length(A)
           && 0 <= b && b <= \length(B)
           && 0 <= s && s <= \length(solution); @*/
\end{lstlisting}
\begin{solution}
\begin{lstlisting}
  bool test_one(int[] A, int a, int[] B, int b, int[] solution, int s)
  //@requires 0 <= a && a <= \length(A);
  //@requires 0 <= b && b <= \length(B);
  //@requires 0 <= c && c <= \length(solution);
  {
      int[] res = alloc_array(int, a);
      int ret = intersect(A, a, B, b, res);
      if (ret != s) return false;
      return arr_eq(res, ret, solution s);
  }
\end{lstlisting}
\end{solution}
\end{part}

\begin{part}\TAGS{testing}
  Inside function \lstinline'run_tests' (in file
  \lstinline'set-test.c0'), create an \emph{exhaustive} battery of
  tests for \lstinline'intersect'.  It should return \lstinline'true'
  when run against a correct implementation of \lstinline'intersect',
  and \lstinline'false' when run against a buggy implementation.  We
  will execute it against 20 different student implementations of
  \lstinline'intersect', some correct and many broken in different ways.

  % Write \emph{exhaustive} test cases for \lstinline'intersect' to
  % catch the bugs in the broken implementations in the function
  % \lstinline'run_tests' (in file \lstinline'set-test.c0'). The return
  % value of \lstinline'run_tests' should be \lstinline'true' if all
  % tests are successful and \lstinline'false' if any fail.


We recommend that you create several helper functions, each of which
tests some aspects of \lstinline'intersect' (think basic tests, tests
about duplicates, edge cases, etc) and returns a \lstinline'bool'
which indicates whether all tests passed --- it will be helpful if
each helper function prints some informative message before returning
(e.g., ``Edge case tests passed'', or ``Test with [3,2,1] failed'').
You can combine the result of all these auxiliary functions with an
AND (\lstinline'&&' in C0) before returning from \lstinline'run_tests'.


%   Then, from inside
% \lstinline'run_tests', you can save the result of calling each of your
% test functions, and pass each result in a call to
% \lstinline'test_completed' (along with a string that describes the
% test, like ``Edge case tests'').  This will pretty-print the
% description of the test and the result, as you can see below.
% Remember that \lstinline'run_tests' should return \lstinline'true'
% only if all of your tests passed, which fortunately is just the AND
% ($\&\&$) of all your test functions' results.

Run \lstinline'./check-test'.  This will run your tests on 20 student
versions of \lstinline'intersect', some of which are correct
implementations, and some of which are incorrect.  The program
\lstinline'./check-test' can also be run against a specific student by
calling it with \lstinline'./check-test -s <student_name>' (run it
first without arguments to get the student names).  \textbf{Your tests
  must all pass on correct implementations in order to get credit}.  A
sample output from that program is below:

\begin{lstlisting}[language={[coin]C}]
% ./check-test
Testing student aardvark (Correct Implementation)
	Test 1... Passed
	Test 2... Failed
	Test 3... Passed
Student code failed a test (expected to pass)
...
Testing student rjsimmon (Incorrect Implementation)
	Test 1... Passed
	Test 2... Failed
	Test 3... Failed
Student code failed a test (expected to fail)... Good!
...
Tested 20 students, 9 students had no failed tests, 11 students had failed tests.
(No credit to be awarded --- your code fails students with correct code)
\end{lstlisting}
\end{part}

\enlargethispage{5ex}
\begin{part}\onePT[2.2ex]\TAGS{testing}
Your \lstinline'run_tests' returns \lstinline'true' on all correct
implementations of \lstinline'intersect'.
\end{part}

\begin{part}\twoPT[2.3ex]\TAGS{testing}
Additionally, your \lstinline'run_tests' returns \lstinline'false' on
half the buggy implementations of \lstinline'intersect'.
\end{part}

\begin{part}\threePT[2.3ex]\TAGS{testing}
Additionally, your \lstinline'run_tests' returns \lstinline'false' on
all the buggy implementations of \lstinline'intersect'.
\end{part}

\begin{solution}
  Just look at the last line of the output in parentheses --- it will
  tell you how many points to give (of course, if it says no credit
  that actually means 1 point but whatever).

  The tests have the following bugs:\\
  \begin{center}
  \begin{tabular}{| m{3cm} | m{12cm} |}
  	\hline \centering aardvark & Always returns the empty intersection\\\cline{1-2}
  	\centering akholbre & Inserts duplicates if either of A or B has any duplicates\\\cline{1-2}
  	\centering ameyers & Doesn't Sort\\\cline{1-2}
  	\centering astanesc & Inserts elements into intersection array starting at index 1\\\cline{1-2}
  	\centering bovik & changes A, B and intersection such that they are all consistent with each other (1, 2, 3, 4 ...)\\\cline{1-2}
  	\centering clavicka & Doesn't remove duplicates from the intersection (i.e. if a given pair of arrays has the same duplicate twice, this shows up again in the intersection. Ex: [1, 2, 3] and [1, 1, 2])\\\cline{1-2}
  	\centering cmrose & Replaces the intersection array with whatever A is\\\cline{1-2}
  	\centering dsimon & Fails if A or B is unsorted\\\cline{1-2}
  	\centering eugeneh & ignores the first element of A and B\\\cline{1-2}
  	\centering hjx & only sorts the intersection up to length 4\\\cline{1-2}
  	\centering ianl1 & Only goes up to n in both A and B when checking for duplicates\\\cline{1-2}
  	\centering jaburns & Assumes both A and B are at least length 1\\\cline{1-2}
  	\centering jacobo & Returns the correct array, but with the wrong length (off by one, as long as it doesn't violate the ensures)\\\cline{1-2}
  	\centering juhank & Only checks for duplicates up to length 6\\\cline{1-2}
  	\centering kdhabhali & Only goes up to m in both A and B when checking for duplicates\\\cline{1-2}
  	\centering rjsimmon & just replaces the intersection with B\\\cline{1-2}
  	\centering wanshenl & Includes a 0 in the intersection if either of the two arrays have a 0\\\cline{1-2}
  	\centering zsnow & overwrites the last element of A with the first element of B, making the first element of B to never be considered\\\cline{1-2}
  	\end{tabular}
  	\end{center}
\end{solution}
