\section*{Memoization}

To avoid these redundant computations, we introduce a data structure
known as a \emph{memo table} --- in our case it will be an array of
integers.  The idea is that, the first time we compute the lagged
Fibonacci number for \lstinline'i', we store it at index \lstinline'i'
in the memo table.  Next time we need the \lstinline'i'-th
lagged Fibonacci number, we simply look it up in the table.

Saving the result of computations that we would do over and over is
called \emph{memoization}.  This requires a bit of extra space in the
form of the memo table, but it can save an enormous amount of time because
it avoids recomputing these results over and over.  This is known as a
\emph{space-time trade-off}, a really important concept in computer science.

\begin{part}\TAGS{array, complexity}
  Using the slow \lstinline'LF' function, write a specification
  function \lstinline'is_memo_table' that checks that, for all
  $\lstinline'i' \in [0, \lstinline'len']$ (note the inclusive upper
  bound!), \lstinline'M[i]' is \emph{either} 0 or
  \lstinline'LF(i,j,k)'.

\begin{lstlisting}
bool is_memo_table(int[] M, int len, int j, int k)
//@requires 0 <= len && len < \length(M);
\end{lstlisting}
\onePT[-1ex]
\end{part}

\begin{part}\TAGS{array, complexity}
  Write a new recursive function \lstinline'lf_memo', which returns
  the same results as \lstinline'LF' but uses a memo table to avoid
  re-computing results by writing them into an array of integers.

  Before the function does any work, it should check whether the
  result is already in the memo table, and if so just return that
  value.  If you do have to compute the number, store it in the memo
  table before returning, so that future calls will not have to do the
  same work again.

  \textbf{DANGER!} Do not use the function \lstinline'LF' in your
  \lstinline'lf_memo' function outside of contracts!  This will
  reintroduce the problem where we perform many redundant
  computations, which defeats the entire purpose of our memo table!
  At this point, \lstinline'LF' has become a specification function
  for us.

\begin{lstlisting}[belowskip=0pt]
int lf_memo(int[] M, int i, int j, int k)
//@requires 0 < j && j < k;
//@requires 0 <= i && i < \length(M);
//@requires is_memo_table(M, i, j, k);
//@ensures is_memo_table(M, i, j, k);
//@ensures \result == LF(i, j, k);
\end{lstlisting}
\end{part}

\begin{part}\TAGS{complexity}
  Using \lstinline'lf_memo' as a helper function, write the function
  \lstinline'fast_lf(i,j,k)' that initializes a new array and calls
  the helper to compute the lagged Fibonacci number.

\begin{lstlisting}[belowskip=0pt]
int fast_lf(int i, int j, int k)
//@requires 0 < j && j < k;
//@requires 0 <= i;
//@ensures \result == LF(i, j, k);
\end{lstlisting}
\end{part}

\begin{part}\TAGS{complexity, testing}
  Check that your \lstinline'fast_lf' function works by running it in
  coin with \lstinline'-d' for some small Fibonacci numbers. Then run
  it in coin without \lstinline'-d' so that you actually notice a
  speedup. Running with \lstinline'-d' is slow as \lstinline'LF' is
  called in the postcondition.
\end{part}

\begin{part}\TAGS{complexity, testing}
  What is the 54,321\textsuperscript{st} Fibonacci number (mod
  $2^{32}$, of course)? What is the 100,000\textsuperscript{th} lagged
  Fibonacci number with $j = 1$ and $k = 25$?
\end{part}

\begin{solution}
\begin{lstlisting}[language={[coin]C}]
--> fast_lf(54321,1,2);
-1387518878 (int)
--> fast_lf(100000,1,25);
738186127 (int)
-->
\end{lstlisting}
\end{solution}

Now would be a good time to compare notes with your neighbors if you
haven't done that already. How do their functions look the same? How
do they look different?

\twoPT

%% \begin{part}\TAGS{testing}
%% Trace out the computation of \lstinline'fast_lf(1,2,5)' mimicking the
%% provided trace of \lstinline'lf(1,2,5)'. Include the state of the array.
%% \end{part}
